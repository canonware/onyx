%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% nxo_regsub portion of Onyx Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{nxo\_regsub}
\label{nxo_regsub}
\index{nxo_regsub@\classname{nxo\_regsub}{}}

The \classname{nxo\_regsub} class is a subclass of the \classname{nxo} class.

\subsubsection{API}
\begin{capi}
\label{nxo_regsub_new}
\index{nxo_regsub_new@\cfunc{nxo\_regsub\_new}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_regsub\_new}{cw\_nxo\_t *a\_nxo, cw\_nx\_t
*a\_nx, const cw\_uint8\_t  *a\_pattern, cw\_uint32\_t a\_plen, cw\_bool\_t
a\_global, cw\_bool\_t a\_insensitive, cw\_bool\_t a\_multiline, cw\_bool\_t
a\_singleline, const cw\_uint8\_t *a\_template, cw\_uint32\_t a\_tlen}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a regsub \classname{nxo}.
		\item[a\_nx: ]
			Pointer to an \classname{nx}.
		\item[a\_pattern: ]
			Pointer to a string that specifies a regular expression.
		\item[a\_plen: ]
			Length of \cvar{a\_pattern}.
		\item[a\_global: ]
			Substitute as many times as possible if TRUE.
		\item[a\_insensitive: ]
			Match with case insensitivity if TRUE.
		\item[a\_multiline: ]
			Treat input as a multi-line string if TRUE.
		\item[a\_singleline: ]
			Treat input as a single line, so that the dot
			metacharacter matches any character, including a
			newline.
		\item[a\_template: ]
			Pointer to a string that specifies a substitution
			template.
		\item[a\_tlen: ]
			Length of \cvar{a\_template}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO: ] Success.
			\item[NXN\_regexerror: ] Regular expression error.
			\end{description}
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{capilist}
\label{nxo_regsub_subst}
\index{nxo_regsub_subst@\cfunc{nxo\_regsub\_subst}{}}
\citem{\cfunc[void]{nxo\_regsub\_subst}{cw\_nxo\_t *a\_nxo, cw\_nxo\_t 
*a\_thread, cw\_nxo\_t *a\_input, cw\_nxo\_t *r\_output, cw\_uint32\_t
*r\_count}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a regsub \classname{nxo}.
		\item[a\_thread: ]
			Pointer to a thread \classname{nxo}.
		\item[a\_input: ]
			Pointer to a string \classname{nxo}.
		\item[r\_output: ]
			Pointer to an \classname{nxo} to dup a string reference
			to.
		\item[r\_count: ]
			Pointer to a \ctype{cw\_uint32\_t}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[*r\_output: ]
			A string that was created by substituting regular
			expression matches according to a substitution template.
		\item[*r\_count: ]
			Number of substitutions made.  If 0 substitutions were
			made, \cvar{*r\_output} is a duplicate of
			\cvar{a\_input}, rather than a copy.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Create a string by substituting according to \cvar{a\_template}
		for each substring within \oparg{input} that matches a regular
		expression.

		As a side effect, set the thread's match cache, which can be
		queried via \cfunc{nxo\_regex\_submatch}{}.
	\end{capilist}
\label{nxo_regsub_nonew_subst}
\index{nxo_regsub_nonew_subst@\cfunc{nxo\_regsub\_nonew\_subst}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_regsub\_nonew\_subst}{cw\_nxo\_t *a\_thread,
const cw\_uint8\_t *a\_pattern, cw\_uint32\_t a\_plen, cw\_bool\_t a\_global,
cw\_bool\_t a\_insensitive, cw\_bool\_t a\_multiline, cw\_bool\_t a\_singleline,
const cw\_uint8\_t *a\_template, cw\_uint32\_t a\_tlen, cw\_nxo\_t *a\_input,
cw\_nxo\_t *r\_output, cw\_uint32\_t *r\_count}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_thread: ]
			Pointer to a thread \classname{nxo}.
		\item[a\_pattern: ]
			Pointer to a string that specifies a regular expression.
		\item[a\_plen: ]
			Length of \cvar{a\_pattern}.
		\item[a\_global: ]
			Substitute as many times as possible if TRUE.
		\item[a\_insensitive: ]
			Match with case insensitivity if TRUE.
		\item[a\_multiline: ]
			Treat input as a multi-line string if TRUE.
		\item[a\_singleline: ]
			Treat input as a single line, so that the dot
			metacharacter matches any character, including a
			newline.
		\item[a\_template: ]
			Pointer to a string that specifies a substitution
			template.
		\item[a\_tlen: ]
			Length of \cvar{a\_template}.
		\item[a\_input: ]
			Pointer to a string \classname{nxo}.
		\item[r\_output: ]
			Pointer to an \classname{nxo} to dup a string reference
			to.
		\item[r\_count: ]
			Pointer to a \ctype{cw\_uint32\_t}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO: ] Success.
			\item[NXN\_regexerror: ] Regular expression error.
			\end{description}
		\item[*r\_output: ]
			A string that was created by substituting regular
			expression matches (specified by \cvar{a\_pattern})
			according to \cvar{a\_template}.
		\item[*r\_count: ]
			Number of substitutions made.  If 0 substitutions were
			made, \cvar{*r\_output} is a duplicate of
			\cvar{a\_input}, rather than a copy.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Create a string by substituting according to \cvar{a\_template}
		for each substring within \oparg{input} that matches a regular
		expression.

		As a side effect, set the thread's match cache, which can be
		queried via \cfunc{nxo\_regex\_submatch}{}.

		This function combines \cfunc{nxo\_regsub\_new}{} and
		\cfunc{nxo\_regsub\_subst}{} in such a way that no Onyx regsub
		object is created, thus providing a more efficient way of doing
		a one-off subst.
	\end{capilist}
\end{capi}

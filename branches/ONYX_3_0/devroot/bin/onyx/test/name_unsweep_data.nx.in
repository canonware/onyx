%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (C) 1996-2002 Jason Evans <jasone@canonware.com>.
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%    notice(s), this list of conditions and the following disclaimer
%    unmodified other than the allowable addition of one or more
%    copyright notices.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice(s), this list of conditions and the following disclaimer in
%    the documentation and/or other materials provided with the
%    distribution.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY
% EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
% BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
% OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
% EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx 3.0.0
%
% This file is processed by nx_gen.nx to produce a more compact embedded version
% in nx_nxcode.c (normal build) and nx_bootstrap.c (development bootstrap).  In
% order to make changes to this file take effect in the bootstrap interpreter,
% either type:
%
%   cook bootstrap
%
% or
%
%   cat nx.nx | onyx nx_gen.nx > nx_boostrap.c
%
% The end result of executing this file is a procedure (executable array).  In
% order to support output that differs according to configuration options, a
% string is constructed, then evaluated.
%
% The output of running sprints on the procedure must be evaluatable, which
% means that certain language features such as immediate evaluation must be
% avoided.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Initial string with an opening brace to defer execution, to which other
% strings are catenated.
`{'

`
systemdict begin

%
% sprintsdict implements syntactic printing to strings for every type.
%
/sprintsdict <
    /arraytype {
	% %array %depth
	dup 0 gt {
	    1 index dup echeck {
		pop
		`_{'
	    }{
	    xcheck {
		`{'
	    }{
		`['
	    } ifelse
	    } ifelse

	    % %array %depth %accum
	    2 index length 1 gt {
		% %array %depth %accum
		0 1 4 index length 2 sub {
		    % %array %depth %accum %i
		    3 index exch get
		    2 index 1 sub
		    % %array %depth %accum %el %rdepth
		    1 index type sprintsdict exch get eval
		    catenate
		    % %array %depth %accum %el %rdepth
		` ' catenate
		} for
	    } if
	    % %array %depth %accum

	    2 index length 0 gt {
		2 index dup length 1 sub get
		2 index 1 sub
		% %array %depth %accum %el %rdepth
		1 index type sprintsdict exch get eval
		catenate
	    } if
	    % %array %depth %accum

	    exch pop
	    % %array %accum
	    exch dup echeck {
		pop
		`}_'
	    }{
	    xcheck {
		`}'
	    }{
		`]'
	    } ifelse
	    } ifelse
	    catenate
	    % %accum
	}{
	    pop pop
	    `-array-'
	} ifelse
    }
    /booleantype {
	pop
	cvs
    }
' catenate
1 1 eq {
    `
    /conditiontype {
	pop pop
	`-condition-'
    }
    ' catenate
} if
`
    /dicttype {
	% %dict %depth
	dup 0 gt {
	    % Update recursion depth.
	    1 sub

	    0
	    `<'

	    % %dict %rdepth %i %accum
	    3 index {
		% %dict %rdepth %i %accum %key %value
		exch 4 index
		% %dict %rdepth %i %accum %value %key %rdepth
		1 index type sprintsdict exch get eval
		` ' catenate
		% %dict %rdepth %accum %i %value %keystr
		exch 4 index
		% %dict %rdepth %i %accum %keystr %value %rdepth
		1 index type sprintsdict exch get eval
		% %dict %rdepth %i %accum %keystr %valstr
		catenate catenate
		% %dict %rdepth %i %accum

		% Update counter.
		exch 1 add dup 4 index length lt {
		    % %dict %rdepth %accum %i
		    exch
		    ` ' catenate
		    % %dict %rdepth %i %accum
		}{
		    % Last element.
		    exch
		    % %dict %rdepth %accum
		} ifelse
	    } foreach
	    % %dict %rdepth %i %accum

	    4 1 roll pop pop pop
	    % %accum
	    `>'
	    catenate
	    % %accum
	}{
	    pop pop
	    `-dict-'
	} ifelse
    }
    /filetype {
	pop pop
	`-file-'
    }
    /finotype {
	pop pop
	`-fino-'
    }
    /hooktype {
	% %hook %depth
	exch hooktag
	% %depth %tag
	dup type /nulltype ne {
	    exch 1 sub
	    % %tag %rdepth
	    1 index type sprintsdict exch get eval
	    % %tagstr
	    `=' exch catenate
	    `=' catenate
	}{
	    pop pop
	    `-hook-'
	} ifelse
    }
    /integertype {
	pop
	cvs
    }
    /marktype {
	pop pop
	`-mark-'
    }
' catenate
1 1 eq {
    `
    /mutextype {
	pop pop
	`-mutex-'
    }
    ' catenate
} if
`
    /nametype {
	pop
	dup cvs
	exch xcheck not {
	    `/' exch catenate
	} if
    }
    /nulltype {
	pop pop
	`null'
    }
    /operatortype {
	pop
	cvs
	dup `-operator-' ne {
	    `--' dup 3 1 roll
	    catenate catenate
	} if
    }
    /pmarktype {
	pop pop
	`-pmark-'
    }
' catenate

1 1 eq {
    `
    /realtype {
	pop
	cvs
    }
    ' catenate
} if
`
    /stacktype {
	% %stack %depth
	dup 0 gt {
	    `('

	    % %stack %depth %accum
	    2 index scount 1 gt {
		% %stack %depth %accum
		2 index scount 1 sub -1 1 {
		    % %stack %depth %accum %i
		    3 index dup 3 2 roll sindex spop
		    2 index 1 sub
		    % %stack %depth %accum %el %rdepth
		    1 index type sprintsdict exch get eval
		    catenate
		    % %stack %depth %accum %el %rdepth
		` ' catenate
		} for
	    } if
	    % %stack %depth %accum

	    2 index scount 0 gt {
		2 index dup sdup spop
		2 index 1 sub
		% %stack %depth %accum %el %rdepth
		1 index type sprintsdict exch get eval
		catenate
	    } if
	    % %stack %depth %accum

	    3 1 roll pop pop
	    % %accum
	    `)'
	    catenate
	    % %accum
	}{
	    pop pop
	    `-stack-'
	} ifelse
    }
    /stringtype {
	pop
	cvs
    }
    /threadtype {
	pop pop
	`-thread-'
    }
> def

% %object %depth sprints %string
/sprints {
    1 index type sprintsdict exch get eval
} def

/sprint {
    sprints print
    `\n' print flush
} def

%
% outputsdict implements formatted output to strings for every type.
%
/outputsdict <
    /integertype {
	% %int %flags

	% Get the base.
	dup /b known {
	    dup /b get
	}{
	    10
	} ifelse
	% %int %flags %base

	2 index exch cvrs
	% %int %flags %str

	% Prepend the sign if necessary.
	1 index /s known {
	    1 index /s get /+ eq {
		2 index 0 ge {
		    `+' exch catenate
		} if
	    } if
	} if
	% %int %flags %str
	3 2 roll pop
	% %flags %str
	exch
	% %str %flags
	outputsdict /stringtype get eval
	% %str
    }
' catenate
1 1 eq {
    `
    /realtype {
	% %real %flags

	% Determine precision past decimal point.
	dup /d known {
	dup /d get
	}{
	6
	} ifelse
	% %real %flags %precision
	
	% Determine whether to use decimal or exponential notation.
	1 index /e known {
	1 index /e get
	}{
	false
	} ifelse
	% %real %flags %precision %exp?

	3 index 3 1 roll
	% %real %flags %real %precision %exp?
	{
	% Use exponential notation.
	cves
	}{
	% Use decimal notation.
	cvds
	} ifelse
	% %real %flags %str

	% Prepend the sign if necessary.
	1 index /s known {
	1 index /s get /+ eq {
	    2 index 0 ge {
	    `+' exch catenate
	    } if
	} if
	} if
	% %real %flags %str
	3 2 roll pop exch
	% %str %flags

	outputsdict /stringtype get eval
	% %str
    }
    ' catenate
} if
`
    % Temporarily define.
    /_s {
	% Check for /w flag.  /w takes precedence over /n.
	dup /w known {
	    % Get padding character.
	    dup /p known {
		dup /p get
	    }{
		` '
	    } ifelse
	    % %str %flags %pad

	    1 index /w get
	    % %str %flags %pad %width
	    3 index length
	    % %str %flags %pad %width %len

	    dup 2 index le {
		% Pad string.
		% %str %flags %pad %width %len

		1 index string
		% %str %flags %pad %width %len %pstr

		% Fill %pstr with %pad.
		0 1 4 index 1 sub {
		    1 index exch 5 index putinterval
		} for
		% %str %flags %pad %width %len %pstr
		4 3 roll pop
		% %str %flags %width %len %pstr

		% Get the justification.
		3 index /j known {
		    3 index /j get
		}{
		    /r
		} ifelse
		% %str %flags %width %len %pstr %just

		dup /r eq {
		    pop
		    % Right justify.
		    % %str %flags %width %len %pstr
		    3 1 roll sub
		}{
		/l eq {
		    % Left justify.
		    % %str %flags %width %len %pstr
		    3 1 roll pop pop
		    0
		}{
		    % Center.
		    % %str %flags %width %len %pstr
		    3 1 roll sub 2 idiv
		} ifelse
		} ifelse
		% %str %flags %pstr %offset

		1 index exch
		% %str %flags %pstr %pstr %offset
		5 4 roll
		% %flags %pstr %pstr %offset %str
		putinterval
		% %flags %pstr
		exch
		% %pstr %flags
	    }{
		% No padding necessary.
		pop pop pop
	    } ifelse
	    % %str %flags
	}{
	    % %str %flags
	    dup /n known {
		% Truncate the string if it is too long.
		1 index length
		1 index /n get
		% %str %flags %len %max
		dup 2 index lt {
		    % Truncate.
		    exch pop
		    dup string
		    % %str %flags %max %nstr
		    dup
		    % %str %flags %max %nstr %nstr
		    5 4 roll
		    % %flags %max %nstr %nstr %str
		    4 3 roll
		    % %flags %nstr %nstr %str %max
		    0 exch getinterval
		    % %flags %nstr %nstr %substr
		    0 exch putinterval
		    % %flags %nstr
		    exch
		}{
		    pop pop
		} ifelse
		% %nstr %flags
	    } if
	    % %str %flags
	} ifelse
	% %str %flags

	pop
	% %str
    } def
    /stringtype /_s load

    % Most types can be handled identically.  The following code uses the
    % same procedure body for all of those types.
    %
    % The following block of code looks scary because it avoids deferred
    % execution in order to "bind" things correctly (we cannot use immediate
    % evaluation in this file).
    [
	% %object %flags

	% Get recursion depth.
	/dup cvx /r /known cvx [
	    /dup cvx /r /get cvx
	] cvx [
	    1
	] cvx /ifelse cvx
	% %object %flags %rdepth

	3 2 /roll cvx /exch cvx
	% %flags %object %rdepth
	/sprints cvx /exch cvx
	% %str %flags
	/_s load cve
	% %str
    ] cvx bind
    [
	/arraytype
	/booleantype
' catenate
1 1 eq {
    `
	/conditiontype
    ' catenate
} if
`
	/dicttype
	/filetype
	/finotype
	/hooktype
	/marktype
' catenate
1 1 eq {
    `
	/mutextype
    ' catenate
} if
`
	/nametype
	/nulltype
	/operatortype
	/pmarktype
	/stacktype
	/threadtype
    ]{
	% %proc %name
	exch dup
	% %name %proc %proc
    } foreach
    % Get rid of the extra copy of %proc.
    pop

    % Now that we are done using _s, undef it.
    currentdict /_s undef
> def

%
% Formatted output to a string.  Supported flags:
%
% All types:
%
% /n : maximum width
%    : %integer
% /w : minimum width
%    : %integer
% /j : justification
%    : /l, /c, /r
% /p : padding character
%    : `?'
% /r : recursion depth
%    : 0..n
%
% Integers only:
%
% /b : base
%    : 2..36
% /s : sign
%    : /+ /-
%
% Reals only:
%
% /d : digits of precision past decimal
%    : %integer (default 6)
% /e : exponential notation
%    : %boolean (default false)
%
% %obj %flags outputs %string
/outputs {
    dup type /dicttype ne {
	/typecheck throw
    } if
    1 index type
    % %obj %flags %type
    outputsdict exch get eval
} def

%obj %flags output -
/output {
    outputs print
} def

% - product %string
/product `Canonware Onyx' def

/pstack {
    ostack {
	1 sprint
    } foreach
    flush
} def

%
% %string %pattern search %post %pattern %pre true
% %string %pattern search %string false
%
/search {
    % Make sure the arguments are strings.
    % Pattern.
    dup type /stringtype ne {
	/typecheck throw
    } if
    % String.
    1 index type /stringtype ne {
	/typecheck throw
    } if

    % Make sure substring is not longer than string.
    dup length 2 index length le {
	% Use a nested looping algorithm.  The outer loop advances the
	% offset %s_i at which to start the search in the string %s,
	% and the inner loop compares byte by byte with the pattern %p.
	%
	% Take care not to cause a rangecheck error.
	0 1 3 index length 3 index length sub {
	    % %s %p %s_i

	    % Create a substring %s_sub of %s that is the same
	    % length as %p, starting at %s_i.
	    dup 3 index exch 3 index length getinterval

	    % %s %p %s_i %s_sub
	    dup length 1 sub 0 1
	    3 2 roll
	    {
		% %s %p %s_i %s_sub %offset
		dup 2 index exch get
		exch 4 index exch get
		ne {
		    % Not equal.  Exit the inner loop.
		    false exit
		} if
	    } for

	    % Check to see if the substring match failed.
	    dup type /booleantype eq {
		% %s %p %s_i %s_sub% false
		% Failure.  Clean up.
		pop pop pop
	    }{
		% %s %p %s_i %s_sub
		% Success.
		3 2 roll pop
		% %s %s_i% %s_sub

		% Contstruct pre string %s_pre.
		3 1 roll dup 2 index exch 0 exch
		% %s_sub %s %s_i %s 0 %s_i
		getinterval
		% %s_sub %s %s_i %s_pre
		3 1 roll
		% %s_sub %s_pre %s %s_i

		% Contstruct post string %s_post.
		3 index length add dup
		2 index length exch sub
		getinterval
		% %s_sub %s_pre %s_post
		3 1 roll

		true
		% %s_post %s_sub %s_pre true
		exit
	    } ifelse
	} for

	% Check to see if we succeeded.  If not, set up the stack to
	% return failure.
	dup type /booleantype ne {
	    % Failure.
	    pop false
	} if
    }{
	% Substring is too long.
	pop false
    } ifelse
} def
' catenate
1 1 eq {
    `
% [`<path>' `<args>'...] system %exit_code
/system {
    % Make sure argument is an array.
    dup type /arraytype ne {
	/typecheck throw
    } if
    % Make sure array is non-empty.
    dup length 0 eq {
	/rangecheck throw
    } if
    % Make sure array elements are strings.
    dup {
	{
	    type /stringtype ne {
		stop
	    } if
	} foreach
    } stopped {
	/typecheck throw
    } if

    fork
    dup 0 eq {
	% Child.
	systemdict begin
	/throw {1 die} def
	end
	pop exec
    }{
	% Parent.
	exch pop waitpid
    } ifelse
} def

% Define require and mrequire configuration parameters in onyxdict.  By default,
% the search order is:
%
% 1) Absolute path: `'.
% 2) Relative path: `.'.
% 3) /ONYX_[MR]PATH: Colon-separated string in envdict.
% 4) `/usr/local/share/3.0.0/nx[m]': Standard installation location.
onyxdict begin
/rpath_pre [`' `.'] def
/rpath_post [`/usr/local/share/onyx-3.0.0/nx'] def

/mpath_pre [`' `.'] def
/mpath_post [`/usr/local/share/onyx-3.0.0/nxm'] def
end % onyxdict.

% %filename require -
/require {
    % Make sure the argument is a string.
    dup type /stringtype ne {
	/typecheck throw
    } if

    {
	[
	    onyxdict /rpath_pre get

	    envdict /ONYX_RPATH 2 ndup known {
		get

		% Push mark that denotes start of array.
		[ exch
		{
		    % [ ... %cpath
		    `:' search {
			% %post `:' %dir
			exch pop exch
			% [ ... %dir %post
		    }{
			% Last path component.
			% %dir
			exit
		    } ifelse
		} loop
		% Create array.
		]
	    }{
		2 npop
	    } ifelse

	    onyxdict /rpath_post get
	]{
	    % %filename %path
	    {
		% %filename %dir
		`/' catenate
		1 index catenate
		% %filename %full_path
		dup `f' test {
		    % Found.
		    % %filename %full_path
		    `r' open cvx eval
		    % %filename
		    pop
		    stop % Success.
		}{
		    % Not found.
		    % %filename %full_path
		    pop
		} ifelse
	    } foreach
	} foreach
    } stopped not {
	% Failure.
	/undefinedfilename throw
    } if
    1 pop % XXX Avoid tail call optimization.
} def

% %filename %symbol mrequire -
/mrequire {
    % Make sure the arguments are strings.
    1 index type /stringtype ne {
	/typecheck throw
    } if
    dup type /stringtype ne {
	/typecheck throw
    } if

    exch
    % %symbol %filename
    {
	[
	    onyxdict /mpath_pre get

	    envdict /ONYX_MPATH 2 ndup known {
		get

		% Push mark that denotes start of array.
		[ exch
		{
		    % [ ... %cpath
		    `:' search {
			% %post `:' %dir
			exch pop exch
			% [ ... %dir %post
		    }{
			% Last path component.
			% %dir
			exit
		    } ifelse
		} loop
		% Create array.
		]
	    }{
		2 npop
	    } ifelse

	    onyxdict /mpath_post get
	]{
	    % %symbol %filename %path
	    {
		% %symbol %filename %dir
		`/' catenate
		1 index catenate
		% %symbol %filename %full_path
		dup `f' test {
		    % Found.
		    % %symbol %filename %full_path
		    3 2 roll modload
		    % %filename
		    pop
		    stop % Success.
		}{
		    % Not found.
		    % %symbol %filename %full_path
		    pop
		} ifelse
	    } foreach
	} foreach
    } stopped not {
	% Failure.
	% %symbol %filename
	exch
	/undefinedfilename throw
    } if
} def
    ' catenate
} if
`
% /errorname throw -
/throw {
    % Do some sanity checking, to try to avoid going infinitely recursive
    % in the error handling machinery.
    {
	{/errordict where {pop true}{false} ifelse}
	{/errordict load /handleerror known}
	{/errordict load /stop known}
	{/currenterror where {pop true}{false} ifelse}
    }{
	eval not {
	    stderr `Onyx: Missing errordict or currenterror defs\n'
	    write

	    % Print stack dumps.
	    stderr `ostack: ' write
	    ostack 2 sprints stderr exch write

	    stderr `\ndstack: ' write
	    stderr dstack 2 sprints write

	    stderr `\nestack: ' write
	    stderr estack 2 sprints write

	    stderr `\nistack: ' write
	    stderr istack 2 sprints write

	    stderr `\nOnyx: dieing\n' write
	    1 die
	} if
    } foreach

    % Make sure the argument is a name.
    dup type /nametype ne {
	/typecheck /systemdict load /throw get eval
    } if

    /currenterror load begin

    % Set newerror to true to indicate there is an error.  It is up to the
    % application to clear this afterwards if it wants to make newerror
    % meaningful in the face of multiple errors.
    /newerror true def

    % Set errorname to the argument passed in.
    dup /errorname exch cvlit def

    % ostack.  Get rid of /errorname in the snapshot.  Ordering is important
    % to keep from polluting the snapshot.
    ostack dup spop pop /ostack exch def

    % dstack.  Do not include the top element, which is the copy of
    % currenterror that we pushed.
    /dstack dstack dup spop pop def

    % estack.  Remove this procedure from the snapshot.
    /estack estack dup spop pop def

    % istack.  Remove this procedure from the snapshot.
    /istack istack dup spop pop def

    % Push the offending object onto ostack.
    /estack load dup sdup spop
    exch
    % %object %errorname

    end % currenterror.

    % If there is an error handler for the error name, call it.  Otherwise,
    % call the errordict handleerror, then call the errordict stop.
    /errordict load
    % %object %errorname %errordict
    dup 2 index known {
	% Call error handler.
	exch get eval
    }{
	% No error handler.
	exch pop
	dup /handleerror get eval
	/stop get eval
    } ifelse
} def

% - version %string
/version `<Version = onyx>' def

end % systemdict.
' catenate

% Final closing brace.
`}' catenate cvx eval

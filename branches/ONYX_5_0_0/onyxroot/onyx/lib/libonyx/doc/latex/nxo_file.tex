%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% nxo_file portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{nxo\_file}
\label{nxo_file}
\index{nxo_file@\classname{nxo\_file}{}}

The \classname{nxo\_file} class is a subclass of the \classname{nxo} class.

\subsubsection{API}
\begin{capi}
\label{cw_nxo_file_read_t}
\index{cw_nxo_file_read_t@\cfunc{cw\_nxo\_file\_read\_t}{}}
\citem{\cfunc[int32\_t]{cw\_nxo\_file\_read\_t}{void *a\_arg, cw\_nxo\_t
*a\_file, uint32\_t a\_len, char *r\_str}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque data pointer.
		\item[a\_file: ]
			Pointer to a file \classname{nxo}.
		\item[a\_len: ]
			Length of \cvar{r\_str}.
		\item[r\_str: ]
			Pointer to space to put read data.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ]
				Read error.
			\item[{\gt}= 0: ]
				Number of bytes stored in \cvar{r\_str}.
			\end{description}
		\item[r\_str: ]
			If \cvar{retval} is non-negative, \cvar{retval} bytes of
			read data, otherwise undefined.
		\end{description}
	\item[Exception(s): ] Application specific.
	\item[Description: ]
		Read up to \cvar{a\_len} bytes of data from \cvar{a\_file} and
		store the result in \cvar{r\_str}.
	\end{capilist}
\label{cw_nxo_file_write_t}
\index{cw_nxo_file_write_t@\cfunc{cw\_nxo\_file\_write\_t}{}}
\citem{\cfunc[bool]{cw\_nxo\_file\_write\_t}{void *a\_arg, cw\_nxo\_t
*a\_file, const char *a\_str, uint32\_t a\_len}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque data pointer.
		\item[a\_file: ]
			Pointer to a file \classname{nxo}.
		\item[a\_str: ]
			Pointer to data to write.
		\item[a\_len: ]
			Length of \cvar{a\_str}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[false: ]
				Success.
			\item[true: ]
				Write error.
			\end{description}
		\end{description}
	\item[Exception(s): ] Application specific.
	\item[Description: ]
		Write \cvar{a\_len} bytes of data from \cvar{a\_str} to
		\cvar{a\_file}.
	\end{capilist}
\label{cw_nxo_file_ref_iter_t}
\index{cw_nxo_file_ref_iter_t@\cfunc{cw\_nxo\_file\_ref\_iter\_t}{}}
\citem{\cfunc[cw\_nxoe\_t *]{cw\_nxo\_file\_ref\_iter\_t}{void *a\_arg,
bool a\_reset}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque data pointer.
		\item[a\_reset: ]
			\begin{description}\item[]
			\item[false: ]
				At least one iteration has already occurred.
			\item[true: ]
				First iteration.
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[non-NULL: ]
				Pointer to an \classname{nxoe}.
			\item[NULL: ]
				No more references.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Reference iterator function typedef.
	\end{capilist}
\label{cw_nxo_file_delete_t}
\index{cw_nxo_file_delete_t@\cfunc{cw\_nxo\_file\_delete\_t}{}}
\citem{\cfunc[void]{cw\_nxo\_file\_delete\_t}{void *a\_arg}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque data pointer.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor function typedef.
	\end{capilist}
\label{nxo_file_new}
\index{nxo_file_new@\cfunc{nxo\_file\_new}{}}
\citem{\cfunc[void]{nxo\_file\_new}{cw\_nxo\_t *a\_nxo, bool a\_locking}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_locking: ]
			Implicit locking mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{capilist}
\label{nxo_file_fd_wrap}
\index{nxo_file_fd_wrap@\cfunc{nxo\_file\_fd\_wrap}{}}
\citem{\cfunc[void]{nxo\_file\_fd\_wrap}{cw\_nxo\_t *a\_nxo, uint32\_t
a\_fd, bool a\_close}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_fd: ]
			File descriptor number.
		\item[a\_close: ] If true, close \cvar{a\_fd} when \cvar{a\_nxo}
			is finalized by the garbage collector, otherwise, do
			not automatically close \cvar{a\_fd}.  This should
			typically be set to true.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Wrap file descriptor \cvar{a\_fd} so that operations on
		\cvar{a\_nxo} will be backed by the file descriptor.
	\end{capilist}
\label{nxo_file_synthetic}
\index{nxo_file_synthetic@\cfunc{nxo\_file\_synthetic}{}}
\citem{\cfunc[void]{nxo\_file\_synthetic}{cw\_nxo\_t *a\_nxo,
cw\_nxo\_file\_read\_t *a\_read, cw\_nxo\_file\_write\_t *a\_write,
cw\_nxo\_file\_ref\_iter\_t *a\_ref\_iter, cw\_nxo\_file\_delet\_t *a\_delete,
void *a\_arg}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_read: ]
			Pointer to a read function.
		\item[a\_write: ]
			Pointer to a write function.
		\item[a\_ref\_iter: ]
			Pointer to a reference iterator function.
		\item[a\_delete: ]
			Pointer to a destructor function.
		\item[a\_arg: ]
			Opaque pointer to be passed to the read and write
			functions.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Set up \cvar{a\_nxo} to call the specified read and write
		functions to satisfy file operations.
	\end{capilist}
\label{nxo_file_open}
\index{nxo_file_open@\cfunc{nxo\_file\_open}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_open}{cw\_nxo\_t *a\_nxo, const
char *a\_filename, uint32\_t a\_nlen, const char *a\_flags,
uint32\_t a\_flen}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_filename: ]
			Pointer to a string (not required to be '{\bs}0'
			terminated) that represents a filename.
		\item[a\_nlen: ]
			Length in bytes of \cvar{a\_filename}.
		\item[a\_flags: ]
			Pointer to a string (not required to be '{\bs}0'
			terminated) that represents a file mode:
			\begin{description}\item[]
			\item[``r'': ]
				Read only.
			\item[``r+'': ]
				Read/write, starting at offset 0.
			\item[``w'': ]
				Write only.  Create file if necessary.  Truncate
				file if non-zero length.
			\item[``w+'': ]
				Read/write, starting at offset 0.  Create
				file if necessary.
			\item[``a'': ]
				Write only, starting at end of file.
			\item[``a+'': ]
				Read/write, starting at end of file.
			\end{description}
		\item[a\_flen: ]
			Length in bytes of \cvar{a\_flags}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\item[NXN\_\htmlref{invalidfileaccess}
				{invalidfileaccess}.]
			\item[NXN\_\htmlref{limitcheck}{limitcheck}.]
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Open a file.
	\end{capilist}
\label{nxo_file_close}
\index{nxo_file_close@\cfunc{nxo\_file\_close}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_close}{cw\_nxo\_t *a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Close a file.
	\end{capilist}
\label{nxo_file_origin_get}
\index{nxo_file_origin_get@\cfunc{nxo\_file\_origin\_get}{}}
\citem{\cfunc[void]{nxo\_file\_origin\_get}{cw\_nxo\_t *a\_nxo, const
char **r\_origin, uint32\_t *r\_olen}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[r\_origin: ] Pointer to a string pointer.
		\item[r\_olen: ] Pointer to an unsigned integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[*r\_origin: ]
			A pointer to a string that represents the origin of
			\cvar{a\_nxo}.
		\item[*r\_olen: ]
			The length of the string pointed to by
			\cvar{*r\_origin}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Get the origin of \cvar{a\_nxo}.
	\end{capilist}
\label{nxo_file_origin_set}
\index{nxo_file_origin_set@\cfunc{nxo\_file\_origin\_set}{}}
\citem{\cfunc[bool]{nxo\_file\_origin\_set}{cw\_nxo\_t *a\_nxo,
const char *a\_origin, uint32\_t a\_olen}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_origin: ]
			Pointer to a string that represents the origin of
			\cvar{a\_nxo}.
		\item[a\_olen: ]
			The length of the string pointed to by\cvar{a\_origin}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the origin of \cvar{a\_nxo}.  A copy of \cvar{a\_origin} is
		made and managed internally.
	\end{capilist}
\label{nxo_file_fd_get}
\index{nxo_file_fd_get@\cfunc{nxo\_file\_fd\_get}{}}
\citem{\cfunc[int32\_t]{nxo\_file\_fd\_get}{const cw\_nxo\_t *a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ]
				Invalid or synthetic file.
			\item[{\gt}= 0: ]
				File descriptor number.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the file descriptor associated with \cvar{a\_nxo}.
	\end{capilist}
\label{nxo_file_nonblocking_get}
\index{nxo_file_nonblocking_get@\cfunc{nxo\_file\_nonblocking\_get}{}}
\citem{\cfunc[bool]{nxo\_file\_nonblocking\_get}{const cw\_nxo\_t
*a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[false: ]
				Blocking file.
			\item[true: ]
				Non-blocking file.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the non-blocking mode for \cvar{a\_nxo}.
	\end{capilist}
\label{nxo_file_nonblocking_set}
\index{nxo_file_nonblocking_set@\cfunc{nxo\_file\_nonblocking\_set}{}}
\citem{\cfunc[bool]{nxo\_file\_nonblocking\_set}{cw\_nxo\_t *a\_nxo,
bool a\_nonblocking}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_nonblocking: ]
			Non-blocking mode to set \classname{nxo} to.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[false: ]
				Success.
			\item[true: ]
				I/O error or non-POSIX file.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Set the non-blocking mode for \cvar{a\_nxo} to
		\cvar{a\_nonblocking}.
	\end{capilist}
\label{nxo_file_read}
\index{nxo_file_read@\cfunc{nxo\_file\_read}{}}
\citem{\cfunc[int32\_t]{nxo\_file\_read}{cw\_nxo\_t *a\_nxo, uint32\_t
a\_len, char *r\_str}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_len: ]
			Length in bytes of \cvar{r\_str}.
		\item[r\_str: ]
			Pointer to a string to store read data into.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ]
				NXN\_\htmlref{ioerror}{ioerror}.
			\item[{\gt}= 0: ]
				Number of bytes of data read into \cvar{r\_str}.
			\end{description}\item[]
		\item[r\_str: ]
			If \cvar{retval} is non-negative, \cvar{retval} bytes of
			read data.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Read data.
	\end{capilist}
\label{nxo_file_readline}
\index{nxo_file_readline@\cfunc{nxo\_file\_readline}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_readline}{cw\_nxo\_t *a\_nxo, cw\_nx\_t
*a\_nx, bool a\_locking, cw\_nxo\_t *r\_string, bool *r\_eof}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_nx: ]
			Pointer to an \classname{nx}.
		\item[a\_locking: ]
			Implicit locking mode.
		\item[r\_string: ]
			Pointer to an \classname{nxo}.
		\item[r\_eof: ]
			Pointer to a \ctype{bool}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\item[r\_string: ]
			If \cvar{retval} is NXN\_ZERO, a string object,
			otherwise unmodified.
		\item[*r\_eof: ]
			\begin{description}\item[]
			\item[false: ]
				End of file not reached.
			\item[true: ]
				End of file reached.
			\end{description}
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Read a line, terminated by ``{\bs}r'', ``{\bs}r{\bs}n'', or EOF.
	\end{capilist}
\label{nxo_file_write}
\index{nxo_file_write@\cfunc{nxo\_file\_write}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_write}{cw\_nxo\_t *a\_nxo, const
char *a\_str, uint32\_t a\_len, uint32\_t *r\_count}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_str: ]
			Pointer to data to write.
		\item[a\_len: ]
			Length of \cvar{a\_str}.
		\item[r\_count: ]
			Pointer to a location to store the number of bytes
			written, or NULL.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\item[*r\_count: ]
			If \cvar{r\_count} is non-NULL, and retval is NXN\_ZERO,
			number of bytes written, otherwise undefined.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Write the \cvar{a\_len} bytes of data pointed to \cvar{a\_str}.
		If the file is in non-blocking mode, it is possible for
		\cvar{*r\_count} to be as small as 0 for a successful write.
	\end{capilist}
\label{nxo_file_truncate}
\index{nxo_file_truncate@\cfunc{nxo\_file\_truncate}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_truncate}{cw\_nxo\_t *a\_nxo, off\_t
a\_length}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_length: ]
			Length to set file to.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Truncate or extend the file associated with \cvar{a\_nxo} so
		that it is \cvar{a\_length} bytes long.
	\end{capilist}
\label{nxo_file_position_get}
\index{nxo_file_position_get@\cfunc{nxo\_file\_position\_get}{}}
\citem{\cfunc[cw\_nxoi\_t]{nxo\_file\_position\_get}{cw\_nxo\_t *a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ]
				NXN\_\htmlref{ioerror}{ioerror}.
			\item[{\gt}= 0: ]
				Current file position.
			\end{description}\item[]
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Get the current file position.
	\end{capilist}
\label{nxo_file_position_set}
\index{nxo_file_position_set@\cfunc{nxo\_file\_position\_set}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_position\_set}{cw\_nxo\_t *a\_nxo,
cw\_nxoi\_t a\_position}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_position: ]
			File position.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Move the current file position to \cvar{a\_position}.
	\end{capilist}
\label{nxo_file_buffer_size_get}
\index{nxo_file_buffer_size_get@\cfunc{nxo\_file\_buffer\_size\_get}{}}
\citem{\cfunc[uint32\_t]{nxo\_file\_buffer\_size\_get}{const cw\_nxo\_t
*a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Size in bytes of the internal data buffer.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the size of the internal data buffer.
	\end{capilist}
\label{nxo_file_buffer_size_set}
\index{nxo_file_buffer_size_set@\cfunc{nxo\_file\_buffer\_size\_set}{}}
\citem{\cfunc[void]{nxo\_file\_buffer\_size\_set}{cw\_nxo\_t *a\_nxo,
uint32\_t a\_size}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\item[a\_size: ]
			Size in bytes of internal buffer to use.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{CW\_ONYXX\_OOM}{CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Use an internal buffer of \cvar{a\_size} bytes.
	\end{capilist}
\label{nxo_file_buffer_count}
\index{nxo_file_buffer_count@\cfunc{nxo\_file\_buffer\_count}{}}
\citem{\cfunc[cw\_nxoi\_t]{nxo\_file\_buffer\_count}{const cw\_nxo\_t *a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Current number of buffered bytes available for reading.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the current number of buffered bytes available for
		reading.
	\end{capilist}
\label{nxo_file_buffer_flush}
\index{nxo_file_buffer_flush@\cfunc{nxo\_file\_buffer\_flush}{}}
\citem{\cfunc[cw\_nxn\_t]{nxo\_file\_buffer\_flush}{cw\_nxo\_t *a\_nxo}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxo: ]
			Pointer to a file \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[NXN\_ZERO.]
			\item[NXN\_\htmlref{ioerror}{ioerror}.]
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Flush any buffered write data to disk, and discard any buffered
		read data.
	\end{capilist}
\end{capi}

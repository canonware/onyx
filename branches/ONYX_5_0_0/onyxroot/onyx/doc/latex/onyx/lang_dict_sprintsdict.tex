%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% sprintsdict reference portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{sprintsdict}
\label{sec:sprintsdict}
\index{sprintsdict@\onyxop{}{sprintsdict}{}}

The sprintsdict dictionary is primarily used to support
\htmlref{\onyxop{}{sprints}{}}{systemdict:sprints}, but its contents may be of
use to an application that wishes to extend or modify syntactical printing.

There is an entry in sprintsdict for each Onyx type.  If there is a
syntactically valid representation for an object and the recursion depth is
greater than 0, the corresponding operator creates a string that syntactically
represents the object.  Otherwise, a string with a non-syntictical
representation of the object is created, except for booleans, integers, names,
nulls, reals, and strings, for which the results are always syntactical.  If the
recursion depth is greater than 0, the operators will recursively convert any
contained objects.

The implementation of \htmlref{\onyxop{}{sprints}{}}{systemdict:sprints} is
useful in illustrating a useful method of doing type-dependent operations:

\begin{verbatim}
$sprints {
        1 idup type $sprintsdict load exch get eval
} def
\end{verbatim}

\begin{longtable}{\optableformat{4.10}}
\caption{sprintsdict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{array depth}
	{{\bf \htmlref{arraytype}{sprintsdict:arraytype}}}
	{string}
	{Create syntactical string from array.}
\hline
\optableent
	{boolean depth}
	{{\bf \htmlref{booleantype}{sprintsdict:booleantype}}}
	{string}
	{Create syntactical string from boolean.}
\hline
\optableent
	{class depth}
	{{\bf \htmlref{classtype}{sprintsdict:classtype}}}
	{string}
	{Create syntactical string from class.}
\hline
\optableent
	{condition depth}
	{{\bf \htmlref{conditiontype}{sprintsdict:conditiontype}}}
	{string}
	{Create syntactical string from condition.}
\hline
\optableent
	{dict depth}
	{{\bf \htmlref{dicttype}{sprintsdict:dicttype}}}
	{string}
	{Create syntactical string from dict.}
\hline
\optableent
	{file depth}
	{{\bf \htmlref{filetype}{sprintsdict:filetype}}}
	{string}
	{Create syntactical string from file.}
\hline
\optableent
	{fino depth}
	{{\bf \htmlref{finotype}{sprintsdict:finotype}}}
	{string}
	{Create syntactical string from fino.}
\hline
\optableent
	{handle depth}
	{{\bf \htmlref{handletype}{sprintsdict:handletype}}}
	{string}
	{Create syntactical string from handle.}
\hline
\optableent
	{instance depth}
	{{\bf \htmlref{instancetype}{sprintsdict:instancetype}}}
	{string}
	{Create syntactical string from instance.}
\hline
\optableent
	{integer depth}
	{{\bf \htmlref{integertype}{sprintsdict:integertype}}}
	{string}
	{Create syntactical string from integer.}
\hline
\optableent
	{mark depth}
	{{\bf \htmlref{marktype}{sprintsdict:marktype}}}
	{string}
	{Create syntactical string from mark.}
\hline
\optableent
	{mutex depth}
	{{\bf \htmlref{mutextype}{sprintsdict:mutextype}}}
	{string}
	{Create syntactical string from mutex.}
\hline
\optableent
	{name depth}
	{{\bf \htmlref{nametype}{sprintsdict:nametype}}}
	{string}
	{Create syntactical string from name.}
\hline
\optableent
	{null depth}
	{{\bf \htmlref{nulltype}{sprintsdict:nulltype}}}
	{string}
	{Create syntactical string from null.}
\hline
\optableent
	{operator depth}
	{{\bf \htmlref{operatortype}{sprintsdict:operatortype}}}
	{string}
	{Create syntactical string from operator.}
\hline
\optableent
	{pmark depth}
	{{\bf \htmlref{pmarktype}{sprintsdict:pmarktype}}}
	{string}
	{Create syntactical string from pmark.}
\hline
\optableent
	{real depth}
	{{\bf \htmlref{realtype}{sprintsdict:realtype}}}
	{string}
	{Create syntactical string from real.}
\hline
\optableent
	{regex depth}
	{{\bf \htmlref{regextype}{sprintsdict:regextype}}}
	{string}
	{Create syntactical string from regex.}
\hline
\optableent
	{regsub depth}
	{{\bf \htmlref{regsubtype}{sprintsdict:regsubtype}}}
	{string}
	{Create syntactical string from regsub.}
\hline
\optableent
	{stack depth}
	{{\bf \htmlref{stacktype}{sprintsdict:stacktype}}}
	{string}
	{Create syntactical string from stack.}
\hline
\optableent
	{string depth}
	{{\bf \htmlref{stringtype}{sprintsdict:stringtype}}}
	{string}
	{Create syntactical string from string.}
\hline
\optableent
	{thread depth}
	{{\bf \htmlref{threadtype}{sprintsdict:threadtype}}}
	{string}
	{Create syntactical string from thread.}
\end{longtable}

\begin{description}
\label{sprintsdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array depth}{arraytype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{array}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{array}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup 0 arraytype print `\n' print flush
-array-
onyx:1> dup 1 arraytype print `\n' print flush
[1 -array- 4]
onyx:1> dup 2 arraytype print `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean depth}{booleantype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{boolean}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> true
onyx:1> dup 0 booleantype print `\n' print flush
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:classtype}
\index{classtype@\onyxop{}{classtype}{}}
\item[{\onyxop{class depth}{classtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[class: ]
			A class object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{class}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{class}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> vclass
onyx:1> dup 0 classtype print `\n' print flush
-class-
onyx:1> dup 1 classtype print `\n' print flush
-class-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition depth}{conditiontype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{condition}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{condition}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> condition
onyx:1> dup 0 conditiontype print `\n' print flush
-condition-
onyx:1> dup 1 conditiontype print `\n' print flush
-condition-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict depth}{dicttype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{dict}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> <$a `a' $subdict <$b `b'>>
onyx:1> dup 0 dicttype print `\n' print flush
-dict-
onyx:1> dup 1 dicttype print `\n' print flush
<$subdict -dict- $a `a'>
onyx:1> dup 2 dicttype print `\n' print flush
<$subdict <$b `b'> $a `a'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file depth}{filetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{file}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> stdout
onyx:1> dup 0 filetype print `\n' print flush
-file-
onyx:1> dup 1 filetype print `\n' print flush
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino depth}{finotype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{fino}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{fino}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (
onyx:1> dup 0 finotype print `\n' print flush
-fino-
onyx:1> dup 1 finotype print `\n' print flush
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:handletype}
\index{handletype@\onyxop{}{handletype}{}}
\item[{\onyxop{handle depth}{handletype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[handle: ]
			A handle object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{handle}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{handle}.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a handle object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhandle exists
		that creates a handle with a tag that is the name ``tagged'',
		and that an operator named untaggedhandle exists that creates an
		untagged handle.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> taggedhandle
onyx:1> dup 0 handletype print `\n' print flush
=tagged=
onyx:1> 1 handletype print `\n' print flush
=tagged=
onyx:0> untaggedhandle
onyx:1> dup 0 handletype print `\n' print flush
-handle-
onyx:1> 1 handletype print `\n' print flush
-handle-
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:instancetype}
\index{instancetype@\onyxop{}{instancetype}{}}
\item[{\onyxop{instance depth}{instancetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[instance: ]
			An instance object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{instance}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{instance}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> vinstance
onyx:1> dup 0 instancetype print `\n' print flush
-instance-
onyx:1> dup 1 instancetype print `\n' print flush
-instance-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer depth}{integertype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{integer}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{integer}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42
onyx:1> dup 0 integertype print `\n' print flush
42
onyx:1> dup 1 integertype print `\n' print flush
42
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark depth}{marktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mark}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mark
onyx:1> dup 0 marktype print `\n' print flush
-mark-
onyx:1> dup 1 marktype print `\n' print flush
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex depth}{mutextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mutex}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mutex
onyx:1> dup 0 mutextype print `\n' print flush
-mutex-
onyx:1> dup 1 mutextype print `\n' print flush
-mutex-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name depth}{nametype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{name}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{name}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> $foo
onyx:1> dup 0 nametype print `\n' print flush
$foo
onyx:1> dup 1 nametype print `\n' print flush
$foo
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null depth}{nulltype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{null}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{null}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> null
onyx:1> dup 0 nulltype print `\n' print flush
-null-
onyx:1> dup 1 nulltype print `\n' print flush
-null-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator depth}{operatortype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{operator}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{operator}.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> ~realtime
onyx:1> dup 0 operatortype print `\n' print flush
--realtime--
onyx:1> 1 operatortype print `\n' print flush
--realtime--
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark depth}{pmarktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{pmark}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{pmark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> { ~x
Error $undefined
ostack: (-pmark- $x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
cstack: ()
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> dup 0 pmarktype print `\n' print flush
-pmark-
onyx:1> dup 1 pmarktype print `\n' print flush
-pmark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:regextype}
\index{regextype@\onyxop{}{regextype}{}}
\item[{\onyxop{regex depth}{regextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regex: ]
			A regex object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{regex}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{regex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> `' regex
onyx:1> dup 0 regextype print `\n' print flush
-regex-
onyx:1> dup 1 regextype print `\n' print flush
-regex-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:regsubtype}
\index{regsubtype@\onyxop{}{regsubtype}{}}
\item[{\onyxop{regsub depth}{regsubtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regsub: ]
			A regsub object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{regsub}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{regsub}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> `' `' regsub
onyx:1> dup 0 regsubtype print `\n' print flush
-regsub-
onyx:1> dup 1 regsubtype print `\n' print flush
-regsub-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:realtype}
\index{realtype@\onyxop{}{realtype}{}}
\item[{\onyxop{real depth}{realtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{real}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{real}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42.0
onyx:1> dup 0 realtype print `\n' print flush
4.200000e+01
onyx:1> dup 1 realtype print `\n' print flush
4.200000e+01
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack depth}{stacktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{stack}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup 0 stacktype print `\n' print flush
-stack-
onyx:1> dup 1 stacktype print `\n' print flush
(1 -stack- 4)
onyx:1> dup 2 stacktype print `\n' print flush
(1 (2 3) 4)
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string depth}{stringtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{string}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> `abcd'
onyx:1> dup 0 stringtype print `\n' print flush
`abcd'
onyx:1> dup 1 stringtype print `\n' print flush
`abcd'
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread depth}{threadtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{thread}.
		\end{description}
	\item[Error(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> thread
onyx:1> dup 0 threadtype print `\n' print flush
-thread-
onyx:1> dup 1 threadtype print `\n' print flush
-thread-
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nxo_thread_nxcode_gen.nx to produce a more compact
% embedded version in nxo_thread_nxcode.c.  Due to bootstrapping issues, this
% cannot safely be done automatically as part of the build process.  In order
% to make changes to this file take effect, either type:
%
%   cook bootstrap
%
% or
%
%   cat nxo_thread_nxcode.nx | onyx nxo_thread_nxcode_gen.nx
%       > nxo_thread_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

% userdict doesn't exist yet.  This code jumps through some hoops to push it
% onto dstack, then define it in threaddict, to avoid a dstackunderflow error.
dict begin
/userdict currentdict
dstack 3 sindex spop begin pop
/threaddict currentdict def
def

% Define and initialize currenterror
/currenterror <
	/newerror	false
	/errorname	`'
	/estack		()
	/istack		()
	/ostack		()
	/dstack		()
	/line		1
	/column		0
> def

% Define and initialize currenterror.
/errordict <
	[
		/dstackunderflow
		/estackoverflow
		/invalidaccess
		/invalidcontext
		/invalidexit
		/invalidfileaccess
		/ioerror
		/limitcheck
		/rangecheck
		/stackunderflow
		/syntaxerror
		/typecheck
		/undefined
		/undefinedfilename
		/undefinedresult
		/unmatchedmark
		/unmatchedfino
		/unregistered
	]{
		{/errordict load /handleerror get eval}
	} foreach

	/stop /stop load

	/handleerror {
		/currenterror load begin

		% If this is a syntaxerror, print the line and column numbers.
		/errorname load /syntaxerror eq {
			`At line ' print
			/line load cvs print
			`, column ' print
			/column load cvs print
			`: ' print
		} if

		% Print the errorname.
		`Error ' print /errorname load 1 sprint

		% Print ostack and dstack using sprint.
		`ostack: ' print
		/ostack load 1 sprint
		`dstack: ' print
		/dstack load 1 sprint

		% Print a stack trace that depicts the currently
		% executing element of arrays.
		/estack load scount exch pop 1 sub dup 0 gt {
			`estack/istack trace (0..' print
			dup cvs print
			`):\n' print
		} if

		% For each element in estack:
		0 1 3 2 roll {
			% <edepth>
			% If this element is an array, print it
			% specially.
			dup cvs print
			dup /estack load exch sindex spop exch pop 
			% <edepth> <array>

			dup type /arraytype eq {
				% Array.
				`: {\n' print
				% <edepth> <array>
				dup length 1 sub 0 1 3 -1 roll {
					% <edepth> <array> <aindex>
					2 index /istack load
					exch sindex spop exch pop
					% <edepth> <array> <aindex>
					% <iindex>
					1 index
					% <edepth> <array> <aindex>
					% <iindex> <aindex>
					eq {
						` ' print
						dup cvs print
						`:-->\t' print
					}{
						`\t' print
					} ifelse
					% <edepth> <array> <aindex>
					1 index exch get 1 sprint
					% <edepth> <array>
				} for
				`}\n' print
				% <edepth> <array>
				pop
				% <edepth>
			}{
				% Non-array.
				`:\t' print
				% <edepth> <array>
				1 sprint
				% <edepth>
			} ifelse
			% <edepth>
			pop
		} for

		end % currenterror.

		% Make sure the output gets written before stop.
		flush
	} bind
> def

end % threaddict.

} % End deferral.

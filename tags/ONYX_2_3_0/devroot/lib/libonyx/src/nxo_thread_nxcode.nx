%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nxo_thread_nxcode_gen.nx to produce a more compact
% embedded version in nxo_thread_nxcode.c.  Due to bootstrapping issues, this
% cannot safely be done automatically as part of the build process.  In order
% to make changes to this file take effect, either type:
%
%   cook bootstrap
%
% or
%
%   cat nxo_thread_nxcode.nx | onyx nxo_thread_nxcode_gen.nx
%       > nxo_thread_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

% userdict doesn't exist yet.  This code jumps through some hoops to push it
% onto dstack, then define it in threaddict, to avoid a dstackunderflow error.
dict begin
/userdict currentdict
dstack dup 3 sindex dup spop begin pop
/threaddict currentdict def
def

% Define and initialize currenterror
/currenterror <
	/newerror	false
	/errorname	`'
	/estack		()
	/istack		()
	/ostack		()
	/dstack		()
	/line		1
	/column		0
> def

% Define and initialize currenterror.
/errordict <
	/stop /stop load

	% - handleerror -
	/handleerror {
		/currenterror load begin

		% If this is a syntaxerror, print the line and column numbers.
		/errorname load /syntaxerror eq {
			stderr dup `At line ' write
			dup /line load cvs write
			dup `, column ' write
			dup /column load cvs write
			`: ' write
		} if

		% Print the errorname.
		stderr dup `Error ' write
		dup /errorname load 1 sprints write

		% Print ostack and dstack using sprint.
		dup `\nostack: ' write
		dup /ostack load 1 sprints write
		dup `\ndstack: ' write
		dup /dstack load 1 sprints write
		`\n' write

		% Print a stack trace that depicts the currently
		% executing element of arrays.
		/estack load scount 1 sub dup 0 gt {
			stderr dup `estack/istack trace (0..' write
			1 index cvs stderr exch write
			`):\n' write
		} if

		% For each element in estack:
		0 1 3 2 roll {
			% <edepth>
			% If this element is an array, print it
			% specially.
			dup cvs stderr exch write
			dup /estack load dup 3 2 roll sindex spop
			% <edepth> <array>

			dup type /arraytype eq {
				% Array.
				`: {\n' stderr exch write
				% <edepth> <array>
				dup length 1 sub 0 1 3 -1 roll {
					% <edepth> <array> <aindex>
					2 index /istack load
					dup 3 2 roll sindex spop
					% <edepth> <array> <aindex>
					% <iindex>
					1 index
					% <edepth> <array> <aindex>
					% <iindex> <aindex>
					eq {
						dup </w 3> outputs
						stderr exch write
						`:--> '
					}{
						`\t'
					} ifelse
					stderr exch write
					% <edepth> <array> <aindex>
					1 index exch get 1 sprints
					stderr exch write
					stderr `\n' write
					% <edepth> <array>
				} for
				stderr `}\n' write
				% <edepth> <array>
				pop
				% <edepth>
			}{
				% Non-array.
				stderr `:\t' write
				% <edepth> <array>
				1 sprints stderr exch write
				stderr `\n' write
				% <edepth>
			} ifelse
			% <edepth>
			pop
		} for

		end % currenterror.

		% Make sure the output gets written before stop.
		flush
	} bind
> def

end % threaddict.

} % End deferral.

%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% libstash portion of Onyx Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{The libstash library}
The \libname{libstash} library defines a number of algorithms and data
structures that are useful for many purposes.

\libname{libstash} is designed to run on *nix platforms, and is known to work on
FreeBSD, Linux, and Solaris.  The pthreads library is required.

Regardless of what classes are used, at least the following minimal shell of C
code should be used.

\begin{verbatim}
#include <libstash/libstash.h>

int
main()
{
        libstash_init();

        /* Do stuff. */

        libstash_shutdown();
        return 0;
}
\end{verbatim}

All \libname{libstash} class API definitions are made available via the
\filename{libstash/libstash.h} header.  \cfunc{libstash\_init}{} must be called
in order for things to work properly.

\section{Compilation}
Use the following compiler command line to compile applications with
\libname{libstash}.
\begin{verbatim}
cc <file> -lstash -lpthread
\end{verbatim}

\section{Types}
\libname{libstash} is careful to use the following data types rather than the
built-in types (other than when using system library functions and string
pointers (char *)) to allow easy porting and explicit knowledge of variable
sizes:
\begin{description}
\item[cw\_bool\_t: ] Boolean, either FALSE or TRUE.
\item[cw\_sint8\_t: ] Signed 8 bit variable.
\item[cw\_uint8\_t: ] Unsigned 8 bit variable.
\item[cw\_sint16\_t: ] Signed 16 bit variable.
\item[cw\_uint16\_t: ] Unsigned 16 bit variable.
\item[cw\_sint32\_t: ] Signed 32 bit variable.
\item[cw\_uint32\_t: ] Unsigned 32 bit variable.
\item[cw\_sint64\_t: ] Signed 64 bit variable.
\item[cw\_uint64\_t: ] Unsigned 64 bit variable.
\end{description}

\section{Global variables}
\libname{libstash} defines the following global variables, which can be used by
the application:
\begin{description}
\item[cw\_g\_mem: ] \classname{mem} instance, default memory allocator.
\item[out\_std: ] \classname{out} instance, prints to file descriptor 1.
\item[out\_err: ] \classname{out} instance, prints to file descriptor 2.
\end{description}

\section{Object instantiation}
Many classes provide a means for external memory allocation, and in some cases
for automatic cleanup during destruction.  This feature enables improved
performance and cache locality, but if misunderstood, can result in mysterious
memory corruption and leaks.

\section{Exceptions}
\libname{libstash} reserves \htmlref{xep}{xep} exception numbers 0 to 127 and
defines the following exceptions:
\begin{description}
\label{_CW_STASHX_OOM}
\item[\cppdef{\_CW\_STASHX\_OOM}: ]
	Memory allocation error.
\label{_CW_STASHX_OUT_PARSE}
\item[\cppdef{\_CW\_STASHX\_OUT\_PARSE}: ]
	Error parsing a format string passed to the \classname{out} class.
\end{description}

\section{API}
\begin{capi}
\label{libstash_init}
\index{libstash_init@\cfunc{libstash\_init}{}}
\citem{\cfunc[void]{libstash\_init}{void}}
	\begin{capilist}
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Initialize various global variables.  In particular, initialize
		\cvar{cw\_g\_mem}, \cvar{out\_std}, and \cvar{out\_err}.
	\end{capilist}
\label{libstash_shutdown}
\index{libstash_shutdown@\cfunc{libstash\_shutdown}{}}
\citem{\cfunc[void]{libstash\_shutdown}{void}}
	\begin{capilist}
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Clean up the global variables that are initialized by
		\cfunc{libstash\_init}{}.
	\end{capilist}
\label{cw_opaque_alloc_t}
\index{cw_opaque_alloc_t@\cfunc{cw\_opaque\_alloc\_t}{}}
\citem{\cfunc[void *]{cw\_opaque\_alloc\_t}{void *a\_arg, size\_t a\_size,
const char *a\_filename, cw\_uint32\_t a\_line\_num}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque pointer.
		\item[a\_size: ]
			Size of memory range to allocate.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a memory range.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Allocate \cvar{a\_size} of space and return a pointer to it.
	\end{capilist}
\label{cw_opaque_dealloc_t}
\index{cw_opaque_dealloc_t@\cfunc{cw\_opaque\_dealloc\_t}{}}
\citem{\cfunc[void]{cw\_opaque\_dealloc\_t}{void *a\_mem, void *a\_ptr, const
char *a\_filename, cw\_uint32\_t a\_line\_num}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_arg: ]
			Opaque pointer.
		\item[a\_ptr: ]
			Pointer to to memory range to be freed.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Deallocate the memory pointed to by \cvar{a\_ptr}.
	\end{capilist}
\label{_cw_assert}
\index{_cw_assert@\cppmacro{\_cw\_assert}{}}
\citem{\cppmacro[void]{\_cw\_assert}{expression}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[expression: ]
			C expression that evaluates to zero or non-zero.
		\end{description}
	\item[Output(s): ]
			Possible error printed to file descriptor 2.
	\item[Exception(s): ] None.
	\item[Description: ]
		If the expression evaluates to zero, print an error message to
		file descriptor 2 and \cfunc{abort}{}.

		Note: This macro is only active if the \cppdef{\_CW\_ASSERT} cpp
		macro is defined.
	\end{capilist}
\label{_cw_not_reached}
\index{_cw_not_reached@\cppmacro{\_cw\_not\_reached}{}}
\citem{\cppmacro[void]{\_cw\_not\_reached}{void}}
	\begin{capilist}
	\item[Input(s): ] None.
	\item[Output(s): ]
		Error printed to file descriptor 2.
	\item[Exception(s): ] None.
	\item[Description: ]
		Abort with an error message.

		Note: This macro is only active if the \cppdef{\_CW\_ASSERT} cpp
		macro is defined.
	\end{capilist}
\label{_cw_check_ptr}
\index{_cw_check\_ptr@\cppmacro{\_cw\_check\_ptr}{}}
\citem{\cppmacro[void]{\_cw\_check\_ptr}{a\_pointer}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_pointer: ]
			A pointer.
		\end{description}
	\item[Output(s): ]
			Possible error printed to file descriptor 2.
	\item[Exception(s): ] None.
	\item[Description: ]
		If \cvar{a\_pointer} is NULL, print an error message to file
		descriptor 2 and \cfunc{abort}{}.

		Note: This macro is only active if the \cppdef{\_CW\_ASSERT} cpp
		macro is defined.
	\end{capilist}
\label{_cw_error}
\index{_cw_error@\cppmacro{\_cw\_error}{}}
\citem{\cppmacro[void]{\_cw\_error}{const char *a\_str}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_str: ]
			Pointer to a NULL-terminated character array.
		\end{description}
	\item[Output(s): ]
		Contents of \cvar{a\_str}, followed by a carriage return,
		printed to file descriptor 2.
	\item[Exception(s): ] None.
	\item[Description: ]
		Print the contents of \cvar{a\_str}, followed by a carriage
		return, to file descriptor 2.
	\end{capilist}
\label{_cw_ntohq}
\index{_cw_ntohq@\cppmacro{\_cw\_ntohq}{}}
\citem{\cppmacro[cw\_uint64\_t]{\_cw\_ntohq}{cw\_uint64\_t a\_val}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_val: ]
			64 bit integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			64 bit integer.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Convert \cvar{a\_val} from network byte order to host byte order
		and return the result.
	\end{capilist}
\label{_cw_htonq}
\index{_cw_htonq@\cppmacro{\_cw\_htonq}{}}
\citem{\cppmacro[cw\_uint64\_t]{\_cw\_htonq}{cw\_uint64\_t a\_val}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_val: ]
			64 bit integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			64 bit integer.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Convert \cvar{a\_val} from host byte order to network byte order
		and return the result.
	\end{capilist}
\end{capi}

\section{Classes}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/bhp}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/ch}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/cnd}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/dch}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/mem}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/mq}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/mtx}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/out}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/pezz}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/pool}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/ql}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/qr}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/qs}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/rwl}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/sma}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/thd}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/tsd}
\input{@abs_srcdir@/lib/c/libstash/doc/latex/xep}

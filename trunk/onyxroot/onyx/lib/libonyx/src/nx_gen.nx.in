################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Onyx <Version = onyx>
#
# Usage: nx_gen.nx [<options>]
#
#   Option: -B : Not bootstrapping.
#           -b : Bootstrapping.
#           -D : Not dstdir (objdir).
#           -d : dstdir.
#
# Read onyx code from stdin and output a revised version to stdout.  The
# output code defines the C function nx_p_nxcode().
#
# This program is run by the 'bootstrap' build system target.
#
################################################################################

# Parse the command line.
$opt_bootstrap false def
$opt_dstdir false def

$opt_dict <
    `-B' {
	$opt_bootstrap false def
    }
    `-b' {
	$opt_bootstrap true def
    }
    `-D' {
	$opt_dstdir false def
    }
    `-d' {
	$opt_dstdir true def
    }
> def

argv length 1 gt {
    argv 1 over length dec getinterval {
	opt_dict over known {
	    opt_dict exch get eval
	}{
	    # Unknown option.
	    `nx_gen.nx: Unknown option '
	    exch 1 sprints cat
	    `\n' cat

	    stderr exch write pop
	    1 die
	} ifelse
    } foreach
} if

# Create an encoding dictionary for various operators.  The values must not
# correspond to an existing name in dstack.  The byte overhead is the length of
# the name plus three.  So, a name must show up at least as many times as in
# the following table to bother adding an entry:
#
#   Length | Minimum use | Transform
#   -------+-------------+------------------------------------------------------
#        2 | 5           | xx xx xx xx --> $X~x x x x x
#        3 | 4           | xxx xxx xxx --> $X~xxx x x x
#        4 | 3           | xxxx xxxx xxxx --> $X~xxxx x x x
#        5 | 3           | xxxxx xxxxx xxxxx --> $X~xxxxx x x x
#      >=6 | 2           | xxxxxx xxxxxx --> $X~xxxxxx x x
#
$_encdict <
    $begin		$A	# 4
    $cat		$B	# 19
    $cvs		$C	# 6
    $cvx		$D	# 13
    $def		$E	# ~21
    $dup		$F	# ~37
    $echeck		$G	# 3
    $eq			$H	# 6
    $eval		$I	# 14
    $exch		$J	# ~57
    $false		$K	# 5
    $flush		$L	# 3
    $foreach		$M	# 9
    $get		$N	# 32
    $getinterval	$O	# 4
    $gt			$P	# 7
    $if			$Q	# 29
    $ifelse		$R	# 20
    $idup		$S	# ~66
    $known		$T	# 8
    $length		$U	# 16
    $load		$V	# 9
    $ne			$W	# 13
    $nip		$X	# 4
    $not		$Y	# 4
    $ostack		$Z	# 3
    $over		$a	# ~26
    $pop		$b	# ~69
    $print		$c	# 3
    $putinterval	$d	# 3
    $scount		$e	# 3
    $spop		$f	# 7
    $stderr		$g	# 10
    $stop		$h	# 3
    $stopped		$i	# 3
    $string		$j	# 2
    $sub		$k	# 15
    $systemdict		$l	# 3
    $true		$m	# 4
    $type		$n	# >= 17
    $until		$o	# 10
    $write		$p	# 10
    $xcheck		$q	# 3
> def

#proc _encarr -
$_encarr {
    0 1 2 idup length dec {
	#proc #i
	2 ndup get
	#proc #i #el
	dup type $nametype eq {
	    dup xcheck {
		compact {
		    # Executable Name.  Try to replace.
		    _encdict 1 idup known {
			_encdict exch get cvx
			#proc #i #e
			2 idup up
			#proc #proc #i #e
			put
		    }{
			2 npop
		    } ifelse
		}{
		    2 npop
		} ifelse
	    }{
		2 npop
	    } ifelse
	}{
	    dup type $arraytype eq {
		# Array.  Recurse.
		_encarr
		pop
	    }{
		# Other.  Do nothing.
		2 npop
	    } ifelse
	} ifelse
	#proc
    } for
    pop
} def

# Read in the code.
$code stdin cvx eval def

# Output the header.
`/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 * This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Onyx <Version = onyx>
 *
 ******************************************************************************/

#include "libonyx/libonyx.h"

' print

opt_bootstrap {
    # Bootstrap.  Output a string, uncompacted.
    $compact false def
    `\
void
nx_p_nxcode(cw_nx_t *a_nx)
{
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "\
' print

    # Output the code.
    `{' code `}' 3 ncat cvx eval 1000 sprints print

    # Output the footer.
    `\
bind eval end");
    nxo_thread_exit(&thread);
}
' print
}{
    # Non-bootstrap.  Read a file if CW_POSIX; output a compacted string
    # otherwise.
    $compact true def

    $init_file
    opt_dstdir {
	`@DATADIR@/onyx-@onyx_version@/libonyx/libonyx_init.nx'
    }{
	`@abs_objroot@/lib/libonyx/src/libonyx_init.nx'
    } ifelse
    def

    `\
void
nx_p_nxcode(cw_nx_t *a_nx)
{
#ifdef CW_POSIX
' print

    `\
#define CW_INIT_FILE "\
' print
    init_file print
    `\
"
' print

    `\
    cw_nxo_t thread, *ostack, *nxo, *dup;
    cw_nxn_t error;

    nxo_thread_new(&thread, a_nx);
    ostack = nxo_thread_ostack_get(&thread);
    nxo = nxo_stack_push(ostack);
    nxo_file_new(nxo, FALSE);
    if ((error = nxo_file_open(nxo, CW_INIT_FILE, sizeof(CW_INIT_FILE) - 1,
			      "r", sizeof("r") - 1, 0644)))
    {
	fprintf(stderr, "Error opening init file \"%s\": %.*s\\n", CW_INIT_FILE,
		nxn_len(error), nxn_str(error));
	exit(1);
    }
    nxo_file_origin_set(nxo, CW_INIT_FILE, sizeof(CW_INIT_FILE) - 1);
    dup = nxo_stack_push(ostack);
    nxo_dup(dup, nxo);
    nxo_attr_set(dup, NXOA_EXECUTABLE);
    nxo_thread_start(&thread);
    if ((error = nxo_file_close(nxo)))
    {
	fprintf(stderr, "Error closing init file \"%s\": %.*s\\n", CW_INIT_FILE,
		nxn_len(error), nxn_str(error));
	exit(1);
    }
    nxo_stack_pop(ostack);
    nxo_thread_exit(&thread);
' print
    `\
#else
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "\
' print

    # Output the translation dictionary.
    `<' print
    _encdict {
	1 sprints print
	`~' print cvx 1 sprints print
    } foreach
    `>begin' print

    # Recursively iterate through the elements of the array and replace
    # executable names with their equivalents in the temporary shorthand
    # dictionary.
    `{' code `}' 3 ncat cvx eval dup _encarr
    # Output the code.
    1000 sprints print

    # Output the footer.
    `\
bind eval end");
    nxo_thread_exit(&thread);
#endif
}
'print

} ifelse

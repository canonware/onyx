################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Onyx <Version = onyx>
#
# This file is processed by nxo_thread_gen.nx to produce a more compact
# embedded version in nxo_thread_nxcode.c (normal build) and
# nxo_thread_bootstrap.c (development bootstrap).  In order to make changes to
# this file take effect in the bootstrap interpreter, either type:
#
#   cook bootstrap
#
# or
#
#   cat nxo_thread.nx | onyx nxo_thread_gen.nx > nxo_thread_boostrap.c
#
# The end result of executing this file is a procedure (executable array).  In
# order to support output that differs according to configuration options, a
# string is constructed, then evaluated.
#
# The output of running sprints on the procedure must be evaluatable, which
# means that certain language features such as immediate evaluation must be
# avoided.
#
################################################################################

# Initial string with an opening brace to defer execution, to which other
# strings are catenated.
`{'

`
# userdict does not exist yet.  This code pushes it onto dstack, then defines it
# in threaddict.
dict begin
$userdict currentdict
dstack dup sbdup dup spop begin pop
$threaddict currentdict def
def

# Define and initialize currenterror.
$currenterror <
    $newerror	false
    $errorname	`'
    $estack	stack
    $istack	stack
    $ostack	stack
    $dstack	stack
    $line	1
    $column	0
> def

# Define and initialize errordict.
$errordict <
    $stop $stop load

    # - handleerror -
    $handleerror {
	$currenterror load begin

	# Avoid the need to check for partial writes.
	stderr nonblocking
	stderr false setnonblocking

	# If this is a syntaxerror, print the line and column numbers.
	$errorname load $syntaxerror eq {
	    stderr dup `At line ' write pop
	    dup $line load cvs write pop
	    dup `, column ' write pop
	    dup $column load cvs write pop
	    `: ' write pop
	} if

	# Print the errorname.
	stderr dup `Error ' write pop
	dup $errorname load 1 sprints write pop

	# Print ostack and dstack using sprint.
	dup `\nostack: ' write pop
	dup $ostack load 1 sprints write pop
	dup `\ndstack: ' write pop
	dup $dstack load 1 sprints write pop
	`\n' write pop

	# Print a stack trace that depicts the currently executing element of
	# arrays.
	$estack load scount 1 sub dup 0 gt {
	    stderr dup `estack/istack trace (0..' write pop
	    1 idup cvs stderr exch write pop
	    `):\n' write pop
	} if

	# For each element in estack:
	0 1 dn {
	    # #edepth
	    # If this element is an array, print it specially.
	    dup cvs stderr exch write pop
	    dup $estack load dup dn sidup spop
	    # #edepth #array

	    dup type $arraytype eq {
		# Array.
		`: {\n' stderr exch write pop
		# #edepth #array
		dup length 1 sub 0 1 dn {
		    # #edepth #array #aindex
		    2 idup $istack load
		    dup dn sidup spop
		    # #edepth #array #aindex #iindex
		    1 idup
		    # #edepth #array #aindex #iindex #aindex
		    eq {
			dup <$w 3> outputs
			stderr exch write pop
			`:--> '
		    }{
			`\t'
		    } ifelse
		    stderr exch write pop
		    # #edepth #array #aindex
		    1 idup exch get 1 sprints
		    stderr exch write pop
		    stderr `\n' write pop
		    # #edepth #array
		} for
		stderr `}\n' write pop
		# #edepth #array
		pop
		# #edepth
	    }{
		# Non-array.
		stderr `:\t' write pop
		# #edepth #array
		1 sprints stderr exch write pop
		stderr `\n' write pop
		# #edepth
	    } ifelse
	    # #edepth
	    pop
	} for

	# Set nonblocking mode of stderr back.
	stderr exch setnonblocking

	end # currenterror.

	# Make sure the output gets written before stop.
	flush
    } bind
> def

end # threaddict.
' cat

# Final closing brace.
`}' cat cvx eval

################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Onyx <Version = onyx>
#
# This file is processed by nx_gen.nx to produce a more compact embedded version
# in nx_nxcode.c (normal build) and nx_bootstrap.c (development bootstrap).  In
# order to make changes to this file take effect in the bootstrap interpreter,
# either type:
#
#   cook bootstrap
#
# or
#
#   cat nx.nx | onyx nx_gen.nx > nx_boostrap.c
#
# The end result of executing this file is a procedure (executable array).  In
# order to support output that differs according to configuration options, a
# string is constructed, then evaluated.
#
# The output of running sprints on the procedure must be evaluable, which
# means that certain language features such as immediate evaluation must be
# avoided.
#
################################################################################

# Initial string with an opening brace to defer execution, to which other
# strings are catenated.
`{'

`
systemdict begin

#
# sprintsdict implements syntactic printing to strings for every type.
#
$sprintsdict <
    $arraytype {
	#array #depth
	dup 0 gt {
	    over dup xcheck {
		pop
		`{'
	    }{
	    echeck {
		`_{'
	    }{
		`['
	    } ifelse
	    } ifelse

	    #array #depth #accum
	    2 idup length 1 gt {
		#array #depth #accum
		0 1 4 idup length 2 sub {
		    #array #depth #accum #i
		    3 idup exch get
		    2 idup 1 sub
		    #array #depth #accum #el #rdepth
		    over type sprintsdict exch get eval
		    cat
		    #array #depth #accum #el #rdepth
		` ' cat
		} for
	    } if
	    #array #depth #accum

	    2 idup length 0 gt {
		2 idup dup length 1 sub get
		2 idup 1 sub
		#array #depth #accum #el #rdepth
		over type sprintsdict exch get eval
		cat
	    } if
	    #array #depth #accum

	    nip
	    #array #accum
	    exch dup xcheck {
		pop
		`}'
	    }{
	    echeck {
		`}_'
	    }{
		`]'
	    } ifelse
	    } ifelse
	    cat
	    #accum
	}{
	    pop pop
	    `-array-'
	} ifelse
    }
    $booleantype {
	pop
	cvs
    }
' cat
@enable_oop@ 1 eq opt_bootstrap not and {
    `
    $classtype {
	pop pop
	`-class-'
    }
    ' cat
} if
@enable_threads@ 1 eq {
    `
    $conditiontype {
	pop pop
	`-condition-'
    }
    ' cat
} if
`
    $dicttype {
	#dict #depth
	dup 0 gt {
	    # Update recursion depth.
	    1 sub

	    0
	    `<'

	    #dict #rdepth #i #accum
	    3 idup {
		#dict #rdepth #i #accum #key #value
		exch 4 idup
		#dict #rdepth #i #accum #value #key #rdepth
		over type sprintsdict exch get eval
		` ' cat
		#dict #rdepth #accum #i #value #keystr
		exch 4 idup
		#dict #rdepth #i #accum #keystr #value #rdepth
		over type sprintsdict exch get eval
		#dict #rdepth #i #accum #keystr #valstr
		cat cat
		#dict #rdepth #i #accum

		# Update counter.
		exch 1 add dup 4 idup length lt {
		    #dict #rdepth #accum #i
		    exch
		    ` ' cat
		    #dict #rdepth #i #accum
		}{
		    # Last element.
		    exch
		    #dict #rdepth #accum
		} ifelse
	    } foreach
	    #dict #rdepth #i #accum

	    4 nup pop pop pop
	    #accum
	    `>'
	    cat
	    #accum
	}{
	    pop pop
	    `-dict-'
	} ifelse
    }
    $filetype {
	pop pop
	`-file-'
    }
    $finotype {
	pop pop
	`-fino-'
    }
' cat
@enable_handle@ 1 eq {
    `
    $handletype {
	#handle #depth
	exch handletag
	#depth #tag
	dup type $nulltype ne {
	    exch 1 sub
	    #tag #rdepth
	    over type sprintsdict exch get eval
	    #tagstr
	    `=' exch cat
	    `=' cat
	}{
	    pop pop
	    `-handle-'
	} ifelse
    }
    ' cat
} if
@enable_oop@ 1 eq opt_bootstrap not and {
    `
    $instancetype {
	pop pop
	`-instance-'
    }
    ' cat
} if
`
    $integertype {
	pop
	cvs
    }
    $marktype {
	pop pop
	`-mark-'
    }
' cat
@enable_threads@ 1 eq {
    `
    $mutextype {
	pop pop
	`-mutex-'
    }
    ' cat
} if
# Note code duplication.
@enable_oop@ 1 eq opt_bootstrap not and {
    `
    $nametype {
	#name #depth
	pop
	dup cvs exch
	#str #name
	dup lcheck {
	    # Literal.
	    pop
	    `$' exch cat
	}{
	dup echeck {
	    # Evaluable.
	    pop
	    `!' exch cat
	}{
	ccheck {
	    # Callable.
	    `:' exch cat
	} if
	} ifelse
	} ifelse
    }
    ' cat
}{
    `
    $nametype {
	#name #depth
	pop
	dup cvs exch
	#str #name
	dup lcheck {
	    # Literal.
	    pop
	    `$' exch cat
	}{
	echeck {
	    # Evaluable.
	    `!' exch cat
	} if
	} ifelse
    }
    ' cat
} ifelse
`
    $nulltype {
	pop pop
	`null'
    }
    $operatortype {
	pop
	cvs
	dup `-operator-' ne {
	    `--' tuck
	    cat cat
	} if
    }
    $pmarktype {
	pop pop
	`-pmark-'
    }
' cat
@enable_real@ 1 eq {
    `
    $realtype {
	pop
	cvs
    }
    ' cat
} if
@enable_regex@ 1 eq {
    `
    $regextype {
	pop pop
	`-regex-'
    }
    $regsubtype {
	pop pop
	`-regsub-'
    }
    ' cat
} if
`
    $stacktype {
	#stack #depth
	dup 0 gt {
	    `('

	    #stack #depth #accum
	    2 idup scount 1 gt {
		#stack #depth #accum
		2 idup scount 1 sub -1 1 {
		    #stack #depth #accum #i
		    3 idup dup dn sidup spop
		    2 idup 1 sub
		    #stack #depth #accum #el #rdepth
		    over type sprintsdict exch get eval
		    cat
		    #stack #depth #accum #el #rdepth
		` ' cat
		} for
	    } if
	    #stack #depth #accum

	    2 idup scount 0 gt {
		2 idup dup sdup spop
		2 idup 1 sub
		#stack #depth #accum #el #rdepth
		over type sprintsdict exch get eval
		cat
	    } if
	    #stack #depth #accum

	    up 2 npop
	    #accum
	    `)'
	    cat
	    #accum
	}{
	    pop pop
	    `-stack-'
	} ifelse
    }
    $stringtype {
	pop
	cvs
    }
    $threadtype {
	pop pop
	`-thread-'
    }
> def

#object #depth sprints #string
$sprints {
    over type sprintsdict exch get eval
} def

$sprint {
    sprints print
    `\n' print flush
} def

#
# outputsdict implements formatted output to strings for every type.
#
$outputsdict <
    $integertype {
	#int #flags

	# Get the base.
	dup $b known {
	    dup $b get
	}{
	    10
	} ifelse
	#int #flags #base

	2 idup exch cvrs
	#int #flags #str

	# Prepend the sign if necessary.
	over $s known {
	    over $s get $+ eq {
		2 idup 0 ge {
		    `+' exch cat
		} if
	    } if
	} if
	#int #flags #str
	dn pop
	#flags #str
	exch
	#str #flags
	outputsdict $stringtype get eval
	#str
    }
' cat
@enable_real@ 1 eq {
    `
    $realtype {
	#real #flags

	# Determine precision past decimal point.
	dup $d known {
	dup $d get
	}{
	6
	} ifelse
	#real #flags #precision
	
	# Determine whether to use decimal or exponential notation.
	over $e known {
	over $e get
	}{
	false
	} ifelse
	#real #flags #precision #exp?

	3 idup up
	#real #flags #real #precision #exp?
	{
	# Use exponential notation.
	cves
	}{
	# Use decimal notation.
	cvds
	} ifelse
	#real #flags #str

	# Prepend the sign if necessary.
	over $s known {
	over $s get $+ eq {
	    2 idup 0 ge {
	    `+' exch cat
	    } if
	} if
	} if
	#real #flags #str
	dn pop exch
	#str #flags

	outputsdict $stringtype get eval
	#str
    }
    ' cat
} if
`
    # Temporarily define.
    $_s {
	# Check for $w flag.  $w takes precedence over $n.
	dup $w known {
	    # Get padding character.
	    dup $p known {
		dup $p get
	    }{
		` '
	    } ifelse
	    #str #flags #pad

	    over $w get
	    #str #flags #pad #width
	    3 idup length
	    #str #flags #pad #width #len

	    dup 2 idup le {
		# Pad string.
		#str #flags #pad #width #len

		over string
		#str #flags #pad #width #len #pstr

		# Fill #pstr with #pad.
		0 1 4 idup 1 sub {
		    over exch 5 idup putinterval
		} for
		#str #flags #pad #width #len #pstr
		3 ipop
		#str #flags #width #len #pstr

		# Get the justification.
		3 idup $j known {
		    3 idup $j get
		}{
		    $r
		} ifelse
		#str #flags #width #len #pstr #just

		dup $r eq {
		    pop
		    # Right justify.
		    #str #flags #width #len #pstr
		    up sub
		}{
		$l eq {
		    # Left justify.
		    #str #flags #width #len #pstr
		    up 2 npop
		    0
		}{
		    # Center.
		    #str #flags #width #len #pstr
		    up sub 2 idiv
		} ifelse
		} ifelse
		#str #flags #pstr #offset

		over exch
		#str #flags #pstr #pstr #offset
		5 ndn
		#flags #pstr #pstr #offset #str
		putinterval
		#flags #pstr
		exch
		#pstr #flags
	    }{
		# No padding necessary.
		pop pop pop
	    } ifelse
	    #str #flags
	}{
	    #str #flags
	    dup $n known {
		# Truncate the string if it is too long.
		over length
		over $n get
		#str #flags #len #max
		dup 2 idup lt {
		    # Truncate.
		    nip
		    dup string
		    #str #flags #max #nstr
		    dup
		    #str #flags #max #nstr #nstr
		    5 ndn
		    #flags #max #nstr #nstr #str
		    4 ndn
		    #flags #nstr #nstr #str #max
		    0 exch getinterval
		    #flags #nstr #nstr #substr
		    0 exch putinterval
		    #flags #nstr
		    exch
		}{
		    pop pop
		} ifelse
		#nstr #flags
	    } if
	    #str #flags
	} ifelse
	#str #flags

	pop
	#str
    } def
    $stringtype $_s load

    # Most types can be handled identically.  The following code uses the
    # same procedure body for all of those types.
    #
    # The following block of code looks scary because it avoids deferred
    # execution in order to "bind" things correctly (we cannot use immediate
    # evaluation in this file).
    [
	#object #flags

	# Get recursion depth.
	$dup cvx $r $known cvx [
	    $dup cvx $r $get cvx
	] cvx [
	    1
	] cvx $ifelse cvx
	#object #flags #rdepth

	$dn cvx $exch cvx
	#flags #object #rdepth
	$sprints cvx $exch cvx
	#str #flags
	$_s load cve
	#str
    ] cvx bind
    [
	$arraytype
	$booleantype
' cat
@enable_oop@ 1 eq opt_bootstrap not and {
    `
	$classtype
    ' cat
} if
@enable_threads@ 1 eq {
    `
	$conditiontype
    ' cat
} if
`
	$dicttype
	$filetype
	$finotype
' cat
@enable_threads@ 1 eq {
    `
	$handletype
    ' cat
} if
@enable_oop@ 1 eq opt_bootstrap not and {
    `
	$instancetype
    ' cat
} if
`
	$marktype
' cat
@enable_threads@ 1 eq {
    `
	$mutextype
    ' cat
} if
`
	$nametype
	$nulltype
	$operatortype
	$pmarktype
' cat
@enable_regex@ 1 eq {
    `
	$regextype
	$regsubtype
    ' cat
} if
`
	$stacktype
	$threadtype
    ]{
	#proc #name
	exch dup
	#name #proc #proc
    } foreach
    # Get rid of the extra copy of #proc.
    pop

    # Now that we are done using _s, undef it.
    currentdict $_s undef
> def

#
# Formatted output to a string.  Supported flags:
#
# All types:
#
# $n : maximum width
#    : #integer
# $w : minimum width
#    : #integer
# $j : justification
#    : $l, $c, $r
# $p : padding character
#    : `?'
# $r : recursion depth
#    : 0..n
#
# Integers only:
#
# $b : base
#    : 2..36
# $s : sign
#    : $+ $-
#
# Reals only:
#
# $d : digits of precision past decimal
#    : #integer (default 6)
# $e : exponential notation
#    : #boolean (default false)
#
#obj #flags outputs #string
$outputs {
    dup type $dicttype ne {
	$typecheck throw
    } if
    over type
    #obj #flags #type
    outputsdict exch get eval
} def

#obj #flags output -
$output {
    outputs print
} def

# - product #string
$product `Canonware Onyx' def

# - pstack -
$pstack {
    ostack {
	1 sprint
    } foreach
    flush
} def

#
#string #pattern search #post #pattern #pre true
#string #pattern search #string false
#
$search {
    # Make sure the arguments are strings.
    # Pattern.
    dup type $stringtype ne {
	$typecheck throw
    } if
    # String.
    over type $stringtype ne {
	$typecheck throw
    } if

    # Make sure substring is not longer than string.
    dup length 2 idup length le {
	# Use a nested looping algorithm.  The outer loop advances the
	# offset #s_i at which to start the search in the string #s,
	# and the inner loop compares byte by byte with the pattern #p.
	#
	# Take care not to cause a rangecheck error.
	0 1 3 idup length 3 idup length sub {
	    #s #p #s_i

	    # Create a substring #s_sub of #s that is the same
	    # length as #p, starting at #s_i.
	    dup 3 idup exch 3 idup length getinterval

	    #s #p #s_i #s_sub
	    dup length 1 sub 0 1
	    dn
	    {
		#s #p #s_i #s_sub #offset
		dup 2 idup exch get
		exch 4 idup exch get
		ne {
		    # Not equal.  Exit the inner loop.
		    false exit
		} if
	    } for

	    # Check to see if the substring match failed.
	    dup type $booleantype eq {
		#s #p #s_i #s_sub false
		# Failure.  Clean up.
		pop pop pop
	    }{
		#s #p #s_i #s_sub
		# Success.
		2 ipop
		#s #s_i #s_sub

		# Contstruct pre string #s_pre.
		up dup 2 idup exch 0 exch
		#s_sub #s #s_i #s 0 #s_i
		getinterval
		#s_sub #s #s_i #s_pre
		up
		#s_sub #s_pre #s #s_i

		# Contstruct post string #s_post.
		3 idup length add dup
		2 idup length exch sub
		getinterval
		#s_sub #s_pre #s_post
		up

		true
		#s_post #s_sub #s_pre true
		exit
	    } ifelse
	} for

	# Check to see if we succeeded.  If not, set up the stack to
	# return failure.
	dup type $booleantype ne {
	    # Failure.
	    pop false
	} if
    }{
	# Substring is too long.
	pop false
    } ifelse
} def
' cat
@enable_posix@ 1 eq {
    `
# [`<path>' `<args>'...] system #exit_code
$system {
    # Make sure argument is an array.
    dup type $arraytype ne {
	$typecheck throw
    } if
    # Make sure array is non-empty.
    dup length 0 eq {
	$rangecheck throw
    } if
    # Make sure array elements are strings.
    dup {
	{
	    type $stringtype ne {
		stop
	    } if
	} foreach
    } stopped {
	$typecheck throw
    } if

    forkexec
    waitpid
} def
    ' cat
} if

@enable_modules@ 1 eq {
    `
# Define require and mrequire configuration parameters in onyxdict.  By default,
# the search order is:
#
# 1) Absolute path: `'.
# 2) Relative path: `.'.
# 3) $ONYX_[MR]PATH: Colon-separated string in envdict.
# 4) `@prefix@/share/onyx-@onyx_version@/nx[m]': Standard installation location.
onyxdict begin
$rpath_pre [`' `.'] def
$rpath_post [@rpath_post@] def

$mpath_pre [`' `.'] def
$mpath_post [@mpath_post@] def
end # onyxdict.

#filename require -
$require {
    # Make sure the argument is a string.
    dup type $stringtype ne {
	$typecheck throw
    } if

    {
	[
	    onyxdict $rpath_pre get

	    envdict $ONYX_RPATH 2 ndup known {
		get

		# Push mark that denotes start of array.
		[ exch
		{
		    # [ ... #cpath
		    `:' search {
			#post `:' #dir
			nip exch
			# [ ... #dir #post
		    }{
			# Last path component.
			#dir
			exit
		    } ifelse
		} loop
		# Create array.
		]
	    }{
		2 npop
	    } ifelse

	    onyxdict $rpath_post get
	]{
	    #filename #path
	    {
		#filename #dir
		`/' cat
		over cat
		#filename #full_path
		dup `f' test {
		    # Found.
		    #filename #full_path
		    nip
		    #full_path
		    `r' open cvx eval
		    stop # Success.
		}{
		    # Not found.
		    #filename #full_path
		    pop
		} ifelse
	    } foreach
	} foreach
    } stopped not {
	# Failure.
	$undefinedfilename throw
    } if
} def

#filename #symbol mrequire -
$mrequire {
    # Make sure the arguments are strings.
    over type $stringtype ne {
	$typecheck throw
    } if
    dup type $stringtype ne {
	$typecheck throw
    } if

    exch
    #symbol #filename
    {
	[
	    onyxdict $mpath_pre get

	    envdict $ONYX_MPATH 2 ndup known {
		get

		# Push mark that denotes start of array.
		[ exch
		{
		    # [ ... #cpath
		    `:' search {
			#post `:' #dir
			nip exch
			# [ ... #dir #post
		    }{
			# Last path component.
			#dir
			exit
		    } ifelse
		} loop
		# Create array.
		]
	    }{
		2 npop
	    } ifelse

	    onyxdict $mpath_post get
	]{
	    #symbol #filename #path
	    {
		#symbol #filename #dir
		`/' cat
		over cat
		#symbol #filename #full_path
		dup `f' test {
		    # Found.
		    #symbol #filename #full_path
		    nip
		    #symbol #full_path
		    exch modload
		    stop # Success.
		}{
		    # Not found.
		    #symbol #filename #full_path
		    pop
		} ifelse
	    } foreach
	} foreach
    } stopped not {
	# Failure.
	#symbol #filename
	exch
	$undefinedfilename throw
    } if
} def
    ' cat
} if
@enable_oop@ 1 eq opt_bootstrap not and {
    `
# Define vclass, which is provided as the top level base class.
$vclass class dup up def
dup $vclass setclassname
dup <
> setdata
<
    #class #instance :init #instance
    $init {
	# Do nothing.
	nip
    }

    #class :new #instance
    $new {
	# Create instance.
	instance 2 ndup exch setisa

	# XXX Hard-code to avoid lookup?
	:init
    }

    # Typically called at the beginning of :new or :init in subclasses.
    # Recursively invokes :init, and sets isa.
    #
    #class #instance :rinit #instance
    $rinit {
	exch super
	#instance #super
	dup type $classtype eq {
	    tuck methods
	    #super #instance #methods
	    dup type $dicttype eq {
		dup $init known {
		    # Call super:init.
		    $init get eval
		}{
		    # :init not defined.
		    pop
		    $undefined throw
		} ifelse
	    }{
		# No methods.
		pop
		$undefined throw
	    } ifelse
	}{
	    # No superclass.
	    pop
	    $undefined throw
	} ifelse
    }

    # Typically called at the beginning of :new in subclasses.  Recursively
    # invokes :new, and sets isa.
    #
    #class :rnew #instance
    $rnew {
	#class

	dup super
	dup type $classtype eq {
	    dup methods
	    dup type $dicttype eq {
		dup $new known {
		    # Call super:new.
		    $new get eval
		}{
		    # :new not defined.
		    pop
		    instance
		} ifelse
	    }{
		# No methods.
		pop
		instance
	    } ifelse
	}{
	    # No superclass.
	    pop
	    instance
	} ifelse
	#class #instance

	dup dn setisa
	#instance
    }

    #class :classname #name/null
    $classname $classname load

    #name #class :setclassname -
    $setclassname {
	exch setclassname
    }

    #class :super #super
    $super $super load

    #super #class :setsuper -
    $setsuper {
	exch setsuper
    }

    #class/instance :data #data
    $data $data load

    #data #class/instance :setdata -
    $setdata {
	exch setdata
    }

    #class :methods #methods
    $methods $methods load

    #methods #class :setmethods -
    $setmethods {
	exch setmethods
    }

    #name #class :method #method
    $method {
	exch method
    }

    #
    # Instance-related methods.
    #

    #instance :isa #class
    $isa $isa load

    #class #instance :setisa -
    $setisa {
	exch setisa
    }

    #class #instance :kind #boolean
    $kind {
	exch kind
    }
> setmethods
    ' cat
} if
`
# $errorname throw -
$throw {
    # Do some sanity checking, to try to avoid going infinitely recursive
    # in the error handling machinery.
    {
	{$errordict where {pop true}{false} ifelse}
	{!errordict $handleerror known}
	{!errordict $stop known}
	{$currenterror where {pop true}{false} ifelse}
    }{
	eval not {
	    `Onyx: Missing errordict or currenterror defs\n'
	    {stderr exch write}{} until

	    # Print stack dumps.
	    `ostack: ' {stderr exch write}{} until
	    ostack 2 sprints {stderr exch write}{} until

	    `\ndstack: ' {stderr exch write}{} until
	    dstack 2 sprints {stderr exch write}{} until

	    `\nestack: ' {stderr exch write}{} until
	    estack 2 sprints {stderr exch write}{} until

	    `\nistack: ' {stderr exch write}{} until
	    istack 2 sprints {stderr exch write}{} until

	    `\nOnyx: dieing\n' {stderr exch write}{} until
	    1 die
	} if
    } foreach

    # Make sure the argument is a name.
    dup type $nametype ne {
	$typecheck !throw
    } if

    !currenterror begin

    # Set newerror to true to indicate there is an error.  It is up to the
    # application to clear this afterwards if it wants to make newerror
    # meaningful in the face of multiple errors.
    $newerror true def

    # Set errorname to the argument passed in.
    dup $errorname exch cvl def

    # ostack.  Get rid of $errorname in the snapshot.  Ordering is important
    # to keep from polluting the snapshot.
    ostack dup spop pop $ostack exch def

    # dstack.  Do not include the top element, which is the copy of
    # currenterror that we pushed.
    $dstack dstack dup spop pop def

    # estack.  Remove this procedure from the snapshot.
    $estack estack dup spop pop def

    # istack.  Remove this procedure from the snapshot.
    $istack istack dup spop pop def

    # Push the offending object onto ostack.
    !estack dup sdup spop
    exch
    #object #errorname

    end # currenterror.

    # If there is an error handler for the error name, call it.  Otherwise,
    # call the errordict handleerror, then call the errordict stop.
    !errordict
    #object #errorname #errordict
    dup 2 idup known {
	# Call error handler.
	exch get eval
    }{
	# No error handler.
	nip
	dup $handleerror get eval
	$stop get eval
    } ifelse
} def

# - version #string
$version `<Version = onyx>' def

end # systemdict.
' cat

# Final closing brace.
`}' cat cvx eval

/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 * This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Onyx <Version = onyx>
 *
 ******************************************************************************/

#include "libonyx/libonyx.h"

void
nx_p_nxcode(cw_nx_t *a_nx)
{
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "<$+$$xcheck$z$$write$y$$until$x$$type$w$$true$v$$systemdict$u$$sub$t$$stderr$s$$spop$r$$scount$q$$putinterval$p$$pop$o$$ostack$n$$load$m$$length$l$$known$k$$idup$j$$ifelse$i$$getinterval$h$$flush$g$$false$f$$exch$e$$eval$d$$dup$c$$def$b$$cvx$a$$cat$/$$begin>begin{v / $sprintsdict < $arraytype {d 0 gt {1 k d echeck {p `_{'} {+ {`{'} {`['} j} j 2 k m 1 gt {0 1 4 k m 2 u {3 k f get 2 k 1 u 1 k x sprintsdict f get e a ` ' a} for} if 2 k m 0 gt {2 k d m 1 u get 2 k 1 u 1 k x sprintsdict f get e a} if nip f d echeck {p `}_'} {+ {`}'} {`]'} j} j a} {p p `-array-'} j} $booleantype {p cvs} $conditiontype {p p `-condition-'} $dicttype {d 0 gt {1 u 0 `<' 3 k {f 4 k 1 k x sprintsdict f get e ` ' a f 4 k 1 k x sprintsdict f get e a a f 1 add d 4 k m lt {f ` ' a} {f} j} foreach 4 nup p p p `>' a} {p p `-dict-'} j} $filetype {p p `-file-'} $finotype {p p `-fino-'} $hooktype {f hooktag d x $nulltype ne {f 1 u 1 k x sprintsdict f get e `=' f a `=' a} {p p `-hook-'} j} $integertype {p cvs} $marktype {p p `-mark-'} $mutextype {p p `-mutex-'} $nametype {p d cvs f + not {`$' f a} if} $nulltype {p p `null'} $operatortype {p cvs d `-operator-' ne {`--' d up a a} if} $pmarktype {p p `-pmark-'} $realtype {p cvs} $stacktype {d 0 gt {`(' 2 k r 1 gt {2 k r 1 u -1 1 {3 k d dn sidup s 2 k 1 u 1 k x sprintsdict f get e a ` ' a} for} if 2 k r 0 gt {2 k d sdup s 2 k 1 u 1 k x sprintsdict f get e a} if up 2 npop `)' a} {p p `-stack-'} j} $stringtype {p cvs} $threadtype {p p `-thread-'} > c $sprints {1 k x sprintsdict f get e} c $sprint {sprints print `\n' print h} c $outputsdict < $integertype {d $b l {d $b get} {10} j 2 k f cvrs 1 k $s l {1 k $s get $+ eq {2 k 0 ge {`+' f a} if} if} if dn p f outputsdict $stringtype get e} $realtype {d $d l {d $d get} {6} j 1 k $e l {1 k $e get} {g} j 3 k up {cves} {cvds} j 1 k $s l {1 k $s get $+ eq {2 k 0 ge {`+' f a} if} if} if dn p f outputsdict $stringtype get e} $_s {d $w l {d $p l {d $p get} {` '} j 1 k $w get 3 k m d 2 k le {1 k string 0 1 4 k 1 u {1 k f 5 k q} for 3 ipop 3 k $j l {3 k $j get} {$r} j d $r eq {p up u} {$l eq {up 2 npop 0} {up u 2 idiv} j} j 1 k f 5 ndn q f} {p p p} j} {d $n l {1 k m 1 k $n get d 2 k lt {nip d string d 5 ndn 4 ndn 0 f i 0 f q f} {p p} j} if} j p} c $stringtype $_s n [ $dup b $r $known b [ $dup b $r $get b ] b [ 1 ] b $ifelse b $dn b $exch b $sprints b $exch b $_s n cve ] b bind [ $arraytype $booleantype $conditiontype $dicttype $filetype $finotype $hooktype $marktype $mutextype $nametype $nulltype $operatortype $pmarktype $stacktype $threadtype ] {f d} foreach p currentdict $_s undef > c $outputs {d x $dicttype ne {$typecheck throw} if 1 k x outputsdict f get e} c $output {outputs print} c $product `Canonware Onyx' c $pstack {o {1 sprint} foreach h} c $search {d x $stringtype ne {$typecheck throw} if 1 k x $stringtype ne {$typecheck throw} if d m 2 k m le {0 1 3 k m 3 k m u {d 3 k f 3 k m i d m 1 u 0 1 dn {d 2 k f get f 4 k f get ne {g exit} if} for d x $booleantype eq {p p p} {2 ipop up d 2 k f 0 f i up 3 k m add d 2 k m f u i up w exit} j} for d x $booleantype ne {p g} if} {p g} j} c $system {d x $arraytype ne {$typecheck throw} if d m 0 eq {$rangecheck throw} if d {{x $stringtype ne {stop} if} foreach} stopped {$typecheck throw} if forkexec waitpid} c onyxdict / $rpath_pre [ `' `.' ] c $rpath_post [ `/usr/local/share/onyx-devel/nx' ] c $mpath_pre [ `' `.' ] c $mpath_post [ `/usr/local/share/onyx-devel/nxm' ] c end $require {d x $stringtype ne {$typecheck throw} if {[ onyxdict $rpath_pre get envdict $ONYX_RPATH 2 ndup l {get [ f {`:' search {nip f} {exit} j} loop ]} {2 npop} j onyxdict $rpath_post get ] {{`/' a 1 k a d `f' test {`r' open b e p stop} {p} j} foreach} foreach} stopped not {$undefinedfilename throw} if} c $mrequire {1 k x $stringtype ne {$typecheck throw} if d x $stringtype ne {$typecheck throw} if f {[ onyxdict $mpath_pre get envdict $ONYX_MPATH 2 ndup l {get [ f {`:' search {nip f} {exit} j} loop ]} {2 npop} j onyxdict $mpath_post get ] {{`/' a 1 k a d `f' test {dn modload p stop} {p} j} foreach} foreach} stopped not {f $undefinedfilename throw} if} c $throw {{{$errordict where {p w} {g} j} {$errordict n $handleerror l} {$errordict n $stop l} {$currenterror where {p w} {g} j}} {e not {t `Onyx: Missing errordict or currenterror defs\n' {z} {} y t `ostack: ' {z} {} y o 2 sprints t f {z} {} y t `\ndstack: ' {z} {} y t dstack 2 sprints {z} {} y t `\nestack: ' {z} {} y t estack 2 sprints {z} {} y t `\nistack: ' {z} {} y t istack 2 sprints {z} {} y t `\nOnyx: dieing\n' {z} {} y 1 die} if} foreach d x $nametype ne {$typecheck $systemdict n $throw get e} if $currenterror n / $newerror w c d $errorname f cvlit c o d s p $ostack f c $dstack dstack d s p c $estack estack d s p c $istack istack d s p c $estack n d sdup s f end $errordict n d 2 k l {f get e} {nip d $handleerror get e $stop get e} j} c $version `<Version = onyx>' c end}bind eval end");
    nxo_thread_exit(&thread);
}

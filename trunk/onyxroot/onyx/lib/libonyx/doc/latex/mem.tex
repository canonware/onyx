%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% mem portion of Onyx Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{mem}
\label{mem}
\index{mem@\classname{mem}{}}

The \classname{mem} class implements a memory allocation (malloc) wrapper.  For
the debug version of \libname{libonyx}, extra information is hashed for each
memory allocation that allows tracking of the following:

\begin{itemize}
\item{File/line number of allocation.}
\item{Double allocation/deallocation of the same address.}
\item{Memory leaks (memory left allocated at mem destruction time).}
\end{itemize}

If any memory leaks are detected, diagnostic output is printed to
\cvar{out\_err}.

Also, the debug version of \libname{libonyx} sets all newly allocated bytes to
{\tt 0xa5}, and all deallocated bytes to {\tt 0x5a} (except in the case of
\cfunc{mem\_calloc}{}).  This tends to cause things to break sooner when
uninitialized or deallocated memory is referenced.

In general, the \classname{mem} class doesn't need to be used directly.
Instead, there are several preprocessor macros that can be used:
\cppmacro{\_cw\_malloc}{}, \cppmacro{\_cw\_calloc}{},
\cppmacro{\_cw\_realloc}{}, and \cppmacro{\_cw\_free}{}.

\subsubsection{API}
\begin{capi}
\label{mem_new}
\index{mem_new@\cfunc{mem\_new}{}}
\citem{\cfunc[cw\_mem\_t *]{mem\_new}{cw\_mem\_t *a\_mem, cw\_mem\_t
*a\_internal}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to space for a \classname{mem}, or NULL.
		\item[a\_internal: ]
			Pointer to a \classname{mem} to use for internal
			memory allocation, or NULL.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{mem}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{capilist}
\label{mem_delete}
\index{mem_delete@\cfunc{mem\_delete}{}}
\citem{\cfunc[void]{mem\_delete}{cw\_mem\_t *a\_mem}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to a \classname{mem}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.
	\end{capilist}
\label{mem_malloc_e}
\index{mem_malloc_e@\cfunc{mem\_malloc\_e}{}}
\citem{\cfunc[void *]{mem\_malloc\_e}{cw\_mem\_t *a\_mem, size\_t a\_size, const
char *a\_filename, cw\_uint32\_t a\_line\_num}}
\label{mem_malloc}
\index{mem_malloc@\cfunc{mem\_malloc}{}}
\citem{\cfunc[void *]{mem\_malloc}{cw\_mem\_t *a\_mem, size\_t a\_size}}
\label{_cw_malloc}
\index{_cw_malloc@\cppmacro{\_cw\_malloc}{}}
\citem{\cppmacro[void *]{\_cw\_malloc}{size\_t a\_size}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to a \classname{mem}.
		\item[a\_size: ]
			Size of memory range to allocate.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a memory range.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		\cfunc{malloc}{} wrapper.
	\end{capilist}
\label{mem_calloc_e}
\index{mem_calloc_e@\cfunc{mem\_calloc\_e}{}}
\citem{\cfunc[void *]{mem\_calloc\_e}{cw\_mem\_t *a\_mem, size\_t a\_number,
size\_t a\_size, const char *a\_filename, cw\_uint32\_t a\_line\_num}}
\label{mem_calloc}
\index{mem_calloc@\cfunc{mem\_calloc}{}}
\citem{\cfunc[void *]{mem\_calloc}{cw\_mem\_t *a\_mem, size\_t a\_number,
size\_t a\_size}}
\label{_cw_calloc}
\index{_cw_calloc@\cppmacro{\_cw\_calloc}{}}
\citem{\cppmacro[void *]{\_cw\_calloc}{size\_t a\_number, size\_t a\_size}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to a \classname{mem}.
		\item[a\_number: ]
			Number of elements to allocate.
		\item[a\_size: ]
			Size of each element to allocate.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a zeroed memory range.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		\cfunc{calloc}{} wrapper.
	\end{capilist}
\label{mem_realloc_e}
\index{mem_realloc_e@\cfunc{mem\_realloc\_e}{}}
\citem{\cfunc[void *]{mem\_realloc\_e}{cw\_mem\_t *a\_mem, void *a\_ptr, size\_t
a\_size, const char *a\_filename, cw\_uint32\_t a\_line\_num}}
\label{mem_realloc}
\index{mem_realloc@\cfunc{mem\_realloc}{}}
\citem{\cfunc[void *]{mem\_realloc}{cw\_mem\_t *a\_mem, void *a\_ptr, size\_t
a\_size}}
\label{_cw_realloc}
\index{_cw_realloc@\cppmacro{\_cw\_realloc}{}}
\citem{\cppmacro[void *]{\_cw\_realloc}{void *a\_ptr, size\_t a\_size}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to a \classname{mem}.
		\item[a\_ptr: ]
			Pointer to memory range to be reallocated.
		\item[a\_size: ]
			Size of memory range to allocate.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a memory range.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		\cfunc{realloc}{} wrapper.
	\end{capilist}
\label{mem_free_e}
\index{mem_free_e@\cfunc{mem\_free\_e}{}}
\citem{\cfunc[void]{mem\_free\_e}{cw\_mem\_t *a\_mem, void *a\_ptr, const char
*a\_filename, cw\_uint32\_t a\_line\_num}}
\label{mem_free}
\index{mem_free@\cfunc{mem\_free}{}}
\citem{\cfunc[void]{mem\_free}{cw\_mem\_t *a\_mem, void *a\_ptr}}
\label{_cw_free}
\index{_cw_free@\cppmacro{\_cw\_free}{}}
\citem{\cppmacro[void]{\_cw\_free}{void *a\_ptr}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mem: ]
			Pointer to a \classname{mem}.
		\item[a\_ptr: ]
			Pointer to to memory range to be freed.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		\cfunc{free}{} wrapper.
	\end{capilist}
\end{capi}

%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% nxa portion of Onyx Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{nxa}
\label{nxa}
\index{nxa@\classname{nxa}{}}

The \classname{nxa} class implements garbage collection.  The garbage collector
runs a separate thread that is controlled via an asynchronous message queue.
The collector thread is only responsible for doing asynchronous collection due
to allocation inactivity and all sweeping; all other marking is synchronously
done in the thread context of the mutator that triggers collection.

\subsubsection{API}
\begin{capi}
\label{nxa_new}
\index{nxa_new@\cfunc{nxa\_new}{}}
\citem{\cfunc[void]{nxa\_new}{cw\_nxa\_t *a\_nxa, cw\_nx\_t *a\_nx}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_nx: ]
			Pointer to a \classname{nx}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{capilist}
\label{nxa_delete}
\index{nxa_delete@\cfunc{nxa\_delete}{}}
\citem{\cfunc[void]{nxa\_delete}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.
	\end{capilist}
\label{nxa_malloc_e}
\index{nxa_malloc_e@\cfunc{nxa\_malloc\_e}{}}
\citem{\cfunc[void *]{nxa\_malloc\_e}{cw\_nxa\_t *a\_nxa, size\_t a\_size, const
char *a\_filename, cw\_uint32\_t a\_line\_num}}
\label{nxa_malloc}
\index{nxa_malloc@\cfunc{nxa\_malloc}{}}
\citem{\cfunc[void *]{nxa\_malloc}{cw\_nxa\_t *a\_nxa, size\_t a\_size}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_size: ]
			Size of memory range to allocate.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a memory range.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		\cfunc{malloc}{} wrapper.
	\end{capilist}
\label{nxa_free_e}
\index{nxa_free_e@\cfunc{nxa\_free\_e}{}}
\citem{\cfunc[void *]{nxa\_free\_e}{cw\_nxa\_t *a\_nxa, void *a\_ptr, const
char *a\_filename, cw\_uint32\_t a\_line\_num}}
\label{nxa_free}
\index{nxa_free@\cfunc{nxa\_free}{}}
\citem{\cfunc[void *]{nxa\_free}{cw\_nxa\_t *a\_nxa, void *a\_ptr}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_ptr: ]
			Pointer to to memory range to be freed.
		\item[a\_filename: ]
			Should be \_\_FILE\_\_.
		\item[a\_line\_num: ]
			Should be \_\_LINE\_\_.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		\cfunc{free}{} wrapper.
	\end{capilist}
\label{nxa_collect}
\index{nxa_collect@\cfunc{nxa\_collect}{}}
\citem{\cfunc[void]{nxa\_collect}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Do a synchronous garbage collection.
	\end{capilist}
\label{nxa_dump}
\index{nxa_dump@\cfunc{nxa\_dump}{}}
\citem{\cfunc[void]{nxa\_dump}{cw\_nxa\_t *a\_nxa, cw\_nxo\_t *a\_thread}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_thread: ]
			Pointer to a thread \classname{nxo}.
		\end{description}
	\item[Output(s): ]
		Output printed to \onyxop{stdout}{}.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Print the internal state of gcdict to \onyxop{stdout}{}.
	\end{capilist}
\label{nxa_active_get}
\index{nxa_active_get@\cfunc{nxa\_active\_get}{}}
\citem{\cfunc[cw\_bool\_t]{nxa\_active\_get}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[FALSE: ]
				Garbage collector deactivated.
			\item[TRUE: ]
				Garbage collector active.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return whether the garbage collector is active (runnable).
	\end{capilist}
\label{nxa_active_set}
\index{nxa_active_set@\cfunc{nxa\_active\_set}{}}
\citem{\cfunc[void]{nxa\_active\_set}{cw\_nxa\_t *a\_nxa, cw\_bool\_t
a\_active}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_active: ]
			\begin{description}\item[]
			\item[FALSE: ]
				Deactivate garbage collector.
			\item[TRUE: ]
				Activate garbage collector.
			\end{description}
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Send a message to the garbage collector to activate or
		deactivate.  The asynchronous nature of the message means that
		it is possible for the garbage collector to run after this
		function returns, even if a deactivation message has been sent.
	\end{capilist}
\label{nxa_period_get}
\index{nxa_period_get@\cfunc{nxa\_period\_get}{}}
\citem{\cfunc[cw\_nxoi\_t]{nxa\_period\_get}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Current inactivity period in seconds that the garbage
			collector waits before doing a collection.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the current inactivity period in seconds that the garbage
		collector waits before doing a collection.
	\end{capilist}
\label{nxa_period_set}
\index{nxa_period_set@\cfunc{nxa\_period\_set}{}}
\citem{\cfunc[void]{nxa\_period\_set}{cw\_nxa\_t *a\_nxa, cw\_nxoi\_t
a\_period}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_period: ]
			Inactivity period in seconds that the garbage collector
			should wait before doing a collection.  If 0, the
			garbage collector will never run due to inactivity.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the inactivity period in seconds that the garbage collector
		should wait before doing a collection.
	\end{capilist}
\label{nxa_threshold_get}
\index{nxa_threshold_get@\cfunc{nxa\_threshold\_get}{}}
\citem{\cfunc[cw\_nxoi\_t]{nxa\_threshold\_get}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Number of bytes of memory allocated since the last
			garbage collection that will trigger the garbage
			collector to run.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the number of bytes of memory allocated since the last
		garbage collection that will trigger the garbage collector to
		run.
	\end{capilist}
\label{nxa_threshold_set}
\index{nxa_threshold_set@\cfunc{nxa\_threshold\_set}{}}
\citem{\cfunc[void]{nxa\_threshold\_set}{cw\_nxa\_t *a\_nxa, cw\_nxoi\_t
a\_threshold}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[a\_threshold: ]
			The number of bytes of memory allocated since the last
			garbage collection that will trigger the garbage
			collector to run.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_ONYXX\_OOM}{_CW_ONYXX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the number of bytes of memory allocated since the last
		garbage collection that will trigger the garbage collector to
		run.
	\end{capilist}
\label{nxa_stats_get}
\index{nxa_stats_get@\cfunc{nxa\_stats\_get}{}}
\citem{\cfunc[void]{nxa\_stats\_get}{cw\_nxa\_t *a\_nxa, cw\_nxoi\_t
*r\_collections, cw\_nxoi\_t *r\_new, cw\_nxoi\_t *r\_cmark, cw\_nxoi\_t
*r\_csweep, cw\_nxoi\_t *r\_mmark, cw\_nxoi\_t *r\_msweep, cw\_nxoi\_t
*r\_smark, cw\_nxoi\_t *r\_ssweep}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\item[r\_collections: ]
			Pointer to an integer.
		\item[r\_new: ]
			Pointer to an integer.
		\item[r\_cmark: ]
			Pointer to an integer.
		\item[r\_csweep: ]
			Pointer to an integer.
		\item[r\_mmark: ]
			Pointer to an integer.
		\item[r\_msweep: ]
			Pointer to an integer.
		\item[r\_smark: ]
			Pointer to an integer.
		\item[r\_ssweep: ]
			Pointer to an integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[*r\_collections: ]
			The number of times the garbage collector has run.
		\item[*r\_new: ]
			The number of bytes of memory allocated since the last
			garbage collection.
		\item[*r\_cmark: ]
			Number of microseconds spent in the mark phase of the
			most recent garbage collection.
		\item[*r\_csweep: ]
			Number of microseconts spent in the sweep phase of the
			most recent garbage collection.
		\item[*r\_mmark: ]
			Largest number of microseconds ever spent in the mark
			phase of a garbage collection.
		\item[*r\_msweep: ]
			Largest number of microseconts spent in the sweep phase
			of a garbage collection.
		\item[*r\_smark: ]
			Total number of microseconds spent in the mark phase of
			all garbage collections.
		\item[*r\_ssweep: ]
			Total number of microseconts spent in the sweep phase of
			all garbage collections.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return garbage collector statistics.
	\end{capilist}
\label{nxa_gcdict_get}
\index{nxa_gcdict_get@\cfunc{nxa\_gcdict\_get}{}}
\citem{\cfunc[cw\_nxo\_t *]{nxa\_gcdict\_get}{cw\_nxa\_t *a\_nxa}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_nxa: ]
			Pointer to a \classname{nxa}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a dict \classname{nxo}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return a pointer to the dict \classname{nxo} corresponding to
		\onyxop{gcdict}{}.
	\end{capilist}
\end{capi}

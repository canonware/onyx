%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx tutorial portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Tutorial}
\label{onyxtut}

This manual includes a comprehensive \htmlref{Onyx Language Reference}{onyxlang}
chapter, which explains the details of what Onyx is.  However, that chapter is
rather dry, and more importantly, it does not discuss how to best utilize Onyx.
This chapter introduces concepts that are important when designing and
implementing Onyx programs.  Onyx is a stack-based language, so although the
ideas that are important to program design in other more traditional languages
still apply in many cases, there are different ways of approaching certain
problems that integrate better with the facilities provided by Onyx.

The most obvious example of this is that Onyx programs are more efficient if
written to use named variables as little as possible, relying instead on the
power of the operand stack.  Another example is error handling.  It is possible
to write procedures that check for every error condition, but Onyx provides a
form of exception handling that, if used correctly, can significantly improve
code readability and performance.

Accomplished PostScript programmers will find almost nothing new in this
chapter; Onyx differs from PostScript in the details, but the concepts are very
similar.  Accomplished Forth programmers will already be comfortable with stack
management, but the rest of the chapter discusses concepts that either have no
Forth equivalent, or that are significantly different from Forth, as is the case
for dictionaries.

\section{Syntax}

Onyx syntax is extremely simple.  Code is essentially composed of tokens that
are delimited by whitespace or a list of self-delimiting tokens (see
Section~\ref{sec:onyx_syntax} for details).  As such, there are very few ways
for a syntax error to occur, but typographical mistakes may instead produce
other errors.  For example, say that a C programmer forgets he is writing Onyx
code and types the following at the interactive \binname{onyx} prompt:

\begin{verbatim}
onyx:0> 1000L {`Hello\n' print} repeat
\end{verbatim}

The intention is to print {\tt Hello} 1000 times, but {\tt 1000L} is invalid
syntax for an integer, so Onyx creates an executable name object instead, and
then tries to execute the name, resulting in the following error:

\begin{verbatim}
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      1000L
1:      -file-
2:      --start--
\end{verbatim}

This is typical of the simple errors encountered when writing Onyx code.  The
Onyx scanner uses a simple state machine to try to create objects of various
types, and when it fails, the input is instead used to create an executable
name.

The scanner only deals with a few types (ignoring procedures for the moment):
integers, reals, names, and strings.  There are many other object types, but
none of them are created directly by the scanner.

\{ and \} are used to delimit procedure bodies, which in actuality are
executable arrays.  \{ puts the scanner into deferred execution mode until the
matching \} is scanned.  \{\} pairs can be nested, so execution is deferred
until matching \} characters have been scanned for all \{ characters.  Deferred
execution means that the scanner creates objects as it scans code, but does not
execute any of them.  While not a strictly necessary language feature, this
greatly simplifies the task of constructing executable arrays, which can then be
treated as procedures.

Following are equivalent examples of how a procedure associated with the name
{\tt double} can be defined:

\begin{verbatim}
onyx:0> /double {2 mul} def
onyx:0> /double [ 2 /mul load ] cvx def
\end{verbatim}

As mentioned earlier, there are few ways of generating a syntax error, but it is
possible.  The most common syntax errors are due to unmatched ' and \}
characters.  Generating other syntax errors is left as an exercise for the
reader.

\section{Data types}

Onyx includes a rich set of data types.  In fact, Onyx code is represented as
data, which means that there is a whole range of possibilities when writing Onyx
programs that are difficult or impossible with compiled languages such as C.
This aspect of Onyx is discussed in Section\~ref{onyxtut:introspection}.

Onyx is dynamically typed, which means that errors due to object type
incompatibilities are detected during program execution.

Not extensible.

\section{Execution}

Onyx code is never compiled, nor is it preprocessed by the interpreter.  Onyx
code is simply consumed.  This has some interesting implications, some of which
are not typical of even other interpreted languages:

\begin{itemize}
\item{If a source file is modified during interpreter execution, the changes may
affect the currently running program, usually in unpleasant ways.}
\item{Syntax errors are not discovered until the malformed code is scanned.  In
order to be sure that there are no syntax errors, a source file must be
completely scanned.}
\end{itemize}

In practice, these are only minor inconveniences, but it is important to keep
them in mind when developing.

\section{Memory management}

Since Onyx includes an automatic mark and sweep garbage collector, memory
management typically requires little thought.  There is no risk of leaking
memory in such a way that it cannot be freed.  However, it is possible to
consume large amounts of memory by creating objects, then keeping references to
them long after they have outlived their usefulness.

Onyx objects fall into two categories according to type: simple and composite.
Simple objects take up no virtual memory of their own; they are embedded into
other composite objects.  For example, an integer on the operand stack takes up
only the space that the stack requires to store it.  The same is true of an
integer that is stored an an element of an array.  Composite objects are
composed of references that fit into the same places that an integer is stored,
plus additional structures stored elsewhere in virtual memory.  There can be
multiple references to the same composite object, and as there is a chain of
references that makes it possible to reach a composite object, the garbage
collector will leave it alone.

It is usually pretty obvious how to remove references to objects.  Objects on
the operand stack can be popped off.  Definitions in the dictionary stack can be
undefined.  However, there may be situations such an array that contains
references to various objects, and the array cannot be discarded as a whole, but
individual elements are no longer needed.  The null type is useful for
clobbering such references, and can even be effectively used to clobber portions
of procedures, since when a null object is executed it does absolutely nothing.
This unique aspect of null objects may not seem significant, but consider that
all other objects, when executed, are either pushed onto the execution stack and
executed, or pushed onto the operand stack.  Doing nothing at all can be useful.

\section{Stacks}

Stacks in Onyx are pretty typical.  Objects are implicitly or explicitly pushed
onto stacks by operators, and the stack contents can be rearranged and removed.
Although stacks are a first class object in Onyx, most Onyx programs are
concerned only with the operand stack, often referred to as ostack, which is
used as a place to store objects, pass arguments into operators and procedures,
and return results.

Onyx is a postfix language, which means that code is written such that operands
precede operators.  For example, the following code Calculates $5 x (3 + 4)$ and
prints the result:

\begin{verbatim}
onyx:0> 5 3 4 add mul
onyx:1> 1 sprint
35
onyx:0>
\end{verbatim}

There are no parentheses to clarify operator precedence, because precedence is
implicit in the code.

Stacks are either written bottom to top on one line, or top to bottom on
separate lines, as in the following examples.  The example stack contains the
numbers 0, 1, and 2, where 0 is the top object and 2 is the bottom object:

\begin{verbatim}
onyx:0> 2 1 0
onyx:3> ostack 1 sprint
(2 1 0)
onyx:3> pstack
0
1
2
onyx:3>
\end{verbatim}

Learning to efficiently (and accurately) manage stacks is a mind-warping process
that no amount of reading is likely to impress upon the reader.  There are
general concepts presented here, but ultimately, the reader will have to write a
good bit of code to get a handle on stacks.  Even the author of Onyx found
himself stumbling over stacks well after Onyx was complete, despite limited
exposure to stack-based languages beforehand.  The problem seems to be that
programmers learn to think in a different way that doesn't exercise the parts of
the brain necessary for stack manipulation.  Some people might argue that stack
manipulation is the job of the compiler.  In any case, stack manipulation is an
acquired skill that requires practice.

\subsection{Using stacks as queues}

Stacks are implemented such that access to the top or bottom is very efficient,
and efficiency decreases linearly, the farther into the stack an operation has
to iterate.  Since pushing and popping is efficient for both ends of stacks,
this means that stacks are suitable for use as queues.

\subsection{Efficiency issues}

Since stacks are stored internally as a doubly linked list, the cost of indexed
access to an object on a stack is proportional to its offset from the top or
bottom of the stack, depending on the operator being used.  Therefore, stacks
are not ideal in situations where arbitrary access to an object is a common
operation.  An array is a better choice for indexed access, and a dictionary is
a better choice for keyed access.

Indexed access doesn't just apply to operators like
\htmlref{\onyxop{}{idup}{}}{systemdict:idup}; operators like
\htmlref{\onyxop{}{nup}{}}{systemdict:nup} and
\htmlref{\onyxop{}{roll}{}}{systemdict:roll} are also affected.  However,
operators such as \htmlref{\onyxop{}{rot}{}}{systemdict:rot} are not as heavily
impacted, since they only need to index into the stack by the number of
positions to rotate.

\section{Dictionaries}

Dictionaries are known by various other names, including hashes and associative
arrays.  Dictionaries in Onyx associate keys with values.  Keys and values can
be of any type, but for each dictionary, all keys are unique.  For example, the
following dictionary cannot exist:

\begin{verbatim}
<
    42 `Some value'
    42 `Another value'
>
\end{verbatim}

To demonstrate this, the following example creates a dictionary with the first
key/value pair listed above, then inserts the second key/value pair.

\begin{verbatim}
onyx:0> <42 `Some value'>
onyx:1> dup 1 sprint
<42 `Some value'>
onyx:1> dup 42 `Another value' put
onyx:1> dup 1 sprint
<42 `Another value'>
onyx:1>
\end{verbatim}

When the second key/value pair is inserted, it replaces the first pair.

\subsection{Efficiency issues}

Although dictionaries can handle keys of any type, they are optimized to use
names as keys.  The performance penalty for other key types is slight, but can
be exacerbated by the cost of comparison for other types.  Names comparison is a
constant time operation, but string comparison is not.  Therefore, use names
rather than strings whenever possible.

\section{Code organization}
XXX
\subsection{Procedures}
XXX
\subsection{Namespaces}
XXX

\section{Error handling}
XXX

\section{Introspection}
\label{onyxtut:introspection}

The following code defines a named procedure that calculates factorials.

\begin{verbatim}
# #n factorial #result
/factorial {
    dup 1 gt {
        # #n-1 factorial
        dup 1 sub factorial
    }{
        # Terminate recursion.
        1
    } ifelse

    mul
} def
\end{verbatim}

What this code actually does is create an executable array, which can be
examined and modified.  The following transcript shows the effects of modifying
the code.

\begin{verbatim}
onyx:0> 3 factorial 1 sprint
6
onyx:0> /factorial load 2 sprint
{dup 1 gt {dup 1 sub factorial} {1} ifelse mul}
onyx:0> /factorial load 4 {1 pstack} put
onyx:0> 3 factorial 
1
1
2
3
onyx:1> 1 sprint
6
onyx:0>
\end{verbatim}

First 3 factorial is calculated.  Then the ``else'' clause of the ifelse
construct is modified to print the stack and 3 factorial is recalculated.  As
can be seen, the stack is printed during the calculation.

\section{Threads}
XXX

\section{Optimization}
XXX

\section{Debugging}
XXX

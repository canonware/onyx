%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx tutorial portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Tutorial}
\label{onyxtut}

This manual includes a comprehensive \htmlref{Onyx Language Reference}{onyxlang}
chapter, which explains the details of what Onyx is.  However, that chapter is
rather dry, and more importantly, it does not discuss how to best utilize Onyx.
This chapter introduces concepts that are important when designing and
implementing Onyx programs, though it is not a complete language tutorial.  You
will need to read the first several sections of Chapter~\ref{onyxlang} in order
to absorb all of the information in this chapter.  However, you should be able
to read this chapter first, then come back to it and glean additional
understanding after having read later chapters.

Onyx is a stack-based language, so although the ideas that are important to
program design in other more traditional languages still apply in many cases,
there are different ways of approaching certain problems that integrate better
with the facilities provided by Onyx.  The most obvious example of this is that
Onyx programs are more efficient if written to use named variables as little as
possible, relying instead on the power of the operand stack.  Another example is
error handling.  It is possible to write procedures that check for every error
condition, but Onyx provides a form of exception handling that, if used
correctly, can significantly improve code readability and performance.

Accomplished PostScript programmers will find little new in this chapter; Onyx
differs from PostScript in the details, but the concepts are very similar.
Accomplished Forth programmers will already be comfortable with stack
management, but the rest of the chapter discusses concepts that either have no
Forth equivalent, or that are significantly different from Forth, as is the case
for dictionaries.

\section{Syntax}

Onyx syntax is extremely simple.  Code is essentially composed of tokens that
are delimited by whitespace or a list of self-delimiting tokens (see
Section~\ref{sec:onyx_syntax} for details).  As such, there are very few ways
for a syntax error to occur, but typographical mistakes may instead produce
other errors.  For example, say that a C programmer forgets he is writing Onyx
code and types the following at the interactive \binname{onyx} prompt:

\begin{verbatim}
onyx:0> 1000L {`Hello\n' print} repeat
\end{verbatim}

The intention is to print {\tt Hello} 1000 times, but {\tt 1000L} is invalid
syntax for an integer, so Onyx creates an executable name object instead, and
then tries to execute the name, resulting in the following error:

\begin{verbatim}
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      1000L
1:      -file-
2:      --start--
\end{verbatim}

This is typical of the simple errors encountered when writing Onyx code.  The
Onyx scanner uses a simple state machine to try to create objects of various
types, and when it fails, the input is instead used to create an executable
name.

The scanner only deals with a few types (ignoring procedures for the moment):
integers, reals, names, and strings.  There are many other object types, but
none of them are created directly by the scanner.

\{ and \} are used to delimit procedure bodies, which in actuality are
executable arrays.  \{ puts the scanner into deferred execution mode until the
matching \} is scanned.  \{\} pairs can be nested, so execution is deferred
until matching \} characters have been scanned for all \{ characters.  Deferred
execution means that the scanner creates objects as it scans code, but does not
execute any of them.  While not a strictly necessary language feature, this
greatly simplifies the task of constructing executable arrays, which can then be
treated as procedures.

Following are equivalent examples of how a procedure associated with the name
{\tt double} can be defined:

\begin{verbatim}
onyx:0> $double {2 mul} def
onyx:0> $double [ 2 $mul load ] cvx def
\end{verbatim}

As mentioned earlier, there are few ways of generating a syntax error, but it is
possible.  The most common syntax errors are due to unmatched ' and \}
characters.  Generating other syntax errors is left as an exercise for the
reader.

\section{Data types}

Onyx includes a rich set of data types.  In fact, Onyx code is represented as
data, which means that there is a whole range of possibilities when writing Onyx
programs that are difficult or impossible with compiled languages such as C.
This aspect of Onyx is discussed in Section~\ref{onyxtut:introspection}.

Onyx is dynamically typed, which means that errors due to object type
incompatibilities are detected during program execution.  For example, the
following code will always run without an error, even though the arguments that
would be passed to the \htmlref{\onyxop{}{add}{}}{systemdict:add} operator are
invalid.

\begin{verbatim}
false {
    `a string' [1] add
}{
    `This is always printed' 1 sprint
} ifelse
\end{verbatim}

Dynamic typing has advantages in the flexibility that it offers, but it also
means that type errors can go undetected in code for long periods of time before
the invalid code is executed.

The Onyx type system is not extensible.  There is no way to add new types in a
program.  However, there are techniques that can be combined with the built in
types to simulate an extensible type system.  For example, dictionaries can be
created with, say, a {\tt \_type} field that indicates the type of the object:

\begin{verbatim}
<
    $_type  $fraction
    $num    3
    $den    4
>
\end{verbatim}

Logical extensions of this can be used to create object hierarchies with single
or multiple inheritance.

\section{Execution}

Onyx code is never compiled, nor is it preprocessed by the interpreter.  Onyx
code is simply consumed.  This has some interesting implications, some of which
are not typical of even other interpreted languages:

\begin{itemize}
\item{If a source file is modified during interpreter execution, the changes may
affect the currently running program, usually in unpleasant ways.}
\item{Syntax errors are not discovered until the malformed code is scanned.  In
order to be sure that there are no syntax errors, a source file must be
completely scanned.}
\end{itemize}

In practice, these are only minor inconveniences, but it is important to keep
them in mind when developing.

\section{Memory management}

Since Onyx includes an automatic mark and sweep garbage collector, memory
management typically requires little thought.  There is no risk of leaking
memory in such a way that it cannot be freed.  However, it is possible to
consume large amounts of memory by creating objects, then keeping references to
them long after they have outlived their usefulness.

Onyx objects fall into two categories according to type: simple and composite.
Simple objects take up no virtual memory of their own; they are embedded into
other composite objects.  For example, an integer on the operand stack takes up
only the space that the stack requires to store it.  The same is true of an
integer that is stored an an element of an array.  Composite objects are
composed of references that fit into the same places that an integer is stored,
plus additional structures stored elsewhere in virtual memory.  There can be
multiple references to the same composite object, and as there is a chain of
references that makes it possible to reach a composite object, the garbage
collector will leave it alone.

It is usually pretty obvious how to remove references to objects.  Objects on
the operand stack can be popped off.  Definitions in the dictionary stack can be
undefined.  However, there may be situations such an array that contains
references to various objects, and the array cannot be discarded as a whole, but
individual elements are no longer needed.  The null type is useful for
clobbering such references, and can even be effectively used to clobber portions
of procedures, since when a null object is executed it does absolutely nothing.
This unique aspect of null objects may not seem significant, but consider that
all other objects, when executed, are either pushed onto the execution stack and
executed, or pushed onto the operand stack.  Doing nothing at all can be useful.

\section{Stacks}

Stacks in Onyx are pretty typical.  Objects are implicitly or explicitly pushed
onto stacks by operators, and the stack contents can be rearranged and removed.
Although stacks are a first class object in Onyx, most Onyx programs are
concerned only with the operand stack, often referred to as ostack, which is
used as a place to store objects, pass arguments into operators and procedures,
and return results.

Onyx is a postfix language, which means that code is written such that operands
precede operators.  For example, the following code Calculates $5 \times (3 +
4)$ and prints the result:

\begin{verbatim}
onyx:0> 5 3 4 add mul
onyx:1> 1 sprint
35
onyx:0>
\end{verbatim}

There are no parentheses to clarify operator precedence, because precedence is
implicit in the code.

Stacks are either written bottom to top on one line, or top to bottom on
separate lines, as in the following examples.  The example stack contains the
numbers 0, 1, and 2, where 0 is the top object and 2 is the bottom object:

\begin{verbatim}
onyx:0> 2 1 0
onyx:3> ostack 1 sprint
(2 1 0)
onyx:3> pstack
0
1
2
onyx:3>
\end{verbatim}

Learning to efficiently (and accurately) manage stacks is a mind-warping process
that no amount of reading is likely to impress upon the reader.  There are
general concepts presented here, but ultimately, the reader will have to write a
good bit of code to get a handle on stacks.  Even the author of Onyx found
himself stumbling over stacks well after Onyx was complete, despite limited
exposure to stack-based languages beforehand.  The problem seems to be that
programmers learn to think in a different way that doesn't exercise the parts of
the brain necessary for stack manipulation.  Some people might argue that stack
manipulation is the job of the compiler.  In any case, stack manipulation is an
acquired skill that requires practice.

\subsection{Using stacks as queues}

Stacks are implemented such that access to the top or bottom is very efficient,
and efficiency decreases linearly, the farther into the stack an operation has
to iterate.  Since pushing and popping is efficient for both ends of stacks,
this means that stacks are suitable for use as queues.

\subsection{Efficiency issues}

Since stacks are stored internally as doubly linked lists, the cost of indexed
access to an object on a stack is proportional to its offset from the top or
bottom of the stack, depending on the operator being used.  Therefore, stacks
are not ideal in situations where arbitrary access to an object is a common
operation.  An array is a better choice for indexed access, and a dictionary is
a better choice for keyed access.

Indexed access doesn't just apply to operators like
\htmlref{\onyxop{}{idup}{}}{systemdict:idup}; operators like
\htmlref{\onyxop{}{nup}{}}{systemdict:nup} and
\htmlref{\onyxop{}{roll}{}}{systemdict:roll} are also affected.  However,
operators such as \htmlref{\onyxop{}{rot}{}}{systemdict:rot} are not as heavily
impacted, since they only need to index into the stack by the number of
positions to rotate.

\section{Dictionaries}

Dictionaries are known by various other names, including hashes and associative
arrays.  Dictionaries in Onyx associate keys with values.  Keys and values can
be of any type, but for each dictionary, all keys are unique.  For example, the
following dictionary cannot exist:

\begin{verbatim}
<
    42 `Some value'
    42 `Another value'
>
\end{verbatim}

To demonstrate this, the following example creates a dictionary with the first
key/value pair listed above, then inserts the second key/value pair.

\begin{verbatim}
onyx:0> <42 `Some value'>
onyx:1> dup 1 sprint
<42 `Some value'>
onyx:1> dup 42 `Another value' put
onyx:1> dup 1 sprint
<42 `Another value'>
onyx:1>
\end{verbatim}

When the second key/value pair is inserted, it replaces the first pair.

\subsection{Efficiency issues}

Although dictionaries can handle keys of any type, they are optimized to use
names as keys.  The performance penalty for other key types is slight, but can
be exacerbated by the cost of comparison for other types.  Name comparison is a
constant time operation, but string comparison is not.  Therefore, use names
rather than strings whenever possible.

\section{Code organization}

As mentioned earlier, Onyx does not have named variables in the same way as many
other languages.  However, it does have the dictionary stack (dstack), which is
dynamically used for name lookups whenever an executable name is interpreted.
This section talks about how to effectively manage the namespace provided by
dstack.

When the Onyx interpreter is first initialized, there are four dictionaries on
dstack:

\begin{itemize}
\item{userdict}
\item{globaldict}
\item{systemdict}
\item{threaddict}
\end{itemize}

dstack can be manipulated any way the application sees fit, though it is
generally dangerous to remove or significantly modify systemdict or threaddict,
since there are definitions in those dictionaries that are critical to the
correct functioning of the interpreter.

Each thread has its own userdict, which provides a thread-local namespace.
globaldict is shared among all threads, so it provides a global namespace.
systemdict contains all of the default global definitions, and threaddict
contains the default thread-local definitions.

For some applications, it may be desirable to add definitions to systemdict, but
care should be taken not to overwrite existing definitions unless you really
know what you are doing.  In most cases, using globaldict is a better way to
go.

\subsection{Procedures}

Named procedures can be created by associating a name in one of the dictionaries
on dstack with a procedure.  There is nothing magical about this, but some care
should be taken in choosing procedure names, and in deciding how to manage the
namespace.  Onyx uses only lower case letters in the names of its definitions on
dstack, so it is easy to avoid namespace collisions by using some other
character in program definitions.  There is nothing wrong with using all
lowercase letters for names in your programs, though some extra care is
warranted when doing so.

An important consideration in program design is determining what belongs in the
global namespace.  For an example of how Onyx partitions its namespace, look at
gcdict.  There are several operators defined in gcdict that are only of interest
when manipulating the garbage collector, so those definitions are stashed out of
the way.  Your program can do the same for definitions that are not of regular
interest.

\subsection{Modules}
Onyx provides the infrastructure for loadable modules, which can be implemented
in Onyx and/or dynamically loaded machine code (shared libraries).  See the
\htmlref{\onyxop{}{require}{}}{systemdict:require} and
\htmlref{\onyxop{}{mrequire}{}}{systemdict:mrequire} documentation for details
on how to load modules.

When writing a module that is meant as a library of additional functionality,
some choices have to be made about how to organize the module.  Some of the
obvious choices for how to organize the loaded definitions are:

\begin{itemize}
\item{Insert definitions into globaldict.}
\item{Create a new dictionary full of definitions, and insert the dictionary
  into globaldict as, say, foodict.}
\item{Create a new dictionary full of definitions, and put the dictionary on
  dstack somewhere, such as directly above or below systemdict.  Note that this
  can be done by the application manually, so simply creating the dictionary and
  letting the application insert it where it pleases could be a better choice.}
\item{Insert definitions into systemdict (questionable practice).}
\end{itemize}

Depending on the nature of the module, any of the above solutions may be the
right choice.  There are tradeoffs between convenience and cleanliness that
should be carefully weighed.

\section{Error handling}
Onyx includes a powerful generic error handling mechanism that can be extended
and customized at several levels.  The
\htmlref{\onyxop{}{throw}{}}{systemdict:throw} procedure is used to throw an
error, and virtually every aspect of the error handling machinery can be
customized, extended, or replaced, since it is all written in Onyx.

Errors have names, with which error handlers can be associated in errordict.
There is a default set of error names, for which default error handlers are
provided in errordict.  New error names can be added, and the default error
handlers can be replaced.  errordict's
\htmlref{\onyxop{}{handleerror}{}}{systemdict:handleerror} procedure can be
modified or replaced.  In fact, with some care, an entirely custom errordict can
be defined, then undefined once it is no longer needed.

Following is the standard idiom for setting up and tearing down custom error
handling:

\begin{verbatim}
# Set up custom error handling...
{
    # Do error-prone stuff...
} stopped {
    # An error occurred.  Do additional cleanup...
} if
# Restore error handling machinery...
\end{verbatim}

The possibilities are extensive.  However, a word of caution is in order.  If
you mess something up in the error handling machinery, bad things will happen,
and you will have a terrible time debugging the problem.  Be careful.

\section{Introspection}
\label{onyxtut:introspection}

The following code defines a named procedure that calculates factorials.

\begin{verbatim}
# #n factorial #result
$factorial {
    dup 1 gt {
        # #n-1 factorial
        dup 1 sub factorial
    }{
        # Terminate recursion.
        1
    } ifelse

    mul
} def
\end{verbatim}

What this code actually does is create an executable array, which can be
examined and modified.  The following transcript shows the effects of modifying
the code.

\begin{verbatim}
onyx:0> 3 factorial 1 sprint
6
onyx:0> $factorial load 2 sprint
{dup 1 gt {dup 1 sub factorial} {1} ifelse mul}
onyx:0> $factorial load 4 {1 pstack} put
onyx:0> 3 factorial 
1
1
2
3
onyx:1> 1 sprint
6
onyx:0>
\end{verbatim}

First $3!$ is calculated.  Then the ``else'' clause of the ifelse construct is
modified to print the stack and $3!$ is recalculated.  As can be seen, the stack
is printed during the calculation.

\section{Threads}

The original impetus for Onyx's creation was the need for scalable threading.
Onyx's threading is therefore truly powerful, though it comes at a cost.
Threading makes asynchronous garbage collection a necessity, which in turn makes
many aspects of Onyx's implementation a bit more heavyweight than would be
necessary for a single-threaded interpreter.

\subsection{Implicit synchronization}

Of more importance to the Onyx user is the fact that Onyx has the concept of
implicit object synchronization.  To see why implicit object synchronization is
necessary, consider what happens when two threads concurrently modify globaldict
(a perfectly legitimate thing to do, by the way).  The internals of a dictionary
are rather complex, and if two modifications were interleaved, havoc would
ensue.  Therefore, globaldict is implicitly locked.  That is a good thing,
except that it slows down every access to globaldict.  In contrast, userdict is
a per-thread dictionary, so it is not implicitly locked.

Implicit locking for new objects is controlled via
\htmlref{\onyxop{}{setlocking}{}}{systemdict:setlocking}, and can be queried via
\htmlref{\onyxop{}{currentlocking}{}}{systemdict:currentlocking}.  Implicit
locking is turned off by default when Onyx is started up, so if an application
needs to create an object that is shared among threads, it should temporarily
turn on implicit locking.  For example, the following code creates a stack in
globaldict that can be used as a simple message queue.

\begin{verbatim}
currentlocking # Save for later restoration.
true currentlocking

# Push globaldict onto dstack before calling def.
globaldict begin
$queue stack def
end # globaldict

# Restore implicit locking mode.
setlocking
\end{verbatim}

For additional details on the mechanics of implicit synchronization, see
Section~\ref{sec:onyx_implicit_synchronization}.

\subsection{General threading concerns}

Onyx's basic threading mechanisms are typical of those found in modern threading
implementations.  One of the aspects of Onyx's threading implementation to be
aware of is that since the operating system's threading implementation is used,
there are many types of programming errors that can cause undefined behavior.
With some effort, it is possible to crash the Onyx interpreter without the use
of threads.  However, it requires skill and discipline to {\em not} crash the
Onyx interpreter when using threads.  This was a conscious design decision for
Onyx; doing otherwise would have limited the scalability of threading.

Now prepare for some discouraging pontification on why threaded programming is
generally harmful.  In the author's experience, the vast majority of developers
do not have a solid enough grasp of threading concepts to be seriously engaging
in the practice.  As a first step to becoming proficient at threaded
programming, much reading and thought are necessary.  The next step is to
implement several non-trivial threaded programs that are doomed to be complete
disasters.  After that, it may be possible for a programmer to write threaded
programs that do the right thing most of the time.  However, even the most
skilled developers still will be unable to consistently write code that is free
of race conditions, deadlocks, livelocks, locksteps, etc.  Finally, there are
some developers who, despite being otherwise proficient, will {\em never} obtain
a solid grasp of threaded programming, regardless of how many times the basic
concepts are reviewed.

In summary, don't use threads unless there are significant measurable gains in
performance or code complexity.  Otherwise, threaded programming just is not
worth the unavoidable pain that it inflicts.

\section{Optimization}

There are many fine points to optimizing Onyx code, but they can primarily be
distilled down to the following simple rules:

\begin{itemize}
\item{Avoid allocating composite objects, in order to reduce pressure on the
  garbage collector.  This means being very careful about string manipulation in
  the fast path.  The \htmlref{\onyxop{}{cat}{}}{systemdict:cat} operator is
  convenient, but not friendly to the garbage collector.}
\item{Write code with as few objects as possible, to reduce the number of times
  through the interpreter loop.  This means getting very familiar with the stack
  manipulation operators.}
\item{Use the operand stack rather than named variables.}
\item{Use the \htmlref{\onyxop{}{bind}{}}{systemdict:bind} operator for
  procedure definitions whenever possible, in order to reduce dstack lookups.}
\item{Avoid the \htmlref{\onyxop{}{exit}{}}{systemdict:exit},
  \htmlref{\onyxop{}{stop}{}}{systemdict:stop}, and
  \htmlref{\onyxop{}{quit}{}}{systemdict:quit} operators when possible, since
  they are implemented via \cfunc{longjmp}{}.}
\end{itemize}

\section{Debugging}

Onyx does not have an integrated interactive debugger per se, because the
introspective power of Onyx is adequate for almost all debugging purposes.  In
cases where it is impractical to interactively debug an application via the main
thread, it is possible to launch a thread that listens for connections on a
socket (or a fifo pair) and provides an interactive session.

Following is a contrived example of debugging some bad code, interleaved with
explanations.  The intention is to calculate $1 + 5$.

\begin{verbatim}
onyx:0> 1 5L add
Error $undefined
ostack: (1)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      5L
1:      -file-
2:      --start--
onyx:2> pstack
5L
1
\end{verbatim}

{\tt 5L} is not a number, nor is it defined in dstack.  Try replacing {\tt 5L}
with {\tt \$five}.

\begin{verbatim}
onyx:2> pop $five resume
Error $typecheck
ostack: (1 $five)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --add--
1:      -file-
2:      --start--
onyx:3> pstack
--add--
$five
1
\end{verbatim}

{\tt \$five} is a literal name, so no errors occur directly due to scanning it.
However, the \htmlref{\onyxop{}{add}{}}{systemdict:add} operator expects two
numbers, and {\tt \$five} is not a number.  Replace it with {\tt 5} and evaluate
the operator.

\begin{verbatim}
onyx:3> nip 5 exch eval
onyx:1> pstack
6
\end{verbatim}

The result is as desired.  However, we forgot to
\htmlref{\onyxop{}{resume}{}}{onyx_interactive:resume} after the last error.

\begin{verbatim}
onyx:1> estack 1 sprint
(--start-- -file- --add-- --ifelse-- --eval-- -array- -file- --estack--)
onyx:1> resume
\end{verbatim}

Now the estack contents should be back to normal.

\begin{verbatim}
onyx:1> estack 1 sprint
(--start-- -file- --estack--)
onyx:1> 
\end{verbatim}

The above example only demonstrates the flavor of typical interactive debugging,
but there is no magic involved in debugging, so your debugging ability should
improve automatically as you gain an improved understanding of Onyx.
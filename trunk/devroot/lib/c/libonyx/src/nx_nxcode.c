/* This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: <Version>
 *
 ******************************************************************************/

#ifdef _CW_USE_INLINES
_CW_INLINE void
#else
static void
#endif
nx_p_nxcode(cw_nx_t *a_nx)
{
	cw_nxo_t	thread;

	nxo_thread_new(&thread, a_nx);
	_cw_onyx_code(&thread, "{systemdict begin /sprintsdict < /arraytype {dup 0 gt {1 index xcheck {`{'} {`['} ifelse 2 index length 1 gt {0 1 4 index length 2 sub {3 index exch get 2 index 1 sub 1 index type sprintsdict exch get eval catenate ` ' catenate} for} if 2 index length 0 gt {2 index dup length 1 sub get 2 index 1 sub 1 index type sprintsdict exch get eval catenate} if exch pop exch xcheck {`}'} {`]'} ifelse catenate} {pop pop `-array-'} ifelse} bind /booleantype {pop cvs} bind /conditiontype {pop pop `-condition-'} bind /dicttype {dup 0 gt {1 sub 0 `<' 3 index {exch 4 index 1 index type sprintsdict exch get eval ` ' catenate exch 4 index 1 index type sprintsdict exch get eval catenate catenate exch 1 add dup 4 index length lt {exch ` ' catenate} {exch} ifelse} foreach 4 1 roll pop pop pop `>' catenate} {pop pop `-dict-'} ifelse} bind /filetype {pop pop `-file-'} bind /finotype {pop pop `-fino-'} bind /hooktype {exch hooktag dup type /nulltype ne {exch 1 sub 1 index type sprintsdict exch get eval `=' exch catenate `=' catenate} {pop pop `-hook-'} ifelse} bind /integertype {pop cvs} bind /marktype {pop pop `-mark-'} bind /mutextype {pop pop `-mutex-'} bind /nametype {pop dup cvs exch xcheck not {`/' exch catenate} if} bind /nulltype {pop pop `null'} bind /operatortype {pop cvs dup `-operator-' ne {`--' dup 3 1 roll catenate catenate} if} bind /pmarktype {pop pop `-pmark-'} bind /stacktype {dup 0 gt {`(' 2 index scount exch pop 1 gt {2 index scount exch pop 1 sub -1 1 {3 index exch sindex spop exch pop 2 index 1 sub 1 index type sprintsdict exch get eval catenate ` ' catenate} for} if 2 index scount exch pop 0 gt {2 index sdup spop exch pop 2 index 1 sub 1 index type sprintsdict exch get eval catenate} if 3 1 roll pop pop `)' catenate} {pop pop `-stack-'} ifelse} bind /stringtype {pop cvs} bind /threadtype {pop pop `-thread-'} bind > def /sprints {1 index type sprintsdict exch get eval} bind def /sprint {sprints print `\n' print flush} bind def /outputsdict < /integertype {dup /b known {dup /b get} {10} ifelse 2 index exch cvrs 1 index /s known {1 index /s get /+ eq {2 index 0 ge {`+' exch catenate} if} if} if 3 2 roll pop exch outputsdict /stringtype get eval} bind /_s {dup /w known {dup /p known {dup /p get} {` '} ifelse 1 index /w get 3 index length dup 2 index le {1 index string 0 1 4 index 1 sub {1 index exch 5 index putinterval} for 4 3 roll pop 3 index /j known {3 index /j get} {/r} ifelse dup /r eq {pop 3 1 roll sub} {/l eq {3 1 roll pop pop 0} {3 1 roll sub 2 div} ifelse} ifelse 1 index exch 5 4 roll putinterval exch} {pop pop pop} ifelse} {dup /n known {1 index length 1 index /n get dup 2 index lt {exch pop dup string dup 5 4 roll 4 3 roll 0 exch getinterval 0 exch putinterval exch} {pop pop} ifelse} if} ifelse pop} bind def /stringtype /_s load [ /dup cvx /r /known cvx [ /dup cvx /r /get cvx ] cvx [ 1 ] cvx /ifelse cvx 3 2 /roll cvx /exch cvx /sprints cvx /exch cvx /_s load /eval cvx ] cvx bind [ /arraytype /booleantype /conditiontype /dicttype /filetype /finotype /hooktype /marktype /mutextype /nametype /nulltype /operatortype /pmarktype /stacktype /threadtype ] {exch dup} foreach pop currentdict /_s undef > def /outputs {dup type /dicttype ne {/typecheck throw} if 1 index type outputsdict exch get eval} bind def /output {outputs print} bind def /product `Canonware Onyx' def /pstack {ostack {1 sprint} foreach flush} bind def /search {dup type /stringtype ne {/typecheck throw} if 1 index type /stringtype ne {/typecheck throw} if dup length 2 index length le {0 1 3 index length 3 index length sub {dup 3 index exch 3 index length getinterval dup length 1 sub 0 1 3 2 roll {dup 2 index exch get exch 4 index exch get ne {false exit} if} for dup type /booleantype eq {pop pop pop} {3 2 roll pop 3 1 roll dup 2 index exch 0 exch getinterval 3 1 roll 3 index length add dup 2 index length exch sub getinterval 3 1 roll true exit} ifelse} for dup type /booleantype ne {pop false} if} {pop false} ifelse} bind def /system {fork dup 0 eq {errordict begin /handleerror {quit} def end pop exec} {exch pop waitpid} ifelse} bind def /throw {{{/errordict where {pop true} {false} ifelse} {/errordict load /handleerror known} {/errordict load /stop known} {/currenterror where {pop true} {false} ifelse}} {eval not {`Onyx: Missing errordict or currenterror defs\n' print `ostack: ' print ostack 2 sprint `dstack: ' print dstack 2 sprint `estack: ' print estack 2 sprint `istack: ' print istack 2 sprint `Onyx: dieing\n' print flush 1 die} if} foreach dup type /nametype ne {/typecheck /systemdict load /throw get eval} if /currenterror load begin /newerror true def dup /errorname exch cvlit def ostack spop pop /ostack exch def /dstack dstack spop pop def estack spop pop /estack exch def istack spop pop /istack exch def /estack load sdup spop exch pop end exch /errordict load exch get eval /errordict load /stop get eval} bind def /version `<Version>' def end} eval");
	nxo_thread_exit(&thread);
}

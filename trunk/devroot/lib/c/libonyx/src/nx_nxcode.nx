%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nx_nxcode_gen.nx to produce a more compact embedded
% version in nx_nxcode.c.  Due to bootstrapping issues, this cannot safely be
% done automatically as part of the build process.  In order to make changes to
% this file take effect, either type:
%
%   cook bootstrap
%
% or
%
%   cat nx_nxcode.nx | onyx nx_nxcode_gen.nx > nx_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

systemdict begin

%
% sprintsdict implements syntactic printing to strings for every type.
%
/sprintsdict <
	/arraytype {
		% %array %depth
		dup 0 gt {
			1 index xcheck {
				`{'
			}{
				`['
			} ifelse

			% %array %depth %accum
			2 index length 1 gt {
				% %array %depth %accum
				0 1 4 index length 2 sub {
					% %array %depth %accum %i
					3 index exch get
					2 index 1 sub
					% %array %depth %accum %el %rdepth
					1 index type sprintsdict exch get eval
					catenate
					% %array %depth %accum %el %rdepth
				` ' catenate
				} for
			} if
			% %array %depth %accum

			2 index length 0 gt {
				2 index dup length 1 sub get
				2 index 1 sub
				% %array %depth %accum %el %rdepth
				1 index type sprintsdict exch get eval
				catenate
			} if
			% %array %depth %accum

			exch pop
			% %array %accum
			exch xcheck {
				`}'
			}{
				`]'
			} ifelse
			catenate
			% %accum
		}{
			pop pop
			`-array-'
		} ifelse
	}
	/booleantype {
		pop
		cvs
	}
	/conditiontype {
		pop pop
		`-condition-'
	}
	/dicttype {
		% %dict %depth
		dup 0 gt {
			% Update recursion depth.
			1 sub

			0
			`<'

			% %dict %rdepth %i %accum
			3 index {
				% %dict %rdepth %i %accum %key %value
				exch 4 index
				% %dict %rdepth %i %accum %value %key %rdepth
				1 index type sprintsdict exch get eval
				` ' catenate
				% %dict %rdepth %accum %i %value %keystr
				exch 4 index
				% %dict %rdepth %i %accum %keystr %value %rdepth
				1 index type sprintsdict exch get eval
				% %dict %rdepth %i %accum %keystr %valstr
				catenate catenate
				% %dict %rdepth %i %accum

				% Update counter.
				exch 1 add dup 4 index length lt {
					% %dict %rdepth %accum %i
					exch
					` ' catenate
					% %dict %rdepth %i %accum
				}{
					% Last element.
					exch
					% %dict %rdepth %accum
				} ifelse
			} foreach
			% %dict %rdepth %i %accum

			4 1 roll pop pop pop
			% %accum
			`>'
			catenate
			% %accum
		}{
			pop pop
			`-dict-'
		} ifelse
	}
	/filetype {
		pop pop
		`-file-'
	}
	/finotype {
		pop pop
		`-fino-'
	}
	/hooktype {
		% %hook %depth
		exch hooktag
		% %depth %tag
		dup type /nulltype ne {
			exch 1 sub
			% %tag %rdepth
			1 index type sprintsdict exch get eval
			% %tagstr
			`=' exch catenate
			`=' catenate
		}{
			pop pop
			`-hook-'
		} ifelse
	}
	/integertype {
		pop
		cvs
	}
	/marktype {
		pop pop
		`-mark-'
	}
	/mutextype {
		pop pop
		`-mutex-'
	}
	/nametype {
		pop
		dup cvs
		exch xcheck not {
			`/' exch catenate
		} if
	}
	/nulltype {
		pop pop
		`null'
	}
	/operatortype {
		pop
		cvs
		dup `-operator-' ne {
			`--' dup 3 1 roll
			catenate catenate
		} if
	}
	/pmarktype {
		pop pop
		`-pmark-'
	}
	/stacktype {
		% %stack %depth
		dup 0 gt {
			`('

			% %stack %depth %accum
			2 index scount exch pop 1 gt {
				% %stack %depth %accum
				2 index scount exch pop 1 sub -1 1 {
					% %stack %depth %accum %i
					3 index exch sindex spop exch pop
					2 index 1 sub
					% %stack %depth %accum %el %rdepth
					1 index type sprintsdict exch get eval
					catenate
					% %stack %depth %accum %el %rdepth
				` ' catenate
				} for
			} if
			% %stack %depth %accum

			2 index scount exch pop 0 gt {
				2 index sdup spop exch pop
				2 index 1 sub
				% %stack %depth %accum %el %rdepth
				1 index type sprintsdict exch get eval
				catenate
			} if
			% %stack %depth %accum

			3 1 roll pop pop
			% %accum
			`)'
			catenate
			% %accum
		}{
			pop pop
			`-stack-'
		} ifelse
	}
	/stringtype {
		pop
		cvs
	}
	/threadtype {
		pop pop
		`-thread-'
	}
> def

% <object> <depth> sprints <string>
/sprints {
	1 index type /sprintsdict load exch get eval
} def

/sprint {
	sprints print
	`\n' print flush
} def

% - product <string>
/product `Canonware Onyx' def

/pstack {
	ostack {
		1 sprint
	} foreach
	flush
} def

%
% <string> <pattern> search <post> <pattern> <pre> true
%                    search <string> false
%
/search {
	% Make sure the arguments are strings.
	% Pattern.
	dup type /stringtype ne {
		/typecheck throw
	} if
	% String.
	1 index type /stringtype ne {
		/typecheck throw
	} if

	% Make sure substring isn't longer than string.
	dup length 2 index length le {
		% Use a nested looping algorithm.  The outer loop advances the
		% offset <s_i> at which to start the search in the string <s>,
		% and the inner loop compares byte by byte with the pattern <p>.
		%
		% Take care not to cause a rangecheck error.
		0 1 3 index length 3 index length sub {
			% <s> <p> <s_i>

			% Create a substring <s_sub> of <s> that is the same
			% length as <p>, starting at <s_i>.
			dup 3 index exch 3 index length getinterval

			% <s> <p> <s_i> <s_sub>
			dup length 1 sub 0 1
			3 2 roll
			{
				% <s> <p> <s_i> <s_sub> <offset>
				dup 2 index exch get
				exch 4 index exch get
				ne {
					% Not equal.  Exit the inner loop.
					false exit
				} if
			} for

			% Check to see if the substring match failed.
			dup type /booleantype eq {
				% <s> <p> <s_i> <s_sub> false
				% Failure.  Clean up.
				pop pop pop
			}{
				% <s> <p> <s_i> <s_sub>
				% Success.
				3 2 roll pop
				% <s> <s_i> <s_sub>

				% Contstruct pre string <s_pre>.
				3 1 roll dup 2 index exch 0 exch
				% <s_sub> <s> <s_i> <s> 0 <s_i>
				getinterval
				% <s_sub> <s> <s_i> <s_pre>
				3 1 roll
				% <s_sub> <s_pre> <s> <s_i>

				% Contstruct post string <s_post>.
				3 index length add dup
				2 index length exch sub
				getinterval
				% <s_sub> <s_pre> <s_post>
				3 1 roll

				true
				% <s_post> <s_sub> <s_pre> true
				exit
			} ifelse
		} for

		% Check to see if we succeeded.  If not, set up the stack to
		% return failure.
		dup type /booleantype ne {
			% Failure.
			pop false
		} if
	}{
		% Substring is too long.
		pop false
	} ifelse
} def

% [`<path>' `<args>'...] system <exit_code>
/system {
	fork
	dup 0 eq {
		errordict begin
		/handleerror {quit} def
		end
		pop exec
	}{
		exch pop waitpid
	} ifelse
} def

% /errorname throw -
/throw {
	% Do some sanity checking, to try to avoid going infinitely recursive
	% in the error handling machinery.
	{
		{/errordict where {pop true}{false} ifelse}
		{/errordict load /handleerror known}
		{/errordict load /stop known}
		{/currenterror where {pop true}{false} ifelse}
	}{
		eval not {
			`Onyx: Missing errordict or currenterror defs\n' print

			% Print stack dumps.
			`ostack: ' print
			ostack 2 sprint

			`dstack: ' print
			dstack 2 sprint

			`estack: ' print
			estack 2 sprint

			`istack: ' print
			istack 2 sprint

			`Onyx: dieing\n' print flush
			1 die
		} if
	} foreach

	% Make sure the argument is a name.
	dup type /nametype ne {
		/typecheck /systemdict load /throw get eval
	} if

	/currenterror load begin

	% Set newerror to true to indicate there is an error.  It is up to the
	% application to clear this afterwards if it wants to make newerror
	% meaningful in the face of multiple errors.
	/newerror true def

	% Set errorname to the argument passed in.
	dup /errorname exch cvlit def

	% ostack.  Get rid of /errorname in the snapshot.
	ostack spop pop /ostack exch def

	% dstack.  Don't include the top element, which is the copy of
	% currenterror that we pushed.
	/dstack dstack spop pop def

	% estack.  Remove this procedure from the snapshot.
	estack spop pop /estack exch def

	% istack.  Remove this procedure from the snapshot.
	istack spop pop /istack exch def

	% Push the offending object onto ostack.
	/estack load sdup spop exch pop

	end % currenterror.

	% Call the error handler.
	exch /errordict load exch get eval

	% Stop.
	/errordict load /stop get eval
} def

% - version <string>
/version `<Version>' def

end % systemdict.

} % End deferral.

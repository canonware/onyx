%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% libsock portion of Canonware Software Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{libsock}

The \libname{libsock} library implements a streamlined interface for
multi-threaded TCP/IP socket programming.  The main purpose of the library is to
abstract the complexities of threaded network server programming without
compromising performance.  libsock centrally handles all of the \cfunc{poll}{}
waiting in one thread to improve performance, at the same time as making reading
and writing seem completely asynchronous at the sock interface level.

Internally, \libname{libsock} works by running a separate thread that
asynchronously manages I/O.  A simple message passing mechanism is used to
communicate control events to the I/O thread.  Data are managed and buffered
with \libname{libstash\/}'s \classname{buf} code.  As such, all library
interfaces for injecting and extracting data require the use of
\classname{buf\/}s.  The I/O thread handles (almost) all of the reading/writing
of data from/to sockets.

\cfunc{libsock\_spare\_bufc\_get}{} provides a method of globally managing
memory buffers.

A simple mechanism for multiplexing connection handling onto a set of threads is
provided.  This mechanism can be thought of as a way of hooking into the I/O
thread's poll loop.


Regardless of what classes are used, at least the following minimal shell of C
code should be used.

\begin{verbatim}
#include <libsock/libsock.h>

int
main()
{
        libstash_init();
        libsock_init(
            1024, /* Max fd number, plus one. */
            4096, /* bufc size. */
            16);  /* Maximum bufc's to cache. */

        /* Do stuff. */

        libsock_shutdown();
        libstash_shutdown();
        return 0;
}
\end{verbatim}

All \libname{libsock} and \libname{libstash} class API definitions are made
available via the \filename{libsock/libsock.h} header.  \cfunc{libstash\_init}{}
and \cfunc{libsock\_init}{} must be called in order for things to work properly.

\section{Compilation}
Use one of the following compiler command lines to compile applications with
\libname{libsock}.
\begin{description}
\item[Normal: ] cc \filename{file} -lsock -lstash -lpthread
\item[Debug: ] cc -g -D\_LIBSTASH\_DBG -D\_LIBSOCK\_DBG \filename{file}
-lsock\_d -lstash\_d -lpthread
\item[Profile: ] cc -pg \filename{file} -lsock\_p -lstash\_p -lpthread
\end{description}

\section{API}
\begin{description}
\label{libsock_init}
\index{\cfunc{libsock\_init}{}}
\item[{\cfunc[void]{libsock\_init}{cw\_uint32\_t a\_max\_fds, cw\_uint32\_t
a\_bufc\_size, cw\_uint32\_t a\_max\_spare\_bufcs}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_max\_fds: ]
			Maximum possible file descriptor plus one.
		\item[a\_bufc\_size: ]
			Size of \classname{bufc} to use for memory buffering.
		\item[a\_max\_spare\_bufcs: ]
			Maximum number of \classname{bufc} objects to cache in
			one \classname{pezz} block.  If more than this number of
			\classname{bufc} objects is needed, \libname{libsock}
			will attempt to allocate another block of
			\classname{bufc} objects.  Note that once allocated, the
			space is not freed until \cfunc{libsock\_shutdown}{} is
			called.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Global initializer for \libname{libsock} and its I/O thread.
	\end{description}
\label{libsock_shutdown}
\index{\cfunc{libsock\_shutdown}{}}
\item[{\cfunc[void]{libsock\_shutdown}{void}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Global shutdown for \libname{libsock}.
	\end{description}
\label{libsock_spare_bufc_get}
\index{\cfunc{libsock\_spare\_bufc\_get}{}}
\item[{\cfunc[cw\_bufc\_t *]{libsock\_spare\_bufc\_get}{void}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{bufc}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Get a \classname{bufc}, using an internal \classname{pezz}.  The
		\classname{bufc} is of the size specified by the
		\cvar{a\_bufc\_size} parameter passed to
		\cfunc{libsock\_init}{}.
	\end{description}
\label{libsock_in_notify}
\index{\cfunc{libsock\_in\_notify}{}}
\item[{\cfunc[void]{libsock\_in\_notify}{cw\_mq\_t *a\_mq, cw\_sock\_t *a\_sock,
void *a\_val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_mq: ]
			Pointer to a \classname{mq}, or NULL.
		\item[a\_sock: ]
			Pointer to the \classname{sock} for which notifications
			should be sent to \cvar{a\_mq}.
		\item[a\_val: ]
			Value to send to \cvar{a\_mq} when data are available
			for \cvar{a\_sock}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Register such that whenever data are available for reading on
		\cvar{a\_sock}, or \cvar{a\_sock} is closed by the I/O thread, a
		message (\cvar{a\_val}) is sent to \cvar{a\_mq}.  To stop
		receiving notifications, pass a NULL pointer for the
		\cvar{a\_mq} parameter. Note that only one \classname{mq} at a
		time can be notified of events on a particular \classname{sock}.
	\end{description}
\end{description}

\section{Classes}
\input{@abs_srcdir@/lib/c/libsock/doc/latex/sock}
\input{@abs_srcdir@/lib/c/libsock/doc/latex/socks}

.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libsock_socks 3s "libsock, version <Version>"
.Nm libsock
.hy 1
.SH NAME
socks - Socket server class.
.SH SYNOPSIS
\fB#include <libsock/libsock.h>\fR

.I cw_socks_t *
.br
.B socks_new
.RI ( "cw_socks_t *a_socks" )

.I void
.br
.B socks_delete
.RI ( "cw_socks_t *a_socks" )

.I cw_bool_t
.br
.B socks_listen
.RI ( "cw_socks_t *a_socks" ", " "cw_uint32_t a_mask" ", " "int *r_port" )

.I cw_sock_t *
.br
.B socks_accept
.RI ( "cw_socks_t *a_socks" ", " "struct timespec *a_timeout" ", "
.IR "cw_sock_t *r_sock" )

.SS Debugging (dbg) symbols
.TP
\*(lqsocks_error\*(rq
Errors that indicate a programming or network error.

.SH DESCRIPTION
\fBsocks\fR implements a socket listener (server).  \fBsocks\fR is used to
accept connections to a port and create a \fBsock\fR instance for each
connection.

.SH USAGE
.I cw_socks_t *
.br
.B socks_new
.RI ( "cw_socks_t *a_socks" )
.RS
Input(s):
.RS
.IR a_socks :
.RS
Pointer to a socks.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a socks.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B socks_delete
.RI ( "cw_socks_t *a_socks" )
.RS
Input(s):
.RS
.IR a_socks :
.RS
Pointer to a socks.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I cw_bool_t
.br
.B socks_listen
.RI ( "cw_socks_t *a_socks" ", " "cw_uint32_t a_mask" ", " "int *r_port" )
.RS
Input(s):
.RS
.IR a_socks :
.RS
Pointer to a socks.
.RE
.IR a_mask :
.RS
Mask of client addresses to listen to (INADDR_ANY, INADDR_LOOPBACK, etc.).
.RE
.IR r_port :
.RS
Port number to listen on, or 0.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: \fBsocket\fR() error, \fBbind\fR() error, or \fBgetsockname\fR() error.
.RE
.IR *r_port :
.RS
If (retval == FALSE), port number that a_socks is listening on.  Otherwise,
undefined.
.RE
.RE
Description:
.RS
Do setup and start accepting connections on *r_port.  If *r_port is 0, let the
OS choose what port number to use, and assign the number to *r_port before
returning.
.RE
.RE

.I cw_sock_t *
.br
.B socks_accept
.RI ( "cw_socks_t *a_socks" ", " "struct timespec *a_timeout" ", "
.IR "cw_sock_t *r_sock" )
.RS
Input(s):
.RS
.IR a_socks :
.RS
Pointer to a socks.
.RE
.IR a_timeout :
.RS
Pointer to a timeout value, specified as an absolute time interval, or NULL.  A
NULL value will cause this function to block indefinitely.
.RE
.IR r_sock :
.RS
Pointer to a sock that is not connected.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: r_sock.
.br
NULL: Not listening, cannot allocate file descriptor, \fBaccept\fR() error, or
\fBsock_wrap\fR() error.
.RE
.RE
Description:
.RS
Accept a connection.  Don't return until someone connects, or the timeout
expires.
.RE
.RE

.SH SEE ALSO
libsock(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

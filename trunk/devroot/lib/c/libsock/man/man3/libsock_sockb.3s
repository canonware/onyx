.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libsock_sockb 3s "libsock, version <Version>"
.Nm libsock
.hy 1
.SH NAME
sockb - Back end I/O thread.
.SH SYNOPSIS
\fB#include <libsock/libsock.h>\fR

.I cw_bool_t
.br
.B sockb_init
.RI ( "cw_uint32_t a_max_fds" ", " "cw_uint32_t a_bufc_size" ", "
.IR "cw_uint32_t a_max_spare_bufcs" )

.I void
.br
.B sockb_shutdown
.RI ( "void" )

.I cw_bufc_t *
.br
.B sockb_get_spare_bufc
.RI ( "void" )

.I cw_bool_t
.br
.B sockb_in_notify
.RI ( "cw_mq_t *a_mq" ", " "int a_sockfd" )

.SS Debugging (dbg) symbols
.TP
\*(lqsockb_error\*(rq
Unusual error conditions that indicate something is going wrong.

.TP
\*(lqsockb_verbose\*(rq
Common events such as remote disconnection and DNS lookup results.

.SH DESCRIPTION
\fBsockb\fR encapsulates the back end I/O thread in \fBlibsock\fR.  In addition,
\fBsockb_get_spare_bufc\fR() provides a method of globally managing memory
buffers.  \fBsockb\fR is of little interest to the user, other than that it has
to be manually initialized and shut down with \fBsockb_init\fR() and
\fBsockb_shutdown\fR().

\fBsockb\fR takes care of all of the socket reading and writing details.  The
\fBsock\fR class relies on \fBsockb\fR extensively.  \fBsock\fR's and the
\fBsockb\fR I/O thread communicate via a message queue.  The \fBsockb\fR thread
makes various callbacks to the \fBsock\fR's.

The I/O thread handles (almost) all of the reading/writing of data from/to
sockets.  Since there only needs to be one \fBsockb\fR instance, a global
variable (g_sockb) is implicitly used by the methods in this class.

The goal of \fBsockb\fR is to centrally handle all of the \fBpoll\fR() waiting
in one thread to improve performance, at the same time as making reading and
writing seem completely asynchronous at the \fBsock\fR interface level.

.SH USAGE

.I cw_bool_t
.br
.B sockb_init
.RI ( "cw_uint32_t a_max_fds" ", " "cw_uint32_t a_bufc_size" ", "
.IR "cw_uint32_t a_max_spare_bufcs" )
.RS
Input(s):
.RS
.IR a_max_fds :
.RS
Maximum possible file descriptor plus one.
.RE
.IR a_bufc_size :
.RS
Size of bufc to use for memory buffering.
.RE
.IR a_max_spare_bufcs :
.RS
Maximum number of \fBbufc\fR's to cache in one \fBpezz\fR block.  If more than
this number of \fBbufc\fR's is needed, the \fBsockb\fR code will attempt to
allocate another block of \fBbufc\fR's.  Note that once allocated, the space is
not freed until \fBsockb_shutdown\fR() is called.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Global initializer for g_sockb and the I/O thread.
.RE
.RE

.I void
.br
.B sockb_shutdown
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Global shutdown for g_sockb.
.RE
.RE

.I cw_bufc_t *
.br
.B sockb_get_spare_bufc
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a \fBbufc\fR instance.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
Get a \fBbufc\fR, using internal \fBpezz\fR's.  \fBbufc\fR's are guaranteed to
be of the size specified by the a_bufc_size parameter passed to
\fBsockb_init\fR().
.RE
.RE

.I cw_bool_t
.br
.B sockb_in_notify
.RI ( "cw_mq_t *a_mq" ", " "int a_sockfd" )
.RS
Input(s):
.RS
.IR a_mq :
.RS
Pointer to a mq, or NULL.
.RE
.IR a_sockfd :
.RS
A socket desccriptor number.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Register such that whenever data is available for reading on a_sockfd, or
a_sockfd is closed by the \fBsockb\fR thread, a message is sent to a_mq.  The
message is simply a socket descriptor number embedded in the \fBmq\fR's data
pointer (ew gross), in order to avoid memory allocation complexity.  To stop
receiving notifications, pass a NULL \fBmq\fR pointer.

Note: Only one mq at a time can be notified of events on a particular sockfd.
.RE

.SH SEE ALSO
libsock(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

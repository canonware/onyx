.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libsock_<template> 3s "libsock, version <Version>"
.hy 1
.SH NAME
libsock - Multi-threaded TCP/IP networking library.
.SH SYNOPSIS
cc
.I file
-lsock -lstash -lpthread
.br
cc -g -D_LIBSTASH_DBG -D_LIBSOCK_DBG
.I file
-lsock_d -lstash_d -lpthread
.br
cc -pg
.I file
-lsock_p -lstash_p -lpthread
.PP
.I void
.br
.B libsock_init
.RI ( "cw_uint32_t a_max_fds" ", " "cw_uint32_t a_bufc_size" ", "
.IR "cw_uint32_t a_max_spare_bufcs" )
.PP
.I void
.br
.B libsock_shutdown
.RI ( "void" )
.PP
.I cw_bufc_t *
.br
.B libsock_spare_bufc_get
.RI ( "void" )
.PP
.I void
.br
.B libsock_in_notify
.RI ( "cw_mq_t *a_mq" ", " "int a_sockfd" )
.SS Debugging (dbg) symbols
.TP
\*(lqlibsock_error\*(rq
Unusual error conditions that indicate something is going wrong.
.TP
\*(lqlibsock_verbose\*(rq
Common events such as remote disconnection and DNS lookup results.
.SH DESCRIPTION
The \fBlibsock\fR library implements a streamlined interface for multi-threaded
TCP/IP socket programming.  The main purpose of the library is to abstract the
complexities of threaded network server programming without compromising
performance.  \fBlibsock\fR centrally handles all of the \fBpoll\fR() waiting in
one thread to improve performance, at the same time as making reading and
writing seem completely asynchronous at the \fBsock\fR interface level.
.PP
Internally, \fBlibsock\fR works by running a separate thread that asynchronously
manages I/O.  A simple message passing mechanism is used to communicate control
events to the I/O thread.  Data are managed and buffered with \fBlibstash\fR's
\fBbuf\fR code.  As such, all library interfaces for injecting and extracting
data require the use of \fBbuf\fR's.  The I/O thread handles (almost) all of the
reading/writing of data from/to sockets.
.PP
\fBlibsock_spare_bufc_get\fR() provides a method of globally managing memory
buffers.
.PP
A simple mechanism for multiplexing connection handling onto a set of threads is
provided.  This mechanism can be thought of as a way of hooking into the I/O
thread's poll loop.
.SH USAGE
Detailed usage of the various available classes is discussed in detail in other
man pages.  Regardless of what classes are used, at least the following minimal
shell of C code should be used.
.RS
.nf
#include <libsock/libsock.h>

int
main()
{
.in +8
libstash_init();
libsock_init(
    1024, /* Max fd number, plus one. */
    4096, /* bufc size. */
    16);  /* Maximum bufc's to cache. */

/* Do stuff. */

libsock_shutdown();
libstash_shutdown();
return 0;
.in -8
}
.fi
.RE
.PP
.I void
.br
.B libsock_init
.RI ( "cw_uint32_t a_max_fds" ", " "cw_uint32_t a_bufc_size" ", "
.IR "cw_uint32_t a_max_spare_bufcs" )
.RS
Input(s):
.RS
.IR a_max_fds :
.RS
Maximum possible file descriptor plus one.
.RE
.IR a_bufc_size :
.RS
Size of bufc to use for memory buffering.
.RE
.IR a_max_spare_bufcs :
.RS
Maximum number of \fBbufc\fR's to cache in one \fBpezz\fR block.  If more than
this number of \fBbufc\fR's is needed, \fBlibsock\fR will attempt to allocate
another block of \fBbufc\fR's.  Note that once allocated, the space is not freed
until \fBlibsock_shutdown\fR() is called.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Global initializer for libsock and the I/O thread.
.RE
.RE
.PP
.I void
.br
.B libsock_shutdown
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Global shutdown for libsock.
.RE
.RE
.PP
.I cw_bufc_t *
.br
.B libsock_spare_bufc_get
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a \fBbufc\fR instance.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Get a \fBbufc\fR, using internal \fBpezz\fR's.  \fBbufc\fR's are guaranteed to
be of the size specified by the a_bufc_size parameter passed to
\fBlibsock_init\fR().
.RE
.RE
.PP
.I void
.br
.B libsock_in_notify
.RI ( "cw_mq_t *a_mq" ", " "int a_sockfd" )
.RS
Input(s):
.RS
.IR a_mq :
.RS
Pointer to a mq, or NULL.
.RE
.IR a_sockfd :
.RS
A socket desccriptor number.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Register such that whenever data is available for reading on a_sockfd, or
a_sockfd is closed by the I/O thread, a message is sent to a_mq.  The message is
simply a socket descriptor number.  To stop receiving notifications, pass a NULL
\fBmq\fR pointer.
.br
Note: Only one mq at a time can be notified of events on a particular sockfd.
.RE
.SH SEE ALSO
libsock_sock(3s), libsock_socks(3s), libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

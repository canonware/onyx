.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_mem 3s "libstash, version <Version>"
.Nm libstash_mem
.hy 1
.SH NAME
mem - malloc wrapper.

.SH SYNOPSIS
.SS Single-threaded
\fB#include <libstash/libstash.h>\fR

.SS Multi-threaded
\fB#include <libstash/libstash_r.h>\fR

.SS General
.I cw_mem_t *
.br
.B mem_new
.RI ( "void" )

.I void
.br
.B mem_delete
.RI ( "cw_mem_t * a_mem" )

.I void
.br
.B mem_set_oom_handler
.RI ( "cw_mem_t * a_mem" ", " "cw_mem_oom_handler_t * a_oom_handler" ", "
.IR "const void * a_data" )

.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_size" ", " "const char * a_filename"
.RI ", " "cw_uint32_t a_line_num" )

.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_number" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_number" ", " "size_t a_size" ", "
.IR "const char * a_filename" ", " "cw_uint32_t a_line_num" )

.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "size_t a_size" ", "
.IR "const char * a_filename" ", " "cw_uint32_t a_line_num" )

.I void
.br
.B mem_free
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" )
.br
.I void
.br
.B mem_free
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "const char * a_filename"
.RI ", " "cw_uint32_t a_line_num" )

.I void
.br
.B mem_dealloc
.RI ( "void * a_mem" ", " "void * a_ptr" )

.SS Debugging (dbg) symbols
.TP
\*(lqmem_verbose\*(rq
In the debug versions of libstash, print out full tracking information for every
allocation and deallocation.
.TP
\*(lqmem_error\*(rq
In the debug versions of libstash, print out information about memory leaks and
other detectable errors or inconsistencies.

.SH DESCRIPTION
Public interface for a memory allocation (malloc) wrapper class.  For the debug
versions of libstash, extra information is hashed for each memory allocation
that allows tracking of the following:

.RS
- File/line number of allocation.
.br
- Double allocation/deallocation of the same address.
.br
- Memory leaks memory left allocated at mem destruction time.
.RE

Also, the debug versions of the library set all newly allocated bytes to 0xa5,
and all deallocated bytes to 0x5a (except in the case of \fBmem_calloc\fR()).
This tends to cause things to break sooner when uninitialized or deallocated
memory is referenced.

In general, this class doesn't need to be used directly.  Instead, there are
several preprocessor macros that can be used: \fB_cw_malloc\fR(),
\fB_cw_calloc\fR(), \fB_cw_realloc\fR(), \fB_cw_free\fR(), and
\fB_cw_dealloc\fR().

.SH USAGE
.I cw_mem_t *
.br
.B mem_new
.RI ( "void" )
.br
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a mem.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B mem_delete
.RI ( "cw_mem_t * a_mem" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I void
.br
.B mem_set_oom_handler
.RI ( "cw_mem_t * a_mem" ", " "cw_mem_oom_handler_t * a_oom_handler" ", "
.IR "const void * a_data" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_oom_handler :
.RS
Pointer to an out of memory handler, or NULL.
.RE
.IR a_data :
.RS
Data pointer that is passed into a_oom_handler().
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Set an out of memory handler function.  The handler function is called whenever
memory allocation fails.  If the handler returns TRUE, alloction is
re-attempted once.
.RE
.RE

.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_size" ", " "const char * a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_size :
.RS
Size of memory range desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a memory range.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBmalloc\fR() wrapper.
.RE
.RE

.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_number" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t * a_mem" ", " "size_t a_number" ", " "size_t a_size" ", "
.IR "const char * a_filename" ", " "cw_uint32_t a_line_num" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_number :
.RS
Number of elements.
.RE
.IR a_size :
.RS
Size of each element desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non_NULL: Pointer to a zeroed memory range.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBcalloc\fR() wrapper.
.RE
.RE

.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "size_t a_size" )
.br
.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "size_t a_size" ", "
.IR "const char * a_filename" ", " "cw_uint32_t a_line_num" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_ptr :
.RS
Pointer to memory range to be reallocated.
.RE
.IR a_size :
.RS
Size of memory range desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non_NULL: Pointer to a zeroed memory range.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBrealloc\fR() wrapper.
.RE
.RE

.I void
.br
.B mem_free
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" )
.br
.I void
.br
.B mem_free
.RI ( "cw_mem_t * a_mem" ", " "void * a_ptr" ", " "const char * a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_ptr :
.RS
Pointer to a memory range to be freed.
.RE
.IR a_size :
.RS
Size of memory range disired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
\fBfree\fR() wrapper.
.RE
.RE

.I void
.br
.B mem_dealloc
.RI ( "void * a_mem" ", " "void * a_ptr" )
.br
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_ptr :
.RS
Pointer to be freed.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Basically the same as \fBmem_free\fR(), but with a different function prototype.
This function can be used for passing a function pointer to do automatic
deallocation, as in the buf and ring classes.
.RE
.RE

.SH SEE ALSO
libstash(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

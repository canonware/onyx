.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_mem 3s "libstash, version <Version>"
.hy 1
.SH NAME
mem - malloc wrapper.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.PP
.I cw_mem_t *
.br
.B mem_new
.RI ( "cw_mem_t *a_mem" )
.PP
.I void
.br
.B mem_delete
.RI ( "cw_mem_t *a_mem" )
.PP
.I void *
.br
.B mem_malloc_e
.RI ( "cw_mem_t *a_mem" ", " "size_t a_size" ", " "const char *a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t *a_mem" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_malloc
.RI ( "size_t a_size" )
.PP
.I void *
.br
.B mem_calloc_e
.RI ( "cw_mem_t *a_mem" ", " "size_t a_number" ", " "size_t a_size" ", "
.IR "const char *a_filename" ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t *a_mem" ", " "size_t a_number" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_calloc
.RI ( "size_t a_number" ", " "size_t a_size" )
.PP
.I void *
.br
.B mem_realloc_e
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "size_t a_size" ", "
.IR "const char *a_filename" ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_realloc
.RI ( "void *a_ptr" ", " "size_t a_size" )
.PP
.I void
.br
.B mem_free_e
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "const char *a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
.I void
.br
.B mem_free
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" )
.br
.I void
.br
.B _cw_free
.RI ( "void *a_ptr" )
.SS Debugging (dbg) symbols
.TP
\*(lqmem_verbose\*(rq
In the debug versions of libstash, print out full tracking information for every
allocation and deallocation.
Output is printed to file descriptor 2, since using cw_g_out would cause a
circular dependency, resulting in possible infinite recursion.
.TP
\*(lqmem_error\*(rq
In the debug versions of libstash, print out information about memory leaks and
other detectable errors or inconsistencies.
Output is printed to file descriptor 2, since using cw_g_out would cause a
circular dependency, resulting in possible infinite recursion.
.SH DESCRIPTION
Public interface for a memory allocation (malloc) wrapper class.  For the debug
versions of libstash, extra information is hashed for each memory allocation
that allows tracking of the following:
.PP
.RS
- File/line number of allocation.
.br
- Double allocation/deallocation of the same address.
.br
- Memory leaks (memory left allocated at mem destruction time).
.RE
.PP
Also, the debug versions of the library set all newly allocated bytes to 0xa5,
and all deallocated bytes to 0x5a (except in the case of \fBmem_calloc\fR()).
This tends to cause things to break sooner when uninitialized or deallocated
memory is referenced.
.PP
In general, this class doesn't need to be used directly.  Instead, there are
several preprocessor macros that can be used: \fB_cw_malloc\fR(),
\fB_cw_calloc\fR(), \fB_cw_realloc\fR(), and \fB_cw_free\fR().
.SH USAGE
.I cw_mem_t *
.br
.B mem_new
.RI ( "void" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to space for a mem.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a mem.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor.
.RE
.RE
.PP
.I void
.br
.B mem_delete
.RI ( "cw_mem_t *a_mem" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE
.PP
.I void *
.br
.B mem_malloc_e
.RI ( "cw_mem_t *a_mem" ", " "size_t a_size" ", " "const char *a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_malloc
.RI ( "cw_mem_t *a_mem" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_malloc
.RI ( "size_t a_size" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_size :
.RS
Size of memory range desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a memory range.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
\fBmalloc\fR() wrapper.
.RE
.RE
.PP
.I void *
.br
.B mem_calloc_e
.RI ( "cw_mem_t *a_mem" ", " "size_t a_number" ", " "size_t a_size" ", "
.IR "const char *a_filename" ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_calloc
.RI ( "cw_mem_t *a_mem" ", " "size_t a_number" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_calloc
.RI ( "size_t a_number" ", " "size_t a_size" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_number :
.RS
Number of elements.
.RE
.IR a_size :
.RS
Size of each element desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a zeroed memory range.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
\fBcalloc\fR() wrapper.
.RE
.RE
.PP
.I void *
.br
.B mem_realloc_e
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "size_t a_size" ", "
.IR "const char *a_filename" ", " "cw_uint32_t a_line_num" )
.br
.I void *
.br
.B mem_realloc
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "size_t a_size" )
.br
.I void *
.br
.B _cw_realloc
.RI ( "void *a_ptr" ", " "size_t a_size" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_ptr :
.RS
Pointer to memory range to be reallocated.
.RE
.IR a_size :
.RS
Size of memory range desired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a zeroed memory range.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
\fBrealloc\fR() wrapper.
.RE
.RE
.PP
.I void
.br
.B mem_free_e
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" ", " "const char *a_filename"
.RI ", " "cw_uint32_t a_line_num" )
.br
.I void
.br
.B mem_free
.RI ( "cw_mem_t *a_mem" ", " "void *a_ptr" )
.br
.I void
.br
.B _cw_free
.RI ( "void *a_ptr" )
.RS
Input(s):
.RS
.IR a_mem :
.RS
Pointer to a mem.
.RE
.IR a_ptr :
.RS
Pointer to a memory range to be freed.
.RE
.IR a_size :
.RS
Size of memory range disired.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
\fBfree\fR() wrapper.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

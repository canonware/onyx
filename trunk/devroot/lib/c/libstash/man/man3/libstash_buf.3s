.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_buf 3s "libstash, version <Version>"
.Nm libstash_buf
.hy 1
.SH NAME
buf, bufc - Reference-counted extensible buffer.
.SH SYNOPSIS
.SS Single-threaded
#define _LIBSTASH_USE_BUF
.br
\fB#include <libstash/libstash.h>\fR

.I cw_buf_t *
.br
.B buf_new
.RI ( "cw_buf_t * a_buf" )

.SS Multi-threaded
#define _LIBSTASH_USE_BUF
.br
\fB#include <libstash/libstash_r.h>\fR

.I cw_buf_t *
.br
.B buf_new
.RI ( "cw_buf_t * a_buf" ", " "cw_bool_t a_is_threadsafe" )

.SS General
.I void
.br
.B buf_delete
.RI ( "cw_buf_t * a_buf" )

.I void
.br
.B buf_dump
.RI ( "cw_buf_t * a_buf" ", " "const char * a_prefix" )

.I cw_sint32_t
.br
.B buf_get_size
.RI ( "cw_buf_t * a_buf" )

.I cw_uint32_t
.br
.B buf_get_num_bufels
.RI ( "cw_buf_t * a_buf" )

.I const struct iovec *
.br
.B buf_get_iovec
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_max_data" ", "
.IR "cw_bool_t a_is_sys_iovec" ", " "int * r_iovec_count" )

.I cw_bool_t
.br
.B buf_catenate_buf
.RI ( "cw_buf_t * a_a" ", " "cw_buf_t * a_b" ", " "cw_bool_t a_preserve" )

.I cw_bool_t
.br
.B buf_split
.RI ( "cw_buf_t * a_a" ", " "cw_buf_t * a_b" ", " "cw_uint32_t a_offset" )

.I cw_bool_t
.br
.B buf_prepend_bufc
.RI ( "cw_buf_t * a_buf" ", " "cw_bufc_t * a_bufc" ", "
.IR "cw_uint32_t a_beg_offset" ", " "cw_uint32_t a_end_offset" )

.I cw_bool_t
.br
.B buf_append_bufc
.RI ( "cw_buf_t * a_buf" ", " "cw_bufc_t * a_bufc" ", "
.IR "cw_uint32_t a_beg_offset" ", " "cw_uint32_t a_end_offset" )

.I cw_bool_t
.br
.B buf_release_head_data
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_amount" )

.I cw_bool_t
.br
.B buf_release_tail_data
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_amount" )

.I cw_uint8_t
.br
.B buf_get_uint8
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )

.I cw_uint32_t
.br
.B buf_get_uint32
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )

.I cw_uint64_t
.br
.B buf_get_uint64
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )

.I cw_bool_t
.br
.B buf_set_uint8
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint_t32 a_val" )

.I cw_bool_t
.br
.B buf_set_uint32
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint32_t a_val" )

.I cw_bool_t
.br
.B buf_set_uint64
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint64_t a_val" )

.I cw_bool_t
.br
.B buf_set_range
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint32_t a_length" ", " "cw_uint8_t * a_val" ", "
.IR "cw_bool_t a_is_writeable" )

.I cw_bufc_t *
.br
.B bufc_new
.RI ( "cw_bufc_t * a_bufc" ", "
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * bufel)" ", "
.IR "void * a_dealloc_arg)" )

.I void
.br
.B bufc_delete
.RI ( "cw_bufc_t * a_bufc" )

.I void
.br
.B bufc_set_buffer
.RI ( "cw_bufc_t * a_bufc" ", " "void * a_buffer" ", " "cw_uint32_t a_size"
.RI ", " "cw_bool_t a_is_writeable" ", "
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * buffer" ", "
.IR "void * a_dealloc_arg" )

.SS Debugging (dbg) symbols
None.

.SH DESCRIPTION
The buf and bufc classes implement a buffer abstraction.  These classes are
designed specifically to handle streaming and transparent extensible buffering
of data for applications such as socket programs. buf's are dynamically
extensible and contractible, as well as reference counted.  This means that data
can be passed and internally shared among buf's without copying or worry of
memory leaks.  Depending on the application, this also allows for very compact
use of memory buffers.

Internally, a buf consists of an array of buffer elements, bufels, that
reference bufc's.  The bufc's are reference counted, such that each bufel
reference to a bufc increases the bufc reference count.  In addition, the
library user has a reference to each bufc as when it is initialized.  When data
are passed among buf's, references are added to the affected bufc's, but no data
are actually copied.

When data are modified, they must be copied if there are multiple references, or
if the bufc was marked as non-writeable in the \fBbufc_set_buffer\fR() call.
Otherwise, data can be modified in place.

Random access to data is O(log n), where n is the number of bufel's in the buf.
Linear access, either forward or backward, is optimized to be fast in the
general case.  The most recent access is cached, so if the next access is in the
same bufel, the cost for that access is O(1).

The buf code provides an iovec (see \fBreadv\fR(2)/\fBwritev\fR(2)) interface
for accessing the internals for read-only operations.  In general, this
interface shouldn't be needed except when using the \fBwritev\fR() function.

Once a bufc has been passed to \fBbuf_{pre,ap}pend_bufc\fR(), its data must be
treated as read-only.  That is, the bufc must be treated as opaque as soon as
any buf has a reference to it.

.SH USAGE
.I cw_buf_t *
.br
.B buf_new
.RI ( "cw_buf_t * a_buf" )
.br
.I cw_buf_t *
.br
.B buf_new
.RI ( "cw_buf_t * a_buf" ", " "cw_bool_t a_is_threadsafe" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to space for a buf, or NULL.
.RE
.IR a_is_thread_safe :
.RS
FALSE: Not thread-safe.
.br
TRUE: Thread-safe.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a buf.
.br
NULL: Memory allocation.  Can only occur if (NULL == a_buf).
.RE
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B buf_delete
.RI ( "cw_buf_t * a_buf" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.RE
Output(s):
.RS
None
.RE
Description:
.RS
Destructor.
.RE
.RE

.I void
.br
.B buf_dump
.RI ( "cw_buf_t * a_buf" ", " "const char * a_prefix" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_prefix :
.RS
Pointer to a string that represents a string to be prefixed to each line of
output.
.RE
.RE
Output(s):
.RS
a_buf's internals printed to cw_g_out.
.RE
Description:
.RS
Dump the internal state of a_buf to cw_g_out.
.RE
.RE

.I cw_sint32_t
.br
.B buf_get_size
.RI ( "cw_buf_t * a_buf" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes of valid data.
.RE
.RE
Description:
.RS
Return the amout of valid data in bytes.
.RE
.RE

.I cw_uint32_t
.br
.B buf_get_num_bufels
.RI ( "cw_buf_t * a_buf" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bufel's (internal buffer elements) in a_buf (same as iovec count in
\fBbuf_get_iovec\fR()).
.RE
.RE
Description:
.RS
Return the number of bufel's in a_buf.
.RE
.RE

.I const struct iovec *
.br
.B buf_get_iovec
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_max_data" ", "
.IR "cw_bool_t a_is_sys_iovec" ", " "int * r_iovec_count" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_max_data :
.RS
Maximum number of bytes of space to include in the iovec.
.RE
.IR a_is_sys_iovec :
.RS
If TRUE, limit *r_iovec_count to the maximum iovec count supported by this
system for \fBreadv\fR()/\fBwritev\fR().
.RE
.IR r_iovec_count :
.RS
Pointer to an int.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to an iovec array that represents the internal data buffers in a_buf.
.RE
.IR *r_iovec_count :
.RS
Number of valid iovec structures in retval.
.RE
.RE
Description:
.RS
Build an iovec array that represents the valid data in a_buf's internal buffers
(up to a_max_data bytes) and return a pointer to it.
.RE
.RE

.I cw_bool_t
.br
.B buf_catenate_buf
.RI ( "cw_buf_t * a_a" ", " "cw_buf_t * a_b" ", " "cw_bool_t a_preserve" )
.RS
Input(s):
.RS
.IR a_a :
.RS
Pointer to a buf.
.RE
.IR a_b :
.RS
Pointer to a buf.
.RE
.IR a_preserve :
.RS
If TRUE, preserve a_b (don't modify it).  If FALSE, release the data in a_b
after catenating a_b to a_a.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Catenate two buf's.  a_b is left unmodifed if a_preserve is TRUE; otherwise a_b
is emptied.
.RE
.RE

.I cw_bool_t
.br
.B buf_split
.RI ( "cw_buf_t * a_a" ", " "cw_buf_t * a_b" ", " "cw_uint32_t a_offset" )
.RS
Input(s):
.RS
.IR a_a :
.RS
Pointer to a buf.
.RE
.IR a_b :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset at which to split a_b.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.  a_a and a_b are unmodified.
.RE
.RE
Description:
.RS
Split a_b at offset a_offset.  Append the data before a_offset to a_a, and leave
the remainder in a_b.
.RE
.RE

.I cw_bool_t
.br
.B buf_prepend_bufc
.RI ( "cw_buf_t * a_buf" ", " "cw_bufc_t * a_bufc" ", "
.IR "cw_uint32_t a_beg_offset" ", " "cw_uint32_t a_end_offset" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_bufc :
.RS
Pointer to a bufc.
.RE
.IR a_beg_offset :
.RS
Offset of first valid byte in a_bufc's memory buffer.
.RE
.IR a_end_offset :
.RS
Offset of first byte past the valid range of bytes in a_bufc's memory buffer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.  a_buf and a_bufc are unmodified.
.RE
.RE
Description:
.RS
Prepend a_bufc, bytes a_beg_offset through (a_end_offset - 1) to a_buf.
.RE
.RE

.I cw_bool_t
.br
.B buf_append_bufc
.RI ( "cw_buf_t * a_buf" ", " "cw_bufc_t * a_bufc" ", "
.IR "cw_uint32_t a_beg_offset" ", " "cw_uint32_t a_end_offset" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_bufc :
.RS
Pointer to a bufc.
.RE
.IR a_beg_offset :
.RS
Offset of first valid byte in a_bufc's memory buffer.
.RE
.IR a_end_offset :
.RS
Offset of first byte past the valid range of bytes in a_bufc's memory buffer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.  a_buf and a_bufc are unmodified.
.RE
.RE
Description:
.RS
Append a_bufc, bytes a_beg_offset through (a_end_offset - 1) to a_buf.
.RE
.RE

.I cw_bool_t
.br
.B buf_release_head_data
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_amount" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_amount :
.RS
Number of bytes of data to release from the head of a_buf.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Error.  (a_amount > buf_get_size(a_buf)).
.RE
.RE
Description:
.RS
Release a_amount bytes from the head of a_buf.
.RE
.RE

.I cw_bool_t
.br
.B buf_release_tail_data
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_amount" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_amount :
.RS
Number of bytes of data to release from the tail of a_buf.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Error.  (a_amount > buf_get_size(a_buf)).
.RE
.RE
Description:
.RS
Release a_amount bytes from the tail of a_buf.
.RE
.RE

.I cw_uint8_t
.br
.B buf_get_uint8
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of uint8 to return.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Value of the uint8 at offset a_offset in a_buf.
.RE
.RE
Description:
.RS
Return the uint8 at offset a_offset.
.RE
.RE

.I cw_uint32_t
.br
.B buf_get_uint32
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of uint32 to return.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Value of the uint32 at offset a_offset in a_buf.
.RE
.RE
Description:
.RS
Return the uint32 at offset a_offset.
.RE
.RE

.I cw_uint64_t
.br
.B buf_get_uint64
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of uint64 to return.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Value of the uint64 at offset a_offset in a_buf.
.RE
.RE
Description:
.RS
Return the uint64 at offset a_offset.
.RE
.RE

.I cw_bool_t
.br
.B buf_set_uint8
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint_t32 a_val" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of data to set. (a_offset <= buf_get_size(a_buf)).
.RE
.IR a_val :
.RS
Value to set data at a_offset to.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Set the uint8 at a_offset to a_val.
.RE
.RE

.I cw_bool_t
.br
.B buf_set_uint32
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint32_t a_val" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of data to set. (a_offset <= buf_get_size(a_buf)).
.RE
.IR a_val :
.RS
Value to set data at a_offset to.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Set the uint32 at a_offset to a_val.
.RE
.RE

.I cw_bool_t
.br
.B buf_set_uint64
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint64_t a_val" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of data to set. (a_offset <= buf_get_size(a_buf)).
.RE
.IR a_val :
.RS
Value to set data at a_offset to.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Set the uint64 at a_offset to a_val.
.RE
.RE

.I cw_bool_t
.br
.B buf_set_range
.RI ( "cw_buf_t * a_buf" ", " "cw_uint32_t a_offset" ", "
.IR "cw_uint32_t a_length" ", " "cw_uint8_t * a_val" ", "
.IR "cw_bool_t a_is_writeable" )
.RS
Input(s):
.RS
.IR a_buf :
.RS
Pointer to a buf.
.RE
.IR a_offset :
.RS
Offset in bytes of data to set. (a_offset <= buf_get_size(a_buf)).
.RE
.IR a_length :
.RS
Number of bytes to copy from a_val.
.RE
.IR a_val :
.RS
Value to set data at a_offset to.
.RE
.IR a_is_writeable :
.RS
FALSE: Non-writeable buffer.
.br
TRUE: Writeable buffer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Copy a_offset bytes from a_val to a_buf at offset a_offset.
.RE
.RE

.I cw_bufc_t *
.br
.B bufc_new
.RI ( "cw_bufc_t * a_bufc" ", "
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * bufel)" ", "
.IR "void * a_dealloc_arg)" )
.RS
Input(s):
.RS
.IR a_bufc :
.RS
Pointer to a bufc.
.RE
.IR a_dealloc_func :
.RS
non-NULL: Pointer to a deallocation function.
.br
NULL: No deallocation function.
.br
Ignored if (NULL == a_bufc).
.RE
.IR a_dealloc_arg :
.RS
First argument to a_dealloc_func.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a bufc.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B bufc_delete
.RI ( "cw_bufc_t * a_bufc" )
.RS
Input(s):
.RS
.IR a_bufc :
.RS
Pointer to a bufc.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I void
.br
.B bufc_set_buffer
.RI ( "cw_bufc_t * a_bufc" ", " "void * a_buffer" ", " "cw_uint32_t a_size"
.RI ", " "cw_bool_t a_is_writeable" ", "
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * buffer" ", "
.IR "void * a_dealloc_arg" )
.RS
Input(s):
.RS
.IR a_bufc :
.RS
Pointer to a bufc.
.RE
.IR a_buffer :
.RS
Pointer to a buffer.
.RE
.IR a_size :
.RS
Size of buffer pointed to by a_buffer.
.RE
.IR a_dealloc_func :
.RS
non-NULL: Pointer to a deallocation function.
.br
NULL: No deallocation function.
.RE
.IR a_dealloc_arg :
.RS
First argument to a_dealloc_func.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Set a_bufc's internal data buffer to a_buffer, with size a_size, and
deallocation function a_dealloc_func(a_dealloc_arg, a_buffer).

This function is not reentrant, and assumes that no other references to a_bufc
exist (or at least they don't rely on the bufc's state).  In other words, don't
call this function after the bufc has been inserted into one or more buf's.
.RE
.RE

.SH SEE ALSO
libstash(3s), readv(2), writev(2).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

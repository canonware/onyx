.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_tsd 3s "libstash, version <Version>"
.hy 1
.SH NAME
tsd - Thread-specific data.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.PP
.I void
.br
.B tsd_new
.RI ( "cw_tsd_t *a_tsd" ", " "void (*a_func)(void *)" )
.PP
.I void
.br
.B tsd_delete
.RI ( "cw_tsd_t *a_tsd" )
.PP
.I void *
.br
.B tsd_get
.RI ( "cw_tsd_t *a_tsd" )
.PP
.I void
.br
.B tsd_set
.RI ( "cw_tsd_t *a_tsd" ", " "void *a_val" )
.SS Debugging (dbg) symbols
None.
.SH DESCRIPTION
\fBtsd\fR implements thread-specific data.  A \fBtsd\fR instance can be created,
then any number of threads can use that same instance to store and retrieve a
thread-specific pointer to data.
.SH USAGE
.I void
.br
.B tsd_new
.RI ( "cw_tsd_t *a_tsd" ", " "void (*a_func)(void *)" )
.RS
Input(s):
.RS
.IR a_tsd :
.RS
Pointer to space for a tsd.
.RE
.IR a_func :
.RS
Pointer to a cleanup function, or NULL.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Constructor.
.RE
.RE
.PP
.I void
.br
.B tsd_delete
.RI ( "cw_tsd_t *a_tsd" )
.RS
Input(s):
.RS
.IR a_tsd :
.RS
Pointer to a tsd.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE
.PP
.I void *
.br
.B tsd_get
.RI ( "cw_tsd_t *a_tsd" )
.RS
Input(s):
.RS
.IR a_tsd :
.RS
Pointer to a tsd.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to thread-specific data.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Get thread-specific data pointer.
.RE
.RE
.PP
.I void
.br
.B tsd_set
.RI ( "cw_tsd_t *a_tsd" ", " "void *a_val" )
.RS
Input(s):
.RS
.IR a_tsd :
.RS
Pointer to a tsd.
.RE
.IR a_val :
.RS
Pointer to thread-specific data.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Set thread-specific data pointer.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

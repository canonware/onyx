.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_qr 3s "libstash, version <Version>"
.hy 1
.SH NAME
qr - Ring macros
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.SS Data structures
.B qr
.RI ( "<qr_type> a_type" )
.SS Operations
.I void
.br
.B qr_new
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.PP
.I <qr_type> *
.br
.B qr_next
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.PP
.I <qr_type> *
.br
.B qr_prev
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.PP
.I void
.br
.B qr_before_insert
.RI ( "<qr_type> *a_qrelm" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.PP
.I void
.br
.B qr_after_insert
.RI ( "<qr_type> *a_qrelm" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.PP
.I void
.br
.B qr_meld
.RI ( "<qr_type> *a_qr_a" ", " "<qr_type> *a_qr_b" ", "
.IR "<field_name> a_field" )
.PP
.I void
.br
.B qr_split
.RI ( "<qr_type> *a_qr_a" ", " "<qr_type> *a_qr_b" ", "
.IR "<field_name> a_field" )
.PP
.I void
.br
.B qr_remove
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.PP
.B qr_foreach
.RI ( "<qr_type> *a_var" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.PP
.B qr_foreach_reverse
.RI ( "<qr_type> *a_var" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.SS Debugging (dbg) symbols
None.
.SH DESCRIPTION
The \fBqr\fR macros implement operations on a ring.  The type of the ring
elements and which field of the elements to use are determined by arguments that
are passed into the macros.  The macros are optimized for speed and code size,
which means that there is minimal error checking built in.  As a result, care
must be taken to assure that these macros are used as intended, or strange
things can happen.
.SH USAGE
.SS Data structures
.B qr
.RI ( "<qr_type> a_type" )
.RS
Input(s):
.RS
.IR a_type :
.RS
Data type for the \fBqr\fR.
.RE
.RE
Output(s):
.RS
A data structure that can be used as a \fBqr\fR.
.RE
Description:
.RS
Generate code for a \fBqr\fR data structure.
.RE
.RE
.PP
.SS Operations
.I void
.br
.B qr_new
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Constructor.
.RE
.RE
.PP
.I <qr_type> *
.br
.B qr_next
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to the next element in the \fBqr\fR.
.RE
.RE
Description:
.RS
Return a pointer to the next element in the \fBqr\fR.
.RE
.RE
.PP
.I <qr_type> *
.br
.B qr_prev
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to the previous element in the \fBqr\fR.
.RE
.RE
Description:
.RS
Return a pointer to the previous element in the \fBqr\fR.
.RE
.RE
.PP
.I void
.br
.B qr_before_insert
.RI ( "<qr_type> *a_qrelm" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qrelm :
.RS
Pointer to an element in a \fBqr\fR.
.RE
.IR a_qr :
.RS
Pointer to an element that is the only element in its ring.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Insert a_qr before a_qrelm.
.RE
.RE
.PP
.I void
.br
.B qr_after_insert
.RI ( "<qr_type> *a_qrelm" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qrelm :
.RS
Pointer to an element in a \fBqr\fR.
.RE
.IR a_qr :
.RS
Pointer to an element that is the only element in its ring.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Insert a_qr after a_qrelm.
.RE
.RE
.PP
.I void
.br
.B qr_meld
.RI ( "<qr_type> *a_qr_a" ", " "<qr_type> *a_qr_b" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr_a :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_qr_b :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Meld a_qr_a and a_qr_b into one ring.
.RE
.RE
.PP
.I void
.br
.B qr_split
.RI ( "<qr_type> *a_qr_a" ", " "<qr_type> *a_qr_b" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr_a :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_qr_b :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Meld a_qr_a and a_qr_b into one ring.
.RE
.RE
.PP
.I void
.br
.B qr_remove
.RI ( "<qr_type> *a_qr" ", " "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Remove a_qr from the ring.
.RE
.RE
.PP
.B qr_foreach
.RI ( "<qr_type> *a_var" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_var :
.RS
The name of a temporary variable to use for iteration.
.RE
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Iterate through the \fBqr\fR, storing a pointer to each element in a_var along
the way.
.RE
.RE
.PP
.B qr_foreach_reverse
.RI ( "<qr_type> *a_var" ", " "<qr_type> *a_qr" ", "
.IR "<field_name> a_field" )
.RS
Input(s):
.RS
.IR a_var :
.RS
The name of a temporary variable to use for iteration.
.RE
.IR a_qr :
.RS
Pointer to a \fBqr\fR.
.RE
.IR a_field :
.RS
Field within the \fBqr\fR elements to use.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Iterate through the \fBqr\fR in the reverse direction, storing a pointer to each
element in a_var along the way.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

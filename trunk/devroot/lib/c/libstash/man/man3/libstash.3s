.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash 3s "libstash, version <Version>"
.Nm libstash
.hy 1
.SH NAME
libstash - Library of algorithms and data structures designed for transaction
processing.
.SH SYNOPSIS
cc
.I file
-lstash -lpthread
.br
cc -g -D_LIBSTASH_DEBUG
.I file
-lstash_d -lpthread
.br
cc -pg
.I file
-lstash_p -lpthread

\fB#include <libstash/libstash.h>\fR

.SS General
.I cw_bool_t
.br
.B libstash_init
.RI ( void )

.I void
.br
.B libstash_shutdown
.RI ( void )

.SS Preprocessor macros
.I void *
.br
.B _cw_malloc
.RI ( "size_t a_size" )

.I void *
.br
.B _cw_calloc
.RI ( "size_t a_number" ", " "size_t a_size" )

.I void *
.br
.B _cw_realloc
.RI ( "void * a_ptr" ", " "size_t a_size" )

.I void *
.br
.B _cw_free
.RI ( "void * a_ptr" )

.I void
.br
.B _cw_assert
.RI ( "<expression>" )

.I void
.br
.B _cw_check_ptr
.RI ( "void * a_ptr" )

.I void
.br
.B _cw_marker
.RI ( "const char * a_str" )

.I void
.br
.B _cw_error
.RI ( "const char * a_str" )

.I cw_uint64_t
.br
.B _cw_ntohq
.RI ( "cw_uint64_t a_val" )

.I cw_uint64_t
.br
.B _cw_htonq
.RI ( "cw_uint64_t a_val" )

.SH DESCRIPTION
The \fBlibstash\fR library defines a number of algorithms and data structures
that are useful for many purposes, but the library specifically targets the
needs of transaction processing.  The main artifact of this focus is that many
classes use 64 bit variables in places where most applications would work fine
with 32 bit variables.

\fBlibstash\fR is designed to run on *nix platforms, and is known to work on
FreeBSD, Linux, and Solaris.  The \fBpthreads\fR library is required for the
multi-threaded versions of \fBlibstash\fR.

.SH USAGE
Detailed usage of the various available classes is discussed in detail in other
man pages.  Regardless of what classes are used, at least the following minimal
shell of C code should be used.

.RS
#include <libstash/libstash.h>

int
.br
main()
.br
{
  libstash_init();

  /* Do stuff. */

  libstash_shutdown();
  return 0;
.br
}
.RE

Although nothing will fatally break if \fBlibstash_init\fR() is not called, a
number of things will work better.  This is especially true of the debugging
versions of the library, since a number of debugging aids are not active unless
the library is initialized.

.I cw_bool_t
.br
.B libstash_init
.RI ( void )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Memory allocation error.
.RE
.RE
Description:
.RS
Initialize various global variables.  In particular, initialize cw_g_mem,
cw_g_dbg, and cw_g_out.
.RE
.RE

.I void
.br
.B libstash_shutdown
.RI ( void )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Clean up the global variables that are initialized by \fBlibstash_init\fR().
.RE
.RE

.I void *
.br
.B _cw_malloc
.RI ( "size_t a_size" )
.RS
Input(s):
.RS
.IR a_size :
.RS
Size of memory block desired.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a memory block, or NULL.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBmem_malloc\fR() wrapper.  Return a pointer to a newly allocated block of
memory of size \fIi_size\fR.
.RE
.RE

.I void *
.br
.B _cw_calloc
.RI ( "size_t a_number" ", " "size_t a_size" )
.RS
Input(s):
.RS
.IR a_number :
.RS
Number of elements.
.RE
.IR a_size :
.RS
Size of each element.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a memory block, or NULL.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBmem_calloc\fR() wrapper.  Return a pointer to a newly allocated array of
\fIa_number\fR items, where each item is \fIa_size\fR bytes.
.RE
.RE

.I void *
.br
.B _cw_realloc
.RI ( "void * a_ptr" ", " "size_t a_size" )
.RS
Input(s):
.RS
.IR a_ptr :
.RS
Pointer to memory block to be reallocated.
.RE
.IR a_size :
.RS
Size of memory block desired.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a memory block, or NULL.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
\fBmem_realloc\fR() wrapper.  Return a pointer to a block of memory with up to
\fIa_size\fR bytes of \fIa_ptr\fR's data preserved.  Use the space at
\fIa_ptr\fR if possible.
.RE
.RE

.I void *
.br
.B _cw_free
.RI ( "void * a_ptr" )
.RS
Input(s):
.RS
.IR a_ptr :
.RS
Pointer to a memory block.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
\fBmem_free\fR() wrapper.  Free the memory block pointed to by \fIa_ptr\fR.
.RE
.RE

.I void
.br
.B _cw_assert
.RI ( "<expression>" )
.RS
Input(s):
.RS
.IR <expression> :
.RS
A C language expression that evaluates to zero or non-zero.
.RE
.RE
Output(s):
.RS
Possible error message printed to \fIcw_g_out\fR.
.RE
Description:
.RS
If \fI<expression>\fR evaluates to zero, print an error message to
\fIcw_g_out\fR and \fIabort\fR().

Note: This macro is optimized out of the non-debug versions of the library.
.RE
.RE

.I void
.br
.B _cw_check_ptr
.RI ( "void * a_ptr" )
.RS
Input(s):
.RS
.IR a_ptr :
.RS
Pointer.
.RE
.RE
Output(s):
.RS
Possible error message printed to \fIcw_g_out\fR.
.RE
Description:
.RS
if \fIa_ptr\fR is NULL, print an error message to \fIcw_g_out\fR and
\fIabort\fR().

Note: This macro is optimized out of the non-debug versions of the library.
.RE
.RE

.I void
.br
.B _cw_marker
.RI ( "const char * a_str" )
.RS
Input(s):
.RS
.IR a_str :
.RS
Pointer to a NULL-terminated character array.
.RE
.RE
Output(s):
.RS
Contents of \fIa_str\fR printed to \fIcw_g_out\fR.
.RE
Description:
.RS
Print the contents of \fIa_str\fR to \fIcw_g_out\fR.
.RE
.RE

.I void
.br
.B _cw_error
.RI ( "const char * a_str" )
.RS
Input(s):
.RS
.IR a_str :
.RS
Pointer to a NULL-terminated character array.
.RE
.RE
Output(s):
.RS
Contents of \fIa_str\fR printed to \fIcw_g_out\fR.
.RE
Description:
.RS
Print the contents of \fIa_str\fR to \fIcw_g_out\fR.
.RE
.RE

.I cw_uint64_t
.br
.B _cw_ntohq
.RI ( "cw_uint64_t a_val" )
.RS
Input(s):
.RS
.IR a_val :
.RS
64 bit integer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
64 bit integer.
.RE
.RE
Description:
.RS
Convert \fIa_val\fR from network byte order to host byte order and return the
result.
.RE
.RE

.I cw_uint64_t
.br
.B _cw_htonq
.RI ( "cw_uint64_t a_val" )
.RS
Input(s):
.RS
.IR a_val :
.RS
64 bit integer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
64 bit integer.
.RE
.RE
Description:
.RS
Convert \fIa_val\fR from host byte order to network byte order and return the
result.
.RE
.RE

\"  .SH RETURN VALUES
\"  .SH EXIT STATUS
\"  .SH FILES
.SH CODE STRUCTURE
.SS Object-oriented C
The algorithms and data structures in \fBlibstash\fR are architected in an
object-oriented manner, though all the actual code is C.  Since C doesn't
directly support object-oriented design, a number of stylistic conventions
are used.

Each class is referred to by a name, which is used as a prefix for all member
methods.  For example, dynamic chained hashing is implemented by the \fBdch\fR
class, and member methods of \fBdch\fR are named \fBdch_new()\fR,
\fBdch_delete()\fR, \fBdch_insert()\fR, etc.

.SS Variable types
\fBlibstash\fR is careful to use the following data types rather than the
built-in types (other than when using system library functions and string
pointers (char *)) to allow easy porting and explicit knowledge of variable
sizes.

.TS
center box linesize(6) tab(@);
cb s s.
C data types
_
.T&
lb | rb | lb.
 Type name@sizeof@Description
_
.T&
l | r | l.
 cw_bool_t@4@Boolean, either FALSE or TRUE.
 cw_sint8_t@1@Signed 8 bit variable.  
 cw_uint8_t@1@Unsigned 8 bit variable.
 cw_sint16_t@2@Signed 16 bit variable.  
 cw_uint16_t@2@Unsigned 16 bit variable.
 cw_sint32_t@4@Signed 32 bit variable.  
 cw_uint32_t@4@Unsigned 32 bit variable.
 cw_sint64_t@8@Signed 64 bit variable.  
 cw_uint64_t@8@Unsigned 64 bit variable.
.TE

.SS Object instantiation
Many classes provide a means for external memory allocation, and in some cases
for automatic cleanup during destruction.  This feature enables improved
performance and cache locality, but if misunderstood, can result in mysterious
memory corruption and leaks.

.SS Variable naming
Though the variable naming conventions used in \fBlibstash\fR are far short of
what Hungarian and other naming conventions attempt, there are a few to take
note of.

.TS
center box linesize(6) tab(@);
cb s s.
Variable prefixes
_
.T&
lb | lb.
 Prefix@Description
_
.T&
l | l.
 cw_g_@Global variable.
 a_@Function argument.
 t_@Temporary variable.
.TE

.SH SEE ALSO
\"  .TS
.TS H
center box linesize(6) tab(@);
cb s s.
Classes built into libstash
_
.T&
lb | lb | lb.
 Name@Man page@Description
_
.T&
l | l | l.
 bhp@libstash_bhp(3s)@Binomial heap.
 bhpi@libstash_bhp(3s)@Binomial heap node.
 buf@libstash_buf(3s)@Extensible buffer.
 bufc@libstash_buf(3s)@Reference-counted memory buffer.
 ch@libstash_ch(3s)@Chained hashing.
 cnd@libstash_cnd(3s)@Condition.
 dbg@libstash_dbg(3s)@Runtime debugging symbol lookup.
 dch@libstash_dch(3s)@Dynamic chained hashing.
 mem@libstash_mem(3s)@Memory allocation (malloc(3) wrapper).
 mq@libstash_mq(3s)@Message queue.
 mtx@libstash_mtx(3s)@Mutex.
 out@libstash_out(3s)@Output (printf(3) replacement).
 pezz@libstash_pezz(3s)@Cached memory allocation.
 res@libstash_res(3s)@Resource (name/value pairs).
 ring@libstash_ring(3s)@Ring (similar uses as for lists).
 rwl@libstash_rwl(3s)@Read/write lock.
 sem@libstash_sem(3s)@Semaphore.
 thd@libstash_thd(3s)@Thread.
 treen@libstash_treen(3s)@Arbitrary tree.
 tsd@libstash_tsd(3s)@Thread-specific data.
.TE

\"  .SH DIAGNOSTICS
\"  .SH BUGS
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

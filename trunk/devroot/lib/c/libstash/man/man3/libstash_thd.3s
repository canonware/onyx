.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_thd 3s "libstash, version <Version>"
.hy 1
.SH NAME
thd - Thread.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.PP
.I cw_thd_t *
.br
.B thd_new
.RI ( "cw_thd_t *a_thd" ", " "void *(*a_start_func)(void *)" ", " 
.IR "void *a_arg" )
.PP
.I void
.br
.B thd_delete
.RI ( "cw_thd_t *a_thd" )
.PP
.I void *
.br
.B thd_join
.RI ( "cw_thd_t *a_thd" )
.PP
.I cw_thd_t *
.br
.B thd_self
.RI ( "void" )
.PP
.I void
.br
.B thd_yield
.RI ( "void" )
.PP
.I int
.br
.B thd_sigmask
.RI ( "int a_action" ", " "sigset_t *a_sigset" ", " "sigset_t *a_old_sigset" )
.PP
.I void
.br
.B thd_crit_enter
.RI ( "void" )
.PP
.I void
.br
.B thd_crit_leave
.RI ( "void" )
.PP
.I void
.br
.B thd_single_enter
.RI ( "void" )
.PP
.I void
.br
.B thd_single_leave
.RI ( "void" )
.PP
.I void
.br
.B thd_suspend
.RI ( "cw_thd_t *a_thd" )
.PP
.I cw_bool_t
.br
.B thd_trysuspend
.RI ( "cw_thd_t *a_thd" )
.PP
.I void
.br
.B thd_resume
.RI ( "cw_thd_t *a_thd" )
.SS Debugging (dbg) symbols
None.
.SH DESCRIPTION
\fBthd\fR implements a thread creation and deletion interface.
.SH USAGE
.I cw_thd_t *
.br
.B thd_new
.RI ( "cw_thd_t *a_thd" ", " "void *(*a_start_func)(void *)" ", " 
.IR "void *a_arg" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to space for a thd.
.RE
.IR a_start_func :
.RS
Pointer to a start function.
.RE
.IR a_arg :
.RS
Argument passed to a_start_func().
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a thd.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor (creates new thread).
.RE
.RE
.PP
.I void
.br
.B thd_delete
.RI ( "cw_thd_t *a_thd" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to a thd.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE
.PP
.I void *
.br
.B thd_join
.RI ( "cw_thd_t *a_thd" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to a thd.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Return value from thread entry function.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Join (wait for) the thread associated with a_thd.
.RE
.RE
.PP
.I cw_thd_t *
.br
.B thd_self
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to the calling thread's thd structure.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return a pointer to the thd structure that corresponds to the calling thread.
.RE
.RE
.PP
.I void
.br
.B thd_yield
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Give up the rest of this thread's time slice.
.RE
.RE
.PP
.I int
.br
.B thd_sigmask
.RI ( "int a_action" ", " "sigset_t *a_sigset" ", " "sigset_t *a_old_sigset" )
.RS
Input(s):
.RS
.IR a_action :
.RS
SIG_BLOCK: Block signals in a_sigset.
.br
SIG_UNBLOCK: Unblock signals in a_sigset.
.br
SIG_SETMASK: Set signal mask to a_sigset.
.RE
.IR a_sigset :
.RS
Pointer to a signal set (sigset_t *).
.RE
.IR a_old_sigset :
.RS
non-NULL: Pointer space to store the old signal mask.
.br
NULL: Ignored.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Always zero, unless the arguments are invalid.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Set the current thread's signal mask.
.RE
.RE
.PP
.I void
.br
.B thd_crit_enter
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Enter a critical region where the calling thread may not be suspended.
.RE
.RE
.PP
.I void
.br
.B thd_crit_leave
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Leave a critical section; the calling thread may once again be suspended.
.RE
.RE
.PP
.I void
.br
.B thd_single_enter
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Enter a critical region where all other threads must be suspended.
.RE
.RE
.PP
.I void
.br
.B thd_single_leave
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Leave a critical section where all other threads must be suspended.
All threads that were suspended in \fBthd_single_enter\fR() are resumed.
.RE
.RE
.PP
.I void
.br
.B thd_suspend
.RI ( "cw_thd_t *a_thd" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to a thd.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Suspend a_thd.
.RE
.RE
.PP
.I cw_bool_t
.br
.B thd_trysuspend
.RI ( "cw_thd_t *a_thd" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to a thd.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Failure.
.RE
.RE
Description:
.RS
Try to suspend a_thd, but fail if a_thd is in a critical section.
.RE
.RE
.PP
.I void
.br
.B thd_resume
.RI ( "cw_thd_t *a_thd" )
.RS
Input(s):
.RS
.IR a_thd :
.RS
Pointer to a thd.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Resume (make runnable) a_thd.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

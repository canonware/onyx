%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% libonyx portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{The libonyx library}
The \libname{libonyx} library implements an embeddable \htmlref{onyx}{onyxlang}
interpreter.  \libname{libonyx} is designed to allow multiple interpreter
instances in the same program, though since \htmlref{onyx}{onyxlang} is a
multi-threaded language, in most cases it makes more sense to use a single
interpreter instance with multiple threads.

The \htmlref{onyx}{onyxlang} language is described elsewhere in this manual, so
this chapter documents the C API with as little information about the
\htmlref{onyx}{onyxlang} language as possible.

A minimal program that runs the onyx interpreter interactively looks like:
\begin{verbatim}
#include <libonyx/libonyx.h>

int
main(int argc, char **argv, char **envp)
{
        cw_nx_t         nx;
        cw_nxo_t        thread, *nxo;

        /* Initialize libstash and the onyx interpreter. */
        libstash_init();
        nx_new(&nx, NULL, argc, argv, envp);

        /* Create a thread. */
        nxo_thread_new(&thread, &nx);

        /* Set up stdin for evaluation. */
        nxo = nxo_stack_push(nxo_thread_ostack_get(&thread));
        nxo_dup(nxo, nxo_thread_stdin_get(&thread));
        nxo_attr_set(nxo, NXOA_EXECUTABLE);

        /* Start the thread. */
        nxo_thread_start(&thread);

        /* Clean up. */
        nx_delete(&nx);
        libstash_shutdown();
        return 0;
}
\end{verbatim}

In most cases, an application will need to implement additional onyx operators
(and make them accessible from within the onyx interpreter) in order to make the
application accessible/controllable from the onyx interpreter.  If the
application user interface is to be interaction with the onyx interpreter, then
little else needs to be done.

\section{Compilation}
\begin{description}
\item[Normal: ] cc \filename{file} -lonyx -lstash -lpthread
\item[Debug: ] cc -g -D\_CW\_DBG \filename{file}
-lonyx\_d -lstash\_d -lpthread
\item[Profile: ] cc -pg \filename{file} -lonyx\_p -lstash\_p -lpthread
\end{description}

\section{Threads}
\libname{libonyx} encapsulates each interpreter instance in an \classname{nx}
object.  An \classname{nx} object supports running multiple concurrent threads.
Each thread context is encapsulated by an \classname{nxo} thread object.

In general, each process thread should execute in its own \classname{nxo} thread
object context, though the only explicit restriction placed on \classname{nxo}
thread object operations is that only one thread can be executing in an
\classname{nxo} thread object context at a time.  In other words, the
\classname{nxo} thread class does not synchronize access to its internals, since
there is normally no reason for multiple threads to execute in the same
\classname{nxo} thread object context.

\section{Garbage Collection}
Garbage collection is done asynchronously by a separate thread that does nothing
but garbage collection.  Since there can be arbitrary threads executing in the
interpreter concurrently, there are two ways to implement safe garbage
collection: concurrent or atomic.  \libname{libonyx} uses atomic garbage
collection, which means that the garbage collector thread suspends all other
threads that are created via \cfunc{\htmlref{thd\_new}{thd_new}}{..., TRUE}
during its mark phase.  In order for this to work, the garbage collector must
not do any locking while the other threads are suspended, or else there is a
high probability of eventual deadlock.  \libname{libonyx} itself meets these
criteria, as must any C extensions to the interpreter that are executed by the
garbage collector thread.

\section{Exceptions}
\libname{libonyx} reserves \htmlref{xep}{xep} exception numbers 128 to 255 and
defines the following exceptions:
\begin{description}
\label{_CW_ONYXX_EXIT}
\item[\cppdef{\_CW\_ONYXX\_EXIT}: ]
	Internal use, for the exit operator.
\label{_CW_ONYXX_STOP}
\item[\cppdef{\_CW\_ONYXX\_STOP}: ]
	Internal use, for the stop operator.
\label{_CW_ONYXX_QUIT}
\item[\cppdef{\_CW\_ONYXX\_QUIT}: ]
	Internal use, for the quit operator, caught by the start operator.
\end{description}

\section{Integration issues}
\subsection{Thread creation}
\libname{libonyx} relies on \libname{libstash} for a number of features.  In
most cases, \libname{libstash} quietly does its job behind the scenes,
regardless of whether the application directly uses its functionality.  However,
\libname{libonyx}'s garbage collector uses the \htmlref{\classname{thd}}{thd}
class to suspend and resume all other threads during the mark phase of atomic
collection.  For this to work, all threads that have any contact with
\libname{libonyx} must be created as suspendible threads using the
\htmlref{\classname{thd}}{thd} class.

This can cause integration headaches for existing threaded applications, but
there is no other portable way to suspend and resume threads.  The only
alternative is to modify \libname{libonyx} to use synchronous garbage
collection, but this is only safe for applications that have a single thread
executing in the interpreter.  In other words, converting to synchronous garbage
collection requires stripping significant functionality out of
\libname{libonyx}.  If you decide that you need to go this route, the author
would be interested in hearing from you; the work involved in implementing
synchronous garbage collection seems not worth the effort, considering the low
likelihood of anyone ever needing to use \libname{libonyx} in such a
configuration.

\subsection{Restarted interrupted system calls}
As mentioned above, \libname{libonyx} uses thread suspension and resumption to
implement garbage collection.  This has the side-effect of making restarted
interrupted system calls a real possibility.  However, the operating system will
return with a partial result if the system call was partially complete when it
was interrupted.  In practice, what this means is that short reads and writes
are possible where they otherwise wouldn't happen, so the application should not
make any assumptions about interruptible system calls always completing with a
full result.  See the \htmlref{\classname{thd}}{thd} class documentation for
more details.

\section{Guidlines for writing extensions}
When embedding \libname{libonyx} in an application, it is usually desireable to
add some operators so that the interpreter can interact with the rest of the
application.  The \libname{libonyx} source code contains hundreds of operators
that can be used as examples when writing new operators.  However, there are
some very important rules that operators must follow, some of which may not be
obvious when reading the code.

\begin{itemize}
\item{Manually managed (\cfunc{malloc}{}/\cfunc{free}{}) memory should not be
allocated unless the code is very careful.  If a function recurses into the
interpreter (this includes calls to
\htmlref{\cfunc{nxo\_thread\_error}{}}{nxo_thread_error}), there is the very
real possibility that control will never return to the operator due to an
exception.  Code must either catch all expceptions and clean up allocations, or
not recurse into the interpreter.}

\item{Composite objects should never be allocated on the C stack.  The garbage
collector has no knowledge of such objects, so if the only reference to an
object is on the C stack, the object may be collected, which will lead to
unpredictable program behavior.  Instead of allocating objects on the C stack,
use tstack, available via
\htmlref{\cfunc{nxo\_thread\_tstack\_get}{}}{nxo_thread_tstack_get}, which is a
per-thread stack that the garbage collector scans.}

\item{For an object to be safe from garbage collection, there must always be at
least one reference to it inside the interpreter.  So, if C code obtains a
pointer to a composite object, then destroys the last known internal onyx
reference (pops it off a stack, redefines it in a dict, replaces an element of
an array, etc.), the pointer is no longer safe to use.  The \libname{libonyx}
API is structured such that it is invalid to do such a thing, for this reason.}
\end{itemize}

Since onyx type checking is dynamic, it is the responsibility of the operators
to assure objects are the correct type before calling any of the type-specific
\cfunc{nxo\_*}{} functions.  Failure to do so will result in unpredictable
behavior and likely crashes.

\section{API}
\begin{capi}
\label{_cw_onyx_code}
\index{_cw_onyx_code@\cppmacro{\_cw\_onyx\_code}{}}
\citem{\cppmacro[void]{\_cw\_onyx\_code}{cw\_nxo\_t *a\_thread, const char
*a\_code}}
	\begin{capilist}
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_thread: ]
			Pointer to a thread \classname{nxo}.
		\item[a\_code: ]
			A "-delimited string constant.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] Depends on actions of a\_code.
	\item[Description: ]
		Convenience macro for static embedded \htmlref{onyx}{onyxlang}
		code.
	\end{capilist}
\end{capi}

\section{Classes}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nx}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxa}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxn}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_array}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_boolean}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_condition}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_dict}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_file}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_fino}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_hook}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_integer}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_mark}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_mutex}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_name}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_no}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_null}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_operator}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_pmark}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_stack}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_string}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/nxo_thread}

\section{Dictionaries}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/gcdict}
\input{@abs_srcdir@/lib/c/libonyx/doc/latex/systemdict}

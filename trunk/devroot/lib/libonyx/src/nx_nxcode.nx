%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nx_nxcode_gen.nx to produce a more compact embedded
% version in nx_nxcode.c.  Due to bootstrapping issues, this cannot safely be
% done automatically as part of the build process.  In order to make changes to
% this file take effect, either type:
%
%   cook bootstrap
%
% or
%
%   cat nx_nxcode.nx | onyx nx_nxcode_gen.nx > nx_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

systemdict begin

%
% sprintsdict implements syntactic printing to strings for every type.
%
/sprintsdict <
	/arraytype {
		% %array %depth
		dup 0 gt {
			1 index dup echeck {
				pop
				`_{'
			}{
			xcheck {
				`{'
			}{
				`['
			} ifelse
			} ifelse

			% %array %depth %accum
			2 index length 1 gt {
				% %array %depth %accum
				0 1 4 index length 2 sub {
					% %array %depth %accum %i
					3 index exch get
					2 index 1 sub
					% %array %depth %accum %el %rdepth
					1 index type sprintsdict exch get eval
					catenate
					% %array %depth %accum %el %rdepth
				` ' catenate
				} for
			} if
			% %array %depth %accum

			2 index length 0 gt {
				2 index dup length 1 sub get
				2 index 1 sub
				% %array %depth %accum %el %rdepth
				1 index type sprintsdict exch get eval
				catenate
			} if
			% %array %depth %accum

			exch pop
			% %array %accum
			exch dup echeck {
				pop
				`}_'
			}{
			xcheck {
				`}'
			}{
				`]'
			} ifelse
			} ifelse
			catenate
			% %accum
		}{
			pop pop
			`-array-'
		} ifelse
	}
	/booleantype {
		pop
		cvs
	}
	/conditiontype {
		pop pop
		`-condition-'
	}
	/dicttype {
		% %dict %depth
		dup 0 gt {
			% Update recursion depth.
			1 sub

			0
			`<'

			% %dict %rdepth %i %accum
			3 index {
				% %dict %rdepth %i %accum %key %value
				exch 4 index
				% %dict %rdepth %i %accum %value %key %rdepth
				1 index type sprintsdict exch get eval
				` ' catenate
				% %dict %rdepth %accum %i %value %keystr
				exch 4 index
				% %dict %rdepth %i %accum %keystr %value %rdepth
				1 index type sprintsdict exch get eval
				% %dict %rdepth %i %accum %keystr %valstr
				catenate catenate
				% %dict %rdepth %i %accum

				% Update counter.
				exch 1 add dup 4 index length lt {
					% %dict %rdepth %accum %i
					exch
					` ' catenate
					% %dict %rdepth %i %accum
				}{
					% Last element.
					exch
					% %dict %rdepth %accum
				} ifelse
			} foreach
			% %dict %rdepth %i %accum

			4 1 roll pop pop pop
			% %accum
			`>'
			catenate
			% %accum
		}{
			pop pop
			`-dict-'
		} ifelse
	}
	/filetype {
		pop pop
		`-file-'
	}
	/finotype {
		pop pop
		`-fino-'
	}
	/hooktype {
		% %hook %depth
		exch hooktag
		% %depth %tag
		dup type /nulltype ne {
			exch 1 sub
			% %tag %rdepth
			1 index type sprintsdict exch get eval
			% %tagstr
			`=' exch catenate
			`=' catenate
		}{
			pop pop
			`-hook-'
		} ifelse
	}
	/integertype {
		pop
		cvs
	}
	/marktype {
		pop pop
		`-mark-'
	}
	/mutextype {
		pop pop
		`-mutex-'
	}
	/nametype {
		pop
		dup cvs
		exch xcheck not {
			`/' exch catenate
		} if
	}
	/nulltype {
		pop pop
		`null'
	}
	/operatortype {
		pop
		cvs
		dup `-operator-' ne {
			`--' dup 3 1 roll
			catenate catenate
		} if
	}
	/pmarktype {
		pop pop
		`-pmark-'
	}
	/realtype {
	    pop
	    cvs
	}
	/stacktype {
		% %stack %depth
		dup 0 gt {
			`('

			% %stack %depth %accum
			2 index scount 1 gt {
				% %stack %depth %accum
				2 index scount 1 sub -1 1 {
					% %stack %depth %accum %i
					3 index dup 3 2 roll sindex spop
					2 index 1 sub
					% %stack %depth %accum %el %rdepth
					1 index type sprintsdict exch get eval
					catenate
					% %stack %depth %accum %el %rdepth
				` ' catenate
				} for
			} if
			% %stack %depth %accum

			2 index scount 0 gt {
				2 index dup sdup spop
				2 index 1 sub
				% %stack %depth %accum %el %rdepth
				1 index type sprintsdict exch get eval
				catenate
			} if
			% %stack %depth %accum

			3 1 roll pop pop
			% %accum
			`)'
			catenate
			% %accum
		}{
			pop pop
			`-stack-'
		} ifelse
	}
	/stringtype {
		pop
		cvs
	}
	/threadtype {
		pop pop
		`-thread-'
	}
> def

% <object> <depth> sprints <string>
/sprints {
	1 index type sprintsdict exch get eval
} def

/sprint {
	sprints print
	`\n' print flush
} def

%
% outputsdict implements formatted output to strings for every type.
%
/outputsdict <
	/integertype {
		% %int %flags

		% Get the base.
		dup /b known {
			dup /b get
		}{
			10
		} ifelse
		% %int %flags %base

		2 index exch cvrs
		% %int %flags %str

		% Prepend the sign if necessary.
		1 index /s known {
			1 index /s get /+ eq {
				2 index 0 ge {
					`+' exch catenate
				} if
			} if
		} if
		% %int %flags %str
		3 2 roll pop
		% %flags %str
		exch
		% %str %flags
		outputsdict /stringtype get eval
		% %str
	}
	/realtype {
	    % %real %flags

	    % Determine precision past decimal point.
	    dup /d known {
		dup /d get
	    }{
		6
	    } ifelse
	    % %real %flags %precision
	    
	    % Determine whether to use decimal or exponential notation.
	    1 index /e known {
		1 index /e get
	    }{
		false
	    } ifelse
	    % %real %flags %precision %exp?

	    3 index 3 1 roll
	    % %real %flags %real %precision %exp?
	    {
		% Use exponential notation.
		cves
	    }{
		% Use decimal notation.
		cvds
	    } ifelse
	    % %real %flags %str

	    % Prepend the sign if necessary.
	    1 index /s known {
		1 index /s get /+ eq {
		    2 index 0 ge {
			`+' exch catenate
		    } if
		} if
	    } if
	    % %real %flags %str
	    3 2 roll pop exch
	    % %str %flags

	    outputsdict /stringtype get eval
	    % %str
	}
	% Temporarily define.
	/_s {
		% Check for /w flag.  /w takes precedence over /n.
		dup /w known {
			% Get padding character.
			dup /p known {
				dup /p get
			}{
				` '
			} ifelse
			% %str %flags %pad

			1 index /w get
			% %str %flags %pad %width
			3 index length
			% %str %flags %pad %width %len

			dup 2 index le {
				% Pad string.
				% %str %flags %pad %width %len

				1 index string
				% %str %flags %pad %width %len %pstr

				% Fill %pstr with %pad.
				0 1 4 index 1 sub {
					1 index exch 5 index putinterval
				} for
				% %str %flags %pad %width %len %pstr
				4 3 roll pop
				% %str %flags %width %len %pstr

				% Get the justification.
				3 index /j known {
					3 index /j get
				}{
					/r
				} ifelse
				% %str %flags %width %len %pstr %just

				dup /r eq {
					pop
					% Right justify.
					% %str %flags %width %len %pstr
					3 1 roll sub
				}{
				/l eq {
					% Left justify.
					% %str %flags %width %len %pstr
					3 1 roll pop pop
					0
				}{
					% Center.
					% %str %flags %width %len %pstr
					3 1 roll sub 2 div
				} ifelse
				} ifelse
				% %str %flags %pstr %offset

				1 index exch
				% %str %flags %pstr %pstr %offset
				5 4 roll
				% %flags %pstr %pstr %offset %str
				putinterval
				% %flags %pstr
				exch
				% %pstr %flags
			}{
				% No padding necessary.
				pop pop pop
			} ifelse
			% %str %flags
		}{
			% %str %flags
			dup /n known {
				% Truncate the string if it is too long.
				1 index length
				1 index /n get
				% %str %flags %len %max
				dup 2 index lt {
					% Truncate.
					exch pop
					dup string
					% %str %flags %max %nstr
					dup
					% %str %flags %max %nstr %nstr
					5 4 roll
					% %flags %max %nstr %nstr %str
					4 3 roll
					% %flags %nstr %nstr %str %max
					0 exch getinterval
					% %flags %nstr %nstr %substr
					0 exch putinterval
					% %flags %nstr
					exch
				}{
					pop pop
				} ifelse
				% %nstr %flags
			} if
			% %str %flags
		} ifelse
		% %str %flags

		pop
		% %str
	} def
	/stringtype /_s load

	% Most types can be handled identically.  The following code uses the
	% same procedure body for all of those types.
	%
	% The following block of code looks scary because it avoids deferred
	% execution in order to "bind" things correctly (we can't use immediate
	% evaluation in this file).
	[
		% %object %flags

		% Get recursion depth.
		/dup cvx /r /known cvx [
			/dup cvx /r /get cvx
		] cvx [
			1
		] cvx /ifelse cvx
		% %object %flags %rdepth

		3 2 /roll cvx /exch cvx
		% %flags %object %rdepth
		/sprints cvx /exch cvx
		% %str %flags
		/_s load /eval cvx
		% %str
	] cvx bind
	[
		/arraytype
		/booleantype
		/conditiontype
		/dicttype
		/filetype
		/finotype
		/hooktype
		/marktype
		/mutextype
		/nametype
		/nulltype
		/operatortype
		/pmarktype
		/stacktype
		/threadtype
	]{
		% %proc %name
		exch dup
		% %name %proc %proc
	} foreach
	% Get rid of the extra copy of %proc.
	pop

	% Now that we're done using _s, undef it.
	currentdict /_s undef
> def

%
% Formatted output to a string.  Supported flags:
%
% All types:
%
% /n : maximum width
%    : %integer
% /w : minimum width
%    : %integer
% /j : justification
%    : /l, /c, /r
% /p : padding character
%    : `?'
% /r : recursion depth
%    : 0..n
%
% Integers only:
%
% /b : base
%    : 2..36
% /s : sign
%    : /+ /-
%
% Reals only:
%
% /d : digits of precision past decimal
%    : %integer (default 6)
% /e : exponential notation
%    : %boolean (default false)
%
% %obj %flags outputs %string
/outputs {
	dup type /dicttype ne {
		/typecheck throw
	} if
	1 index type
	% %obj %flags %type
	outputsdict exch get eval
} def

%obj %flags output -
/output {
	outputs print
} def

% - product <string>
/product `Canonware Onyx' def

/pstack {
	ostack {
		1 sprint
	} foreach
	flush
} def

%
% <string> <pattern> search <post> <pattern> <pre> true
%                    search <string> false
%
/search {
	% Make sure the arguments are strings.
	% Pattern.
	dup type /stringtype ne {
		/typecheck throw
	} if
	% String.
	1 index type /stringtype ne {
		/typecheck throw
	} if

	% Make sure substring isn't longer than string.
	dup length 2 index length le {
		% Use a nested looping algorithm.  The outer loop advances the
		% offset <s_i> at which to start the search in the string <s>,
		% and the inner loop compares byte by byte with the pattern <p>.
		%
		% Take care not to cause a rangecheck error.
		0 1 3 index length 3 index length sub {
			% <s> <p> <s_i>

			% Create a substring <s_sub> of <s> that is the same
			% length as <p>, starting at <s_i>.
			dup 3 index exch 3 index length getinterval

			% <s> <p> <s_i> <s_sub>
			dup length 1 sub 0 1
			3 2 roll
			{
				% <s> <p> <s_i> <s_sub> <offset>
				dup 2 index exch get
				exch 4 index exch get
				ne {
					% Not equal.  Exit the inner loop.
					false exit
				} if
			} for

			% Check to see if the substring match failed.
			dup type /booleantype eq {
				% <s> <p> <s_i> <s_sub> false
				% Failure.  Clean up.
				pop pop pop
			}{
				% <s> <p> <s_i> <s_sub>
				% Success.
				3 2 roll pop
				% <s> <s_i> <s_sub>

				% Contstruct pre string <s_pre>.
				3 1 roll dup 2 index exch 0 exch
				% <s_sub> <s> <s_i> <s> 0 <s_i>
				getinterval
				% <s_sub> <s> <s_i> <s_pre>
				3 1 roll
				% <s_sub> <s_pre> <s> <s_i>

				% Contstruct post string <s_post>.
				3 index length add dup
				2 index length exch sub
				getinterval
				% <s_sub> <s_pre> <s_post>
				3 1 roll

				true
				% <s_post> <s_sub> <s_pre> true
				exit
			} ifelse
		} for

		% Check to see if we succeeded.  If not, set up the stack to
		% return failure.
		dup type /booleantype ne {
			% Failure.
			pop false
		} if
	}{
		% Substring is too long.
		pop false
	} ifelse
} def

% [`<path>' `<args>'...] system <exit_code>
/system {
	% Make sure argument is an array.
	dup type /arraytype ne {
		/typecheck throw
	} if
	% Make sure array is non-empty.
	dup length 0 eq {
		/rangecheck throw
	} if
	% Make sure array elements are strings.
	dup {
		{
			type /stringtype ne {
				stop
			} if
		} foreach
	} stopped {
		/typecheck throw
	} if

	fork
	dup 0 eq {
		% Child.
		systemdict begin
		/throw {1 die} def
		end
		pop exec
	}{
		% Parent.
		exch pop waitpid
	} ifelse
} def

% /errorname throw -
/throw {
	% Do some sanity checking, to try to avoid going infinitely recursive
	% in the error handling machinery.
	{
		{/errordict where {pop true}{false} ifelse}
		{/errordict load /handleerror known}
		{/errordict load /stop known}
		{/currenterror where {pop true}{false} ifelse}
	}{
		eval not {
			stderr `Onyx: Missing errordict or currenterror defs\n'
			write

			% Print stack dumps.
			stderr `ostack: ' write
			ostack 2 sprints stderr exch write

			stderr `\ndstack: ' write
			stderr dstack 2 sprints write

			stderr `\nestack: ' write
			stderr estack 2 sprints write

			stderr `\nistack: ' write
			stderr istack 2 sprints write

			stderr `\nOnyx: dieing\n' write
			1 die
		} if
	} foreach

	% Make sure the argument is a name.
	dup type /nametype ne {
		/typecheck /systemdict load /throw get eval
	} if

	/currenterror load begin

	% Set newerror to true to indicate there is an error.  It is up to the
	% application to clear this afterwards if it wants to make newerror
	% meaningful in the face of multiple errors.
	/newerror true def

	% Set errorname to the argument passed in.
	dup /errorname exch cvlit def

	% ostack.  Get rid of /errorname in the snapshot.  Ordering is important
	% to keep from polluting the snapshot.
	ostack dup spop pop /ostack exch def

	% dstack.  Don't include the top element, which is the copy of
	% currenterror that we pushed.
	/dstack dstack dup spop pop def

	% estack.  Remove this procedure from the snapshot.
	/estack estack dup spop pop def

	% istack.  Remove this procedure from the snapshot.
	/istack istack dup spop pop def

	% Push the offending object onto ostack.
	/estack load dup sdup spop
	exch
	% %object %errorname

	end % currenterror.

	% If there is an error handler for the error name, call it.  Otherwise,
	% call errordict's handleerror, then call errordict's stop.
	/errordict load
	% %object %errorname %errordict
	dup 2 index known {
		% Call error handler.
		exch get eval
	}{
		% No error handler.
		exch pop
		dup /handleerror get eval
		/stop get eval
	} ifelse
} def

% - version <string>
/version `<Version>' def

end % systemdict.

} % End deferral.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nx_nxcode_gen.nx to produce a more compact embedded
% version in nx_nxcode.c.  Due to bootstrapping issues, this cannot safely be
% done automatically as part of the build process.  In order to make changes to
% this file take effect, either type:
%
%   cook bootstrap
%
% or
%
%   cat nx_nxcode.nx | onyx nx_nxcode_gen.nx > nx_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

systemdict begin

% sprint is used by some of the procedures defined later in this file, so must
% be defined early.
%
% <object> <depth> sprint -
/sprint {
	1 index type /sprintdict load exch get eval
	`\n' print flush
} def

% - product <string>
/product `Canonware Onyx' def

/pstack {
	ostack {
		1 sprint
	} foreach
	flush
} def

%
% <string> <pattern> search <post> <pattern> <pre> true
%                    search <string> false
%
/search {
	% Make sure the arguments are strings.
	% Pattern.
	dup type /stringtype ne {
		/typecheck throw
	} if
	% String.
	1 index type /stringtype ne {
		/typecheck throw
	} if

	% Make sure substring isn't longer than string.
	dup length 2 index length le {
		% Use a nested looping algorithm.  The outer loop advances the
		% offset <s_i> at which to start the search in the string <s>,
		% and the inner loop compares byte by byte with the pattern <p>.
		%
		% Take care not to cause a rangecheck error.
		0 1 3 index length 3 index length sub {
			% <s> <p> <s_i>

			% Create a substring <s_sub> of <s> that is the same
			% length as <p>, starting at <s_i>.
			dup 3 index exch 3 index length getinterval

			% <s> <p> <s_i> <s_sub>
			dup length 1 sub 0 1
			3 2 roll
			{
				% <s> <p> <s_i> <s_sub> <offset>
				dup 2 index exch get
				exch 4 index exch get
				ne {
					% Not equal.  Exit the inner loop.
					false exit
				} if
			} for

			% Check to see if the substring match failed.
			dup type /booleantype eq {
				% <s> <p> <s_i> <s_sub> false
				% Failure.  Clean up.
				pop pop pop
			}{
				% <s> <p> <s_i> <s_sub>
				% Success.
				3 2 roll pop
				% <s> <s_i> <s_sub>

				% Contstruct pre string <s_pre>.
				3 1 roll dup 2 index exch 0 exch
				% <s_sub> <s> <s_i> <s> 0 <s_i>
				getinterval
				% <s_sub> <s> <s_i> <s_pre>
				3 1 roll
				% <s_sub> <s_pre> <s> <s_i>

				% Contstruct post string <s_post>.
				3 index length add dup
				2 index length exch sub
				getinterval
				% <s_sub> <s_pre> <s_post>
				3 1 roll

				true
				% <s_post> <s_sub> <s_pre> true
				exit
			} ifelse
		} for

		% Check to see if we succeeded.  If not, set up the stack to
		% return failure.
		dup type /booleantype ne {
			% Failure.
			pop false
		} if
	}{
		% Substring is too long.
		pop false
	} ifelse
} def

% [`<path>' `<args>'...] system <exit_code>
/system {
	fork
	dup 0 eq {
		errordict begin
		/handleerror {quit} def
		end
		pop exec
	}{
		exch pop waitpid
	} ifelse
} def

% /errorname throw -
/throw {
	% Do some sanity checking, to try to avoid going infinitely recursive
	% in the error handling machinery.
	{
		{/errordict where {pop true}{false} ifelse}
		{/errordict load /handleerror known}
		{/errordict load /stop known}
		{/currenterror where {pop true}{false} ifelse}
	}{
		eval not {
			`Onyx: Missing errordict or currenterror defs\n' print

			% Print stack dumps.
			`ostack: ' print
			ostack 2 sprint

			`dstack: ' print
			dstack 2 sprint

			`estack: ' print
			estack 2 sprint

			`istack: ' print
			istack 2 sprint

			`Onyx: dieing\n' print flush
			1 die
		} if
	} foreach

	% Make sure the argument is a name.
	dup type /nametype ne {
		/typecheck /systemdict load /throw get eval
	} if

	/currenterror load begin

	% Set newerror to true to indicate there is an error.  It is up to the
	% application to clear this afterwards if it wants to make newerror
	% meaningful in the face of multiple errors.
	/newerror true def

	% Set errorname to the argument passed in.
	dup /errorname exch cvlit def

	% ostack.  Get rid of /errorname in the snapshot.
	ostack spop pop /ostack exch def

	% dstack.  Don't include the top element, which is the copy of
	% currenterror that we pushed.
	/dstack dstack spop pop def

	% estack.  Remove this procedure from the snapshot.
	estack spop pop /estack exch def

	% istack.  Remove this procedure from the snapshot.
	istack spop pop /istack exch def

	% Push the offending object onto ostack.
	/estack load sdup spop exch pop

	end % currenterror.

	% Call the error handler.
	exch /errordict load exch get eval

	% Stop.
	/errordict load /stop get eval
} def

% - version <string>
/version `<Version>' def

end % systemdict.

} % End deferral.

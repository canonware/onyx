/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 * This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Onyx <Version = onyx>
 *
 ******************************************************************************/

#include "libonyx/libonyx.h"

void
nx_p_nxcode(cw_nx_t *a_nx)
{
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "{systemdict begin $sprintsdict < $arraytype {dup 0 gt {over dup xcheck {pop `{'} {echeck {`_{'} {`['} ifelse} ifelse 2 idup length 1 gt {0 1 4 idup length 2 sub {3 idup exch get 2 idup 1 sub over type sprintsdict exch get eval cat ` ' cat} for} if 2 idup length 0 gt {2 idup dup length 1 sub get 2 idup 1 sub over type sprintsdict exch get eval cat} if nip exch dup xcheck {pop `}'} {echeck {`}_'} {`]'} ifelse} ifelse cat} {pop pop `-array-'} ifelse} $booleantype {pop cvs} $conditiontype {pop pop `-condition-'} $dicttype {dup 0 gt {1 sub 0 `<' 3 idup {exch 4 idup over type sprintsdict exch get eval ` ' cat exch 4 idup over type sprintsdict exch get eval cat cat exch 1 add dup 4 idup length lt {exch ` ' cat} {exch} ifelse} foreach 4 nup pop pop pop `>' cat} {pop pop `-dict-'} ifelse} $filetype {pop pop `-file-'} $finotype {pop pop `-fino-'} $handletype {exch handletag dup type $nulltype ne {exch 1 sub over type sprintsdict exch get eval `=' exch cat `=' cat} {pop pop `-handle-'} ifelse} $integertype {pop cvs} $marktype {pop pop `-mark-'} $mutextype {pop pop `-mutex-'} $nametype {pop dup cvs exch dup lcheck {pop `$' exch cat} {echeck {`!' exch cat} if} ifelse} $nulltype {pop pop `null'} $operatortype {pop cvs dup `-operator-' ne {`--' tuck cat cat} if} $pmarktype {pop pop `-pmark-'} $realtype {pop cvs} $regextype {pop pop `-regex-'} $regsubtype {pop pop `-regsub-'} $stacktype {dup 0 gt {`(' 2 idup scount 1 gt {2 idup scount 1 sub -1 1 {3 idup dup dn sidup spop 2 idup 1 sub over type sprintsdict exch get eval cat ` ' cat} for} if 2 idup scount 0 gt {2 idup dup sdup spop 2 idup 1 sub over type sprintsdict exch get eval cat} if up 2 npop `)' cat} {pop pop `-stack-'} ifelse} $stringtype {pop cvs} $threadtype {pop pop `-thread-'} > def $sprints {over type sprintsdict exch get eval} def $sprint {sprints print `\n' print flush} def $outputsdict < $integertype {dup $b known {dup $b get} {10} ifelse 2 idup exch cvrs over $s known {over $s get $+ eq {2 idup 0 ge {`+' exch cat} if} if} if dn pop exch outputsdict $stringtype get eval} $realtype {dup $d known {dup $d get} {6} ifelse over $e known {over $e get} {false} ifelse 3 idup up {cves} {cvds} ifelse over $s known {over $s get $+ eq {2 idup 0 ge {`+' exch cat} if} if} if dn pop exch outputsdict $stringtype get eval} $_s {dup $w known {dup $p known {dup $p get} {` '} ifelse over $w get 3 idup length dup 2 idup le {over string 0 1 4 idup 1 sub {over exch 5 idup putinterval} for 3 ipop 3 idup $j known {3 idup $j get} {$r} ifelse dup $r eq {pop up sub} {$l eq {up 2 npop 0} {up sub 2 idiv} ifelse} ifelse over exch 5 ndn putinterval exch} {pop pop pop} ifelse} {dup $n known {over length over $n get dup 2 idup lt {nip dup string dup 5 ndn 4 ndn 0 exch getinterval 0 exch putinterval exch} {pop pop} ifelse} if} ifelse pop} def $stringtype $_s load [ $dup cvx $r $known cvx [ $dup cvx $r $get cvx ] cvx [ 1 ] cvx $ifelse cvx $dn cvx $exch cvx $sprints cvx $exch cvx $_s load cve ] cvx bind [ $arraytype $booleantype $conditiontype $dicttype $filetype $finotype $handletype $marktype $mutextype $nametype $nulltype $operatortype $pmarktype $regextype $regsubtype $stacktype $threadtype ] {exch dup} foreach pop currentdict $_s undef > def $outputs {dup type $dicttype ne {$typecheck throw} if over type outputsdict exch get eval} def $output {outputs print} def $product `Canonware Onyx' def $pstack {ostack {1 sprint} foreach flush} def $search {dup type $stringtype ne {$typecheck throw} if over type $stringtype ne {$typecheck throw} if dup length 2 idup length le {0 1 3 idup length 3 idup length sub {dup 3 idup exch 3 idup length getinterval dup length 1 sub 0 1 dn {dup 2 idup exch get exch 4 idup exch get ne {false exit} if} for dup type $booleantype eq {pop pop pop} {2 ipop up dup 2 idup exch 0 exch getinterval up 3 idup length add dup 2 idup length exch sub getinterval up true exit} ifelse} for dup type $booleantype ne {pop false} if} {pop false} ifelse} def $system {forkexec waitpid} def onyxdict begin $rpath_pre [ `' `.' ] def $rpath_post [ `/usr/local/share/onyx-devel/nx' ] def $mpath_pre [ `' `.' ] def $mpath_post [ `/usr/local/share/onyx-devel/nxm' ] def end $require {dup type $stringtype ne {$typecheck throw} if {[ onyxdict $rpath_pre get envdict $ONYX_RPATH 2 ndup known {get [ exch {`:' search {nip exch} {exit} ifelse} loop ]} {2 npop} ifelse onyxdict $rpath_post get ] {{`/' cat over cat dup `f' test {nip `r' open cvx eval stop} {pop} ifelse} foreach} foreach} stopped not {$undefinedfilename throw} if} def $mrequire {over type $stringtype ne {$typecheck throw} if dup type $stringtype ne {$typecheck throw} if exch {[ onyxdict $mpath_pre get envdict $ONYX_MPATH 2 ndup known {get [ exch {`:' search {nip exch} {exit} ifelse} loop ]} {2 npop} ifelse onyxdict $mpath_post get ] {{`/' cat over cat dup `f' test {nip exch modload stop} {pop} ifelse} foreach} foreach} stopped not {exch $undefinedfilename throw} if} def $throw {{{$errordict where {pop true} {false} ifelse} {!errordict $handleerror known} {!errordict $stop known} {$currenterror where {pop true} {false} ifelse}} {eval not {`Onyx: Missing errordict or currenterror defs\n' {stderr exch write} {} until `ostack: ' {stderr exch write} {} until ostack 2 sprints {stderr exch write} {} until `\ndstack: ' {stderr exch write} {} until dstack 2 sprints {stderr exch write} {} until `\nestack: ' {stderr exch write} {} until estack 2 sprints {stderr exch write} {} until `\nistack: ' {stderr exch write} {} until istack 2 sprints {stderr exch write} {} until `\nOnyx: dieing\n' {stderr exch write} {} until 1 die} if} foreach dup type $nametype ne {$typecheck !throw} if !currenterror begin $newerror true def dup $errorname exch cvl def ostack dup spop pop $ostack exch def $dstack dstack dup spop pop def $estack estack dup tailopt 1 2 ifelse snpop pop def $istack istack dup tailopt 1 2 ifelse snpop pop def !estack dup sdup spop exch end !errordict dup 2 idup known {exch get eval} {nip dup $handleerror get eval $stop get eval} ifelse} def $version `<Version = onyx>' def end}bind eval end");
    nxo_thread_exit(&thread);
}

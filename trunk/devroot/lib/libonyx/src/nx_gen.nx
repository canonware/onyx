################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Onyx <Version = onyx>
#
# Read onyx code from stdin and output a compacted version to stdout.  The
# output code defines the C function nx_p_nxcode().
#
# This program is run by the 'bootstrap' build system target.
#
################################################################################

# Create an encoding dictionary for various operators.  The values must not
# correspond to an existing name in dstack.  The byte overhead is the length of
# the name plus three.  So, a name must show up at least as many times as in
# the following table to bother adding an entry:
#
#   Length | Minimum use | Transform
#   -------+-------------+------------------------------------------------------
#        2 | 5           | xx xx xx xx --> $X~x x x x x
#        3 | 4           | xxx xxx xxx --> $X~xxx x x x
#        4 | 3           | xxxx xxxx xxxx --> $X~xxxx x x x
#        5 | 3           | xxxxx xxxxx xxxxx --> $X~xxxxx x x x
#        6 | 2           | xxxxxx xxxxxx --> $X~xxxxxx x x
#       >7 | 2
#
$_encdict <
    $begin		$A	# 4
    $cat		$B	# 19
    $cvs		$C	# 6
    $cvx		$D	# 13
    $def		$E	# ~21
    $dup		$F	# ~37
    $echeck		$G	# 3
    $eq			$H	# 6
    $eval		$I	# 14
    $exch		$J	# ~57
    $false		$K	# 5
    $flush		$L	# 3
    $foreach		$M	# 9
    $get		$N	# 32
    $getinterval	$O	# 4
    $gt			$P	# 7
    $if			$Q	# 29
    $ifelse		$R	# 20
    $idup		$S	# ~66
    $known		$T	# 8
    $length		$U	# 16
    $load		$V	# 9
    $ne			$W	# 13
    $nip		$X	# 4
    $not		$Y	# 4
    $ostack		$Z	# 3
    $over		$a	# ~26
    $pop		$b	# ~69
    $print		$c	# 3
    $putinterval	$d	# 3
    $scount		$e	# 3
    $spop		$f	# 7
    $stderr		$g	# 10
    $stop		$h	# 3
    $stopped		$i	# 3
    $string		$j	# 2
    $sub		$k	# 15
    $systemdict		$l	# 3
    $true		$m	# 4
    $type		$n	# >= 17
    $until		$o	# 10
    $write		$p	# 10
    $xcheck		$q	# 3
> def

# #proc _encarr -
$_encarr {
    0 1 2 idup length 1 sub {
	# #proc #i
	1 idup 1 idup get
	# #proc #i #el
	dup type $nametype eq {
	    dup dup xcheck exch echeck not and {
		# Executable Name.  Try to replace.
		_encdict 1 idup known {
		    _encdict exch get cvx
		    # #proc #i #e
		    2 idup up
		    # #proc #proc #i #e
		    put
		}{
		    pop pop
		} ifelse
	    }{
		pop pop
	    } ifelse
	}{
	    dup type $arraytype eq {
		# Array.  Recurse.
		_encarr
		pop
	    }{
		# Other.  Do nothing.
		pop pop
	    } ifelse
	} ifelse
	# #proc
    } for
    pop
} def

# Output the header.
`/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 * This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Onyx <Version = onyx>
 *
 ******************************************************************************/

#include "libonyx/libonyx.h"

void
nx_p_nxcode(cw_nx_t *a_nx)
{
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "' print

# Output the translation dictionary.
`<' print
_encdict {
    1 sprints print
    `~' print cvx 1 sprints print
} foreach
`>begin' print

# Read in the code.
stdin cvx eval

# We now have an array of code.  Recursively iterate through the elements of
# the array and replace executable names with their equivalents in the
# temporary shorthand dictionary.
dup _encarr

# Output the procedure, using a recursion depth large enough to meet or exceed
# the depth of nested braces in the code.
1000 sprints print

`bind eval end");
    nxo_thread_exit(&thread);
}
' print

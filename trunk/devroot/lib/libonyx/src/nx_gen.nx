################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Onyx <Version = onyx>
#
# Usage: nx_gen.nx [<options>]
#
#   Option: -B : Not bootstrapping.
#           -b : Bootstrapping.
#           -C : Do not compact.
#           -c : Compact.
#
# Read onyx code from stdin and output a compacted version to stdout.  The
# output code defines the C function nx_p_nxcode().
#
# This program is run by the 'bootstrap' build system target.
#
################################################################################

# Parse the command line.
$opt_bootstrap false def
$opt_compact true def

$opt_dict <
    `-B' {
	$opt_bootstrap false def
    }
    `-b' {
	$opt_bootstrap true def
    }
    `-C' {
	$opt_compact false def
    }
    `-c' {
	$opt_compact true def
    }
> def

argv length 1 gt {
    argv 1 over length dec getinterval {
	opt_dict over known {
	    opt_dict exch get eval
	}{
	    # Unknown option.
	    `nx_gen.nx: Unknown option '
	    exch 1 sprints cat
	    `\n' cat

	    stderr exch write pop
	    1 die
	} ifelse
    } foreach
}{
    $opt_bootstrap false def
} ifelse

# Create an encoding dictionary for various operators.  The values must not
# correspond to an existing name in dstack.  The byte overhead is the length of
# the name plus three.  So, a name must show up at least as many times as in
# the following table to bother adding an entry:
#
#   Length | Minimum use | Transform
#   -------+-------------+------------------------------------------------------
#        2 | 5           | xx xx xx xx --> $X~x x x x x
#        3 | 4           | xxx xxx xxx --> $X~xxx x x x
#        4 | 3           | xxxx xxxx xxxx --> $X~xxxx x x x
#        5 | 3           | xxxxx xxxxx xxxxx --> $X~xxxxx x x x
#      >=6 | 2           | xxxxxx xxxxxx --> $X~xxxxxx x x
#
$_encdict <
    $begin		$A	# 4
    $cat		$B	# 19
    $cvs		$C	# 6
    $cvx		$D	# 13
    $def		$E	# ~21
    $dup		$F	# ~37
    $echeck		$G	# 3
    $eq			$H	# 6
    $eval		$I	# 14
    $exch		$J	# ~57
    $false		$K	# 5
    $flush		$L	# 3
    $foreach		$M	# 9
    $get		$N	# 32
    $getinterval	$O	# 4
    $gt			$P	# 7
    $if			$Q	# 29
    $ifelse		$R	# 20
    $idup		$S	# ~66
    $known		$T	# 8
    $length		$U	# 16
    $load		$V	# 9
    $ne			$W	# 13
    $nip		$X	# 4
    $not		$Y	# 4
    $ostack		$Z	# 3
    $over		$a	# ~26
    $pop		$b	# ~69
    $print		$c	# 3
    $putinterval	$d	# 3
    $scount		$e	# 3
    $spop		$f	# 7
    $stderr		$g	# 10
    $stop		$h	# 3
    $stopped		$i	# 3
    $string		$j	# 2
    $sub		$k	# 15
    $systemdict		$l	# 3
    $true		$m	# 4
    $type		$n	# >= 17
    $until		$o	# 10
    $write		$p	# 10
    $xcheck		$q	# 3
> def

#proc _encarr -
$_encarr {
    0 1 2 idup length dec {
	#proc #i
	2 ndup get
	#proc #i #el
	dup type $nametype eq {
	    dup xcheck {
		opt_compact {
		    # Executable Name.  Try to replace.
		    _encdict 1 idup known {
			_encdict exch get cvx
			#proc #i #e
			2 idup up
			#proc #proc #i #e
			put
		    }{
			2 npop
		    } ifelse
		}{
		    2 npop
		} ifelse
	    }{
		2 npop
	    } ifelse
	}{
	    dup type $arraytype eq {
		# Array.  Recurse.
		_encarr
		pop
	    }{
		# Other.  Do nothing.
		2 npop
	    } ifelse
	} ifelse
	#proc
    } for
    pop
} def

# Output the header.
`/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 * This file is automatically generated.
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Onyx <Version = onyx>
 *
 ******************************************************************************/

#include "libonyx/libonyx.h"

void
nx_p_nxcode(cw_nx_t *a_nx)
{
    cw_nxo_t thread;

    nxo_thread_new(&thread, a_nx);
    cw_onyx_code(&thread, "' print

opt_compact {
    # Output the translation dictionary.
    `<' print
    _encdict {
	1 sprints print
	`~' print cvx 1 sprints print
    } foreach
    `>begin' print
} if

# Read in the code.
stdin cvx eval

# We now have an array of code.  Recursively iterate through the elements of
# the array and replace executable names with their equivalents in the
# temporary shorthand dictionary.
dup _encarr

# Output the procedure, using a recursion depth large enough to meet or exceed
# the depth of nested braces in the code.
1000 sprints print

`bind eval end");
    nxo_thread_exit(&thread);
}
' print

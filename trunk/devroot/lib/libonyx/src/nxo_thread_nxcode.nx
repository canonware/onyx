%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% This file is processed by nxo_thread_nxcode_gen.nx to produce a more compact
% embedded version in nxo_thread_nxcode.c.  Due to bootstrapping issues, this
% cannot safely be done automatically as part of the build process.  In order
% to make changes to this file take effect, either type:
%
%   cook onyx_bootstrap
%
% or
%
%   cat nxo_thread_nxcode.nx | onyx nxo_thread_nxcode_gen.nx
%       > nxo_thread_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

% userdict doesn't exist yet.  This code jumps through some hoops to push it
% onto dstack, then define it in threaddict, to avoid a dstackunderflow error.
dict begin
/userdict currentdict
dstack 3 sindex spop begin pop
/threaddict currentdict def
def

% Define and initialize currenterror
/currenterror <
	/stop		/stop load
	/newerror	false
	/errorname	`'
	/estack		()
	/istack		()
	/ostack		()
	/dstack		()
	/recordstacks	true
	/line		1
	/column		0
> def

% Define and initialize currenterror.
/errordict <
	% Don't execute this code for the initial thread, since throw isn't
	% defined yet.
	/throw where {
		pop
		[
			/dstackunderflow
			/estackoverflow
			/invalidaccess
			/invalidcontext
			/invalidexit
			/invalidfileaccess
			/ioerror
			/limitcheck
			/rangecheck
			/stackunderflow
			/syntaxerror
			/typecheck
			/undefined
			/undefinedfilename
			/undefinedresult
			/unmatchedmark
			/unmatchedfino
			/unregistered
		]{
			% This does the equivalent of:
			%   /anerror {/anerror throw}
			% It saves quite a bit of space, so seems worth the
			% obfuscation.
			%
			dup cvx exch [exch /throw load /eval cvx] cvx
		} foreach
	} if

	/handleerror cvx {
		/currenterror load begin

		% If this is a syntaxerror, print the line and column numbers.
		/errorname load /syntaxerror eq {
			`At line ' print
			/line load cvs print
			`, column ' print
			/column load cvs print
			`: ' print
		} if

		% Print the errorname.
		`Error /' print /errorname load cvs print `\n' print

		% If stack recording is active, print ostack and dstack, plus an
		% estack/istack execution trace.
		/recordstacks load {
			% Print ostack and dstack using sprint.
			`ostack: ' print
			/ostack load 1 sprint
			`dstack: ' print
			/dstack load 1 sprint

			% Print a stack trace that depicts the currently
			% executing element of arrays.
			/estack load scount exch pop 1 sub dup 0 gt {
				`estack/istack trace (0..' print
				dup cvs print
				`):\n' print

			} if

			% For each element in estack:
			0 1 3 2 roll {
				% <edepth>
				% If this element is an array, print it
				% specially.
				dup cvs print
				dup /estack load exch sindex spop exch pop 
				% <edepth> <array>

				dup type /arraytype eq {
					% Array.
					`: {\n' print
					% <edepth> <array>
					dup length 1 sub 0 1 3 -1 roll {
						% <edepth> <array> <aindex>
						2 index /istack load
						exch sindex spop exch pop
						% <edepth> <array> <aindex>
						% <iindex>
						1 index
						% <edepth> <array> <aindex>
						% <iindex> <aindex>
						eq {
							` ' print
							dup cvs print
							`:-->\t' print
						}{
							`\t' print
						} ifelse
						% <edepth> <array> <aindex>
						1 index exch get 1 sprint
						% <edepth> <array>
					} for
					`}\n' print
					% <edepth> <array>
					pop
					% <edepth>
				}{
					% Non-array.
					`:\t' print
					% <edepth> <array>
					1 sprint
					% <edepth>
				} ifelse
				% <edepth>
				pop
			} for
		} if
		end

		% Make sure the output gets written before stop.
		flush
	} bind
> def

end % threaddict

} % End deferral.

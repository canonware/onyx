%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% bhp portion of Canonware Software Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{bhp}
\label{bhp}
\index{\classname{bhp}{}}
The \classname{bhp} and \classname{bhpi} classes implement binomial heaps.  The
\classname{bhpi} class encapsulates the internal nodes of \classname{bhp}
instances.  Pointer casting is used to allow arbitrary data types to be used.  A
priority comparison function must be specified during creation of a
\classname{bhp}.  Priority comparison functions are included for
\ctype{cw\_uint32\_t}, \ctype{cw\_sint32\_t}, and \ctype{cw\_uint64\_t}.

\subsubsection{dbg symbols}
None.

\subsubsection{API}
\begin{description}
\label{bhpi_new}
\index{\cfunc{bhpi\_new}{}}
\item[{\cfunc[cw\_bhpi\_t]{bhpi\_new}{cw\_bhpi\_t *a\_bhpi, cw\_mem\_t *a\_mem,
const void *a\_priority, const void *a\_data, void (*a\_dealloc\_func)(void
*dealloc\_arg, void *bhpi), void *a\_dealloc\_arg}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhpi: ]
			Pointer to space for a \classname{bhpi}, or NULL.
		\item[a\_mem: ]
			Pointer to the allocator to use internally.
		\item[a\_priority: ]
			Pointer to a priority object.
		\item[a\_data: ]
			Pointer to a data object.
		\item[a\_dealloc\_func: ]
			Pointer to a memory deallocation function, or NULL.
			Ignored if (\cvar{a\_bhpi} == NULL).
		\item[a\_dealloc\_arg: ]
			Pointer to first argument to \cvar{a\_dealloc\_func}, or
			NULL.  Ignored if (\cvar{a\_dealloc\_func} == NULL), or
			(\cvar{a\_bhpi} == NULL).
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{bhpi}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{description}
\label{bhpi_delete}
\index{\cfunc{bhpi\_delete}{}}
\item[{\cfunc[void]{bhpi\_delete}{cw\_bhpi\_t *a\_bhpi}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhpi: ]
			Pointer to a \classname{bhpi}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.  If the \classname{bhpi} has been inserted into a
		\classname{bhp}, do not call this method, since the
		\classname{bhp} code will eventually do it.

		Note: No attempt is made to free data pointed to by the priority
		or data pointers.
	\end{description}
\label{bhp_new}
\label{bhp_new_r}
\index{\cfunc{bhp\_new}{}}
\index{\cfunc{bhp\_new\_r}{}}
\item[{\cfunc[cw\_bhp\_t *]{bhp\_new}{cw\_bhp\_t *a\_bhp, cw\_mem\_t *a\_mem,
bhp\_prio\_comp\_t *a\_prio\_comp}}: ]
\item[{\cfunc[cw\_bhp\_t *]{bhp\_new\_r}{cw\_bhp\_t *a\_bhp, cw\_mem\_t *a\_mem,
bhp\_prio\_comp\_t *a\_prio\_comp}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to space for a \classname{bhp}, or NULL.
		\item[a\_mem: ]
			Pointer to the allocator to use internally.
		\item[a\_prio\_comp: ]
			Pointer to a priority comparison function.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{bhp}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Non-thread-safe and thread-safe constructors.
	\end{description}
\label{bhp_delete}
\index{\cfunc{bhp\_delete}{}}
\item[{\cfunc[void]{bhp\_delete}{cw\_bhp\_t *a\_bhp}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.
	\end{description}
\label{bhp_dump}
\index{\cfunc{bhp\_dump}{}}
\item[{\cfunc[void]{bhp\_dump}{cw\_bhp\_t *a\_bhp}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\end{description}
	\item[Output(s): ]
		Output printed to \cvar{cw\_g\_out}.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Print the internal tree to \cvar{cw\_g\_out}.
	\end{description}
\label{bhp_insert}
\index{\cfunc{bhp\_insert}{}}
\item[{\cfunc[void]{bhp\_insert}{cw\_bhp\_t *a\_bhp, cw\_bhpi\_t *a\_bhpi}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\item[a\_bhpi: ]
			Pointer to a \classname{bhpi}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Insert an item into \cvar{a\_bhp}.
	\end{description}
\label{bhp_min_find}
\index{\cfunc{bhp\_min\_find}{}}
\item[{\cfunc[cw\_bool\_t]{bhp\_min\_find}{cw\_bhp\_t *a\_bhp, void
**r\_priority, void **r\_data}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\item[r\_priority: ]
			Pointer to a pointer, or NULL.
		\item[r\_data: ]
			Pointer to a pointer, or NULL.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[FALSE: ] Success.
			\item[TRUE: ] Empty heap.
			\end{description}
		\item[*r\_priority: ]
			Pointer to the priority object.
		\item[*r\_data: ]
			Pointer to the data object.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Set \cvar{*r\_priority} and \cvar{*r\_data} to point to a
		minimum node in \cvar{a\_bhp}.
	\end{description}
\label{bhp_min_del}
\index{\cfunc{bhp\_min\_del}{}}
\item[{\cfunc[cw\_bool\_t]{bhp\_min\_del}{cw\_bhp\_t *a\_bhp, void
**r\_priority, void **r\_data}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\item[r\_priority: ]
			Pointer to a pointer, or NULL.
		\item[r\_data: ]
			Pointer to a pointer, or NULL.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[FALSE: ] Success.
			\item[TRUE: ] Empty heap.
			\end{description}
		\item[*r\_priority: ]
			Pointer to the priority object.
		\item[*r\_data: ]
			Pointer to the data object.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Set \cvar{*r\_priority} and \cvar{*r\_data} to point to a
		minimum node in \cvar{a\_bhp} and remove the item from
		\cvar{a\_bhp}.
	\end{description}
\label{bhp_size_get}
\index{\cfunc{bhp\_size\_get}{}}
\item[{\cfunc[cw\_uint64\_t]{bhp\_size\_get}{cw\_bhp\_t *a\_bhp}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bhp: ]
			Pointer to a \classname{bhp}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Number of items in \cvar{a\_bhp}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the number of items in \cvar{a\_bhp}.
	\end{description}
\label{bhp_union}
\index{\cfunc{bhp\_union}{}}
\item[{\cfunc[void]{bhp\_union}{cw\_bhp\_t *a\_a, cw\_bhp\_t *a\_b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \classname{bhp}.
		\item[a\_b: ]
			Pointer to a \classname{bhp}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Merge \cvar{a\_b} into \cvar{a\_a}.  \cvar{a\_b} is invalid
		after this call, and does not need to be deleted.
	\end{description}
\label{bhp_priority_compare_uint32}
\index{\cfunc{bhp\_priority\_compare\_uint32}{}}
\item[{\cfunc[cw\_sint32\_t]{bhp\_priority\_compare\_uint32}{const void *a\_a,
const void *a\_b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \ctype{cw\_uint32\_t}.
		\item[a\_b: ]
			Pointer to a \ctype{cw\_uint32\_t}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ] \cvar{*a\_a} < \cvar{*a\_b}.
			\item[0: ] \cvar{*a\_a} == \cvar{*a\_b}.
			\item[1: ] \cvar{*a\_a} > \cvar{*a\_b}.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Compare \cvar{*a\_a} and \cvar{*a\_b} as unsigned 32 bit
		integers.
	\end{description}
\label{bhp_priority_compare_uint32}
\index{\cfunc{bhp\_priority\_compare\_uint32}{}}
\item[{\cfunc[cw\_sint32\_t]{bhp\_priority\_compare\_sint32}{const void *a\_a,
const void *a\_b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \ctype{cw\_sint32\_t}.
		\item[a\_b: ]
			Pointer to a \ctype{cw\_sint32\_t}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ] \cvar{*a\_a} < \cvar{*a\_b}.
			\item[0: ] \cvar{*a\_a} == \cvar{*a\_b}.
			\item[1: ] \cvar{*a\_a} > \cvar{*a\_b}.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Compare \cvar{*a\_a} and \cvar{*a\_b} as signed 32 bit
		integers.
	\end{description}
\label{bhp_priority_compare_uint64}
\index{\cfunc{bhp\_priority\_compare\_uint64}{}}
\item[{\cfunc[cw\_sint32\_t]{bhp\_priority\_compare\_uint64}{const void *a\_a,
const void *a\_b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \ctype{cw\_uint64\_t}.
		\item[a\_b: ]
			Pointer to a \ctype{cw\_uint64\_t}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[-1: ] \cvar{*a\_a} < \cvar{*a\_b}.
			\item[0: ] \cvar{*a\_a} == \cvar{*a\_b}.
			\item[1: ] \cvar{*a\_a} > \cvar{*a\_b}.
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Compare \cvar{*a\_a} and \cvar{*a\_b} as unsigned 64 bit
		integers.
	\end{description}
\end{description}

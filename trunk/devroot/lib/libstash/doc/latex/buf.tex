%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% buf portion of Canonware Software Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{buf}
\label{buf}
\index{\classname{buf}{}}

The \classname{buf} and \classname{bufc} classes implement a buffer abstraction.
These classes are designed specifically to handle streaming and transparent
extensible buffering of data for applications such as socket programs.
\classname{buf} objects are dynamically extensible and contractible, as well as
reference counted.  This means that data can be passed and internally shared
among \classname{buf} objects without copying or worry of memory leaks.
Depending on the application, this also allows for very compact use of memory
buffers.

Internally, a \classname{buf} consists of an array of buffer elements,
\classname{bufel}s, that reference \classname{bufc} objects.  The
\classname{bufc} objects are reference counted, such that each \classname{bufel}
reference to a \classname{bufc} increases the \classname{bufc} reference count.
In addition, the library user has a reference to each \classname{bufc} as when
it is initialized.  When data are passed among \classname{buf} objects,
references are added to the affected \classname{bufc} objects, but no data are
actually copied.

When data are modified, they must be copied if there are multiple references, or
if the \classname{bufc} was marked as non-writeable in the
\cfunc{bufc\_buffer\_set}{} call.  Otherwise, data can be modified in place.

Random access to data is O(log n), where n is the number of \classname{bufel}
objects in the \classname{buf}.  Linear access, either forward or backward, is
optimized to be fast in the general case.  The most recent access is cached, so
if the next access is in the same \classname{bufel}, the cost for that access is
O(1).

The \classname{buf} code provides an iovec (see \cfunc{readv}{}/\cfunc{writev}{}
documentation) interface for accessing the internals for read-only operations.
In general, this interface shouldn't be needed except when using the
\cfunc{writev}{} function.

Once a \classname{bufc} has been passed to \cfunc{buf\_\{pre,ap\}pend\_bufc}{},
its data must be treated as read-only.  That is, the \classname{bufc} must be
treated as opaque as soon as any \classname{buf} has a reference to it.

\subsubsection{API}
\begin{description}
\label{buf_new}
\label{buf_new_r}
\index{\cfunc{buf\_new}{}}
\index{\cfunc{buf\_new\_r}{}}
\item[{\cfunc[cw\_buf\_t *]{buf\_new}{cw\_buf\_t *a\_buf, cw\_mem\_t
*a\_mem}}: ]
\item[{\cfunc[cw\_buf\_t *]{buf\_new\_r}{cw\_buf\_t *a\_buf, cw\_mem\_t
*a\_mem}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to space for a \classname{buf}, or NULL.
		\item[a\_mem: ]
			Pointer to the allocator to use internally.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{buf}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Non-thread-safe and thread-safe constructors.
	\end{description}
\label{buf_delete}
\index{\cfunc{buf\_delete}{}}
\item[{\cfunc[void]{buf\_delete}{cw\_buf\_t *a\_buf}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.
	\end{description}
\label{buf_dump}
\index{\cfunc{buf\_dump}{}}
\item[{\cfunc[void]{buf\_dump}{cw\_buf\_t *a\_buf}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\end{description}
	\item[Output(s): ]
		\cvar{a\_buf}'s internals, printed to \cvar{out\_err}.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Print the internal state of \cvar{a\_buf} to \cvar{out\_err}.
	\end{description}
\label{buf_size_get}
\index{\cfunc{buf\_size\_get}{}}
\item[{\cfunc[cw\_uint32\_t]{buf\_size\_get}{cw\_buf\_t *a\_buf}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Number of bytes of valid data.
		\end{description}
	\item[Exception(s): ] None.
		Return the amout of valid data in bytes.
	\item[Description: ]
	\end{description}
\label{buf_num_bufels_get}
\index{\cfunc{buf\_num\_bufels\_get}{}}
\item[{\cfunc[cw\_uint32\_t]{buf\_num\_bufels\_get}{cw\_buf\_t *a\_buf}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Number of \classname{bufel}'s (internal buffer elements)
			in \cvar{a\_buf} (same as iovec count in
			\cfunc{buf\_iovec\_get}{}).
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the number of \classname{bufel}'s in \cvar{a\_buf}.
	\end{description}
\label{buf_iovec_get}
\index{\cfunc{buf\_iovec\_get}{}}
\item[{\cfunc[const struct iovec *]{buf\_iovec\_get}{cw\_buf\_t *a\_buf,
cw\_uint32\_t a\_max\_data, cw\_bool\_t a\_is\_sys\_iovec, int
*r\_iovec\_count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_max\_data: ]
			Maximum number of bytes of space to include in the
			iovec.
		\item[a\_is\_sys\_iovec: ]
			If TRUE, limit \cvar{*r\_iovec\_count} to the maximum
			iovec count supported by this system for
			\cfunc{readv}{}/\cfunc{writev}{}.
		\item[r\_iovec\_count: ]
			Pointer to an int.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to an iovec array that represents the internal
			data buffers in \cvar{a\_buf}.
		\item[*r\_iovec\_count: ]
			Number of valid iovec structures in \cvar{retval}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Build an iovec array that represents the valid data in
		\cvar{a\_buf}'s internal buffers (up to \cvar{a\_max\_data}
		bytes) and return a pointer to it.
	\end{description}
\label{buf_catenate}
\index{\cfunc{buf\_catenate}{}}
\item[{\cfunc[void]{buf\_catenate}{cw\_buf\_t *a\_a, cw\_buf\_t *a\_b,
cw\_bool\_t a\_preserve}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \classname{buf}.
		\item[a\_b: ]
			Pointer to a \classname{buf}.
		\item[a\_preserve: ]
			If TRUE, preserve \cvar{a\_b} (don't modify it).  If
			FALSE, release the data in \cvar{a\_b} after catenating
			\cvar{a\_b} to \cvar{a\_a}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Catenate two \classname{buf}'s.  \cvar{a\_b} is left unmodifed
		if \cvar{a\_preserve} is TRUE; otherwise \cvar{a\_b} is emptied.
	\end{description}
\label{buf_split}
\index{\cfunc{buf\_split}{}}
\item[{\cfunc[void]{buf\_split}{cw\_buf\_t *a\_a, cw\_buf\_t *a\_b,
cw\_bool\_t a\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_a: ]
			Pointer to a \classname{buf}.
		\item[a\_b: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset at which to split \cvar{a\_b}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Split \cvar{a\_b} at offset \cvar{a\_offset}.  Append the data
		before \cvar{a\_offset} to \cvar{a\_a}, and leave the remainder
		in \cvar{a\_b}.
	\end{description}
\label{buf_bufc_prepend}
\index{\cfunc{buf\_bufc\_prepend}{}}
\item[{\cfunc[void]{buf\_bufc\_prepend}{cw\_buf\_t *a\_buf, cw\_bufc\_t
*a\_bufc, cw\_uint32\_t a\_beg\_offset, cw\_uint32\_t a\_end\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\item[a\_beg\_offset: ]
			Offset of first valid byte in \cvar{a\_bufc}'s memory
			buffer.
		\item[a\_end\_offset: ]
			Offset of first byte past the valid range of bytes in
			\cvar{a\_bufc}'s memory buffer.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Prepend \cvar{a\_bufc}, bytes \cvar{a\_beg\_offset} through
		(\cvar{a\_end\_offset} - 1) to \cvar{a\_buf}.
	\end{description}
\label{buf_bufc_append}
\index{\cfunc{buf\_bufc\_append}{}}
\item[{\cfunc[void]{buf\_bufc\_append}{cw\_buf\_t *a\_buf, cw\_bufc\_t
*a\_bufc, cw\_uint32\_t a\_beg\_offset, cw\_uint32\_t a\_end\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\item[a\_beg\_offset: ]
			Offset of first valid byte in \cvar{a\_bufc}'s memory
			buffer.
		\item[a\_end\_offset: ]
			Offset of first byte past the valid range of bytes in
			\cvar{a\_bufc}'s memory buffer.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Append \cvar{a\_bufc}, bytes \cvar{a\_beg\_offset} through
		(\cvar{a\_end\_offset} - 1) to \cvar{a\_buf}.
	\end{description}
\label{buf_head_data_release}
\index{\cfunc{buf\_head\_data\_release}{}}
\item[{\cfunc[cw\_bool\_t]{buf\_head\_data\_release}{cw\_buf\_t *a\_buf,
cw\_uint32\_t a\_amount}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_amount: ]
			Number of bytes of data to release from the head of
			\cvar{a\_buf}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[FALSE: ]
				 Success.
			\item[TRUE: ]
				 Error.  (\cvar{a\_amount} >
				\cfunc{buf\_size\_get}{a\_buf}).
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Release \cvar{a\_amount} bytes from the head of \cvar{a\_buf}.
	\end{description}
\label{buf_tail_data_release}
\index{\cfunc{buf\_tail\_data\_release}{}}
\item[{\cfunc[cw\_bool\_t]{buf\_tail\_data\_release}{cw\_buf\_t *a\_buf,
cw\_uint32\_t a\_amount}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_amount: ]
			Number of bytes of data to release from the tail of
			\cvar{a\_buf}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			\begin{description}\item[]
			\item[FALSE: ]
				 Success.
			\item[TRUE: ]
				 Error.  (\cvar{a\_amount} >
				\cfunc{buf\_size\_get}{a\_buf}).
			\end{description}
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Release \cvar{a\_amount} bytes from the tail of \cvar{a\_buf}.
	\end{description}
\label{buf_uint8_get}
\index{\cfunc{buf\_uint8\_get}{}}
\item[{\cfunc[cw\_uint8\_t]{buf\_uint8\_get}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint8 to return.  (\cvar{a\_offset}
			<= \cfunc{buf\_size\_get}{a\_buf} - 1).
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Value of the uint8 at offset \cvar{a\_offset} in
			\cvar{a\_buf}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the uint8 at offset \cvar{a\_offset}.
	\end{description}
\label{buf_uint32_get}
\index{\cfunc{buf\_uint32\_get}{}}
\item[{\cfunc[cw\_uint32\_t]{buf\_uint32\_get}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint32 to return.  (\cvar{a\_offset}
			<= \cfunc{buf\_size\_get}{a\_buf} - 4).
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Value of the uint32 at offset \cvar{a\_offset} in
			\cvar{a\_buf}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the uint32 at offset \cvar{a\_offset}.
	\end{description}
\label{buf_uint64_get}
\index{\cfunc{buf\_uint64\_get}{}}
\item[{\cfunc[cw\_uint64\_t]{buf\_uint64\_get}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint64 to return.  (\cvar{a\_offset}
			<= \cfunc{buf\_size\_get}{a\_buf} - 8).
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Value of the uint64 at offset \cvar{a\_offset} in
			\cvar{a\_buf}.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the uint64 at offset \cvar{a\_offset}.
	\end{description}
\label{buf_uint8_set}
\index{\cfunc{buf\_uint8\_set}{}}
\item[{\cfunc[void]{buf\_uint8\_set}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset, cw\_uint\_t32 a\_val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint64 to set.  (\cvar{a\_offset} <=
			\cfunc{buf\_size\_get}{a\_buf}).
		\item[a\_val: ]
			Value to set data at \cvar{a\_offset} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the uint8 at \cvar{a\_offset} to \cvar{a\_val}.
	\end{description}
\label{buf_uint32_set}
\index{\cfunc{buf\_uint32\_set}{}}
\item[{\cfunc[void]{buf\_uint32\_set}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset, cw\_uint\_t32 a\_val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint64 to set.  (\cvar{a\_offset} <=
			\cfunc{buf\_size\_get}{a\_buf}).
		\item[a\_val: ]
			Value to set data at \cvar{a\_offset} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the uint32 at \cvar{a\_offset} to \cvar{a\_val}.
	\end{description}
\label{buf_uint64_set}
\index{\cfunc{buf\_uint64\_set}{}}
\item[{\cfunc[void]{buf\_uint64\_set}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset, cw\_uint\_t32 a\_val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of uint64 to set.  (\cvar{a\_offset} <=
			\cfunc{buf\_size\_get}{a\_buf}).
		\item[a\_val: ]
			Value to set data at \cvar{a\_offset} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Set the uint64 at \cvar{a\_offset} to \cvar{a\_val}.
	\end{description}
\label{buf_range_set}
\index{\cfunc{buf\_range\_set}{}}
\item[{\cfunc[void]{buf\_range\_set}{cw\_buf\_t *a\_buf, cw\_uint32\_t
a\_offset, cw\_uint32\_t a\_length, cw\_uint8\_t *a\_val, cw\_bool\_t
a\_is\_writeable}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_buf: ]
			Pointer to a \classname{buf}.
		\item[a\_offset: ]
			Offset in bytes of data to set. (\cvar{a\_offset} <=
			\cfunc{buf\_size\_get}{a\_buf}).
		\item[a\_length: ]
			Number of bytes to copy from \cvar{a\_val}.
		\item[a\_val: ]
			Value to set data at \cvar{a\_offset} to.
		\item[a\_is\_writeable: ]
			\begin{description}\item[]
			\item[FALSE: ]
				Non-writeable buffer.
			\item[TRUE: ]
				Writeable buffer.
			\end{description}
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Insert \cvar{a\_offset} bytes from \cvar{a\_val} into
		\cvar{a\_buf} at offset \cvar{a\_offset}.
	\end{description}
\label{bufc_new}
\index{\cfunc{bufc\_new}{}}
\item[{\cfunc[cw\_bufc\_t *]{bufc\_new}{cw\_bufc\_t *a\_bufc, cw\_mem\_t
*a\_mem, cw\_opaque\_dealloc\_t *a\_dealloc\_func, void *a\_dealloc\_arg}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\item[a\_mem: ]
			Pointer to the allocator to use internally.
		\item[a\_opaque\_dealloc\_func: ]
			\begin{description}\item[]
			\item[non-NULL: ] Pointer to a deallocation function.
			\item[NULL: ] No deallocation function.
			\end{description}
		\item[a\_dealloc\_arg: ]
			First argument to \cvar{a\_dealloc\_func}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Pointer to a \classname{bufc}.
		\end{description}
	\item[Exception(s): ]
		\begin{description}\item[]
		\item[\htmlref{\_CW\_STASHX\_OOM}{_CW_STASHX_OOM}.]
		\end{description}
	\item[Description: ]
		Constructor.
	\end{description}
\label{bufc_delete}
\index{\cfunc{bufc\_delete}{}}
\item[{\cfunc[void]{bufc\_delete}{cw\_bufc\_t *a\_bufc}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Destructor.
	\end{description}
\label{bufc_buffer_set}
\index{\cfunc{bufc\_buffer\_set}{}}
\item[{\cfunc[void]{bufc\_buffer\_set}{cw\_bufc\_t *a\_bufc, void *a\_buffer,
cw\_uint32\_t a\_size, cw\_bool\_t a\_is\_writeable, cw\_opaque\_dealloc\_t
*a\_dealloc\_func, void *a\_dealloc\_arg}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\item[a\_buffer: ]
			Pointer to a buffer.
		\item[a\_size: ]
			Size of buffer pointed to by \cfunc{a\_buffer}.
		\item[a\_is\_writeable: ]
			\begin{description}\item[]
			\item[FALSE: ] \cfunc{a\_buffer} may not be modified.
			\item[TRUE: ] \cfunc{a\_buffer} may be modified if there
				is only one reference to it.
			\end{description}
		\item[a\_opaque\_dealloc\_func: ]
			\begin{description}\item[]
			\item[non-NULL: ] Pointer to a deallocation function.
			\item[NULL: ] No deallocation function.
			\end{description}
		\item[a\_dealloc\_arg: ]
			First argument to \cvar{a\_dealloc\_func}.
		\end{description}
	\item[Output(s): ] None.
	\item[Exception(s): ] None.
	\item[Description: ]
		Set \cvar{a\_bufc}'s internal data buffer to \cvar{a\_buffer},
		with size \cvar{a\_size}, and deallocation function
		\cfunc{a\_dealloc\_func}{a\_dealloc\_arg, a\_buffer}.

		This function is not reentrant, and assumes that no other
		references to \cvar{a\_bufc} exist (or at least they don't rely
		on the \classname{bufc}'s state).  In other words, don't call
		this function after the \classname{bufc} has been inserted into
		one or more \classname{buf}'s.
	\end{description}
\label{bufc_size_get}
\index{\cfunc{bufc\_size\_get}{}}
\item[{\cfunc[cw\_uint32\_t]{bufc\_size\_get}{cw\_bufc\_t *a\_bufc}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a\_bufc: ]
			Pointer to a \classname{bufc}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[retval: ]
			Size of \cvar{a\_bufc}'s internal buffer.
		\end{description}
	\item[Exception(s): ] None.
	\item[Description: ]
		Return the number of bytes in \cvar{a\_bufc}'s internal buffer.
	\end{description}
\end{description}

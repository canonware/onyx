.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_xep 3s "libstash, version <Version>"
.hy 1
.SH NAME
xep - Exception handling.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.PP
.I void
.br
.B xep_begin
.RI ( "void" )
.PP
.I void
.br
.B xep_end
.RI ( "void" )
.PP
.B xep_try
.I "..."
.PP
.B xep_catch
.RI ( "cw_xepv_t a_xepv" )
.I "..."
.PP
.B xep_mcatch
.RI ( "cw_xepv_t a_xepv" )
.I "..."
.PP
.B xep_acatch
.RI ( "void" )
.I "..."
.PP
.B xep_finally
.I "..."
.PP
.I cw_xepv_t
.br
.B xep_value
.RI ( "void" )
.PP
.I void
.br
.B xep_throw_e
.RI ( "cw_xepv_t a_xepv" ", " "const char *a_filename" ", " 
.IR "cw_uint32_t a_line_num" )
.br
.I void
.br
.B xep_throw
.RI ( "cw_xepv_t a_xepv" )
.PP
.I void
.br
.B xep_retry
.RI ( "void" )
.PP
.I void
.br
.B xep_handled
.RI ( "void" )
.SS Debugging (dbg) symbols
None.
.SH DESCRIPTION
The \fBxep\fR class implements exception handling, with support for
.IR xep_try ,
.IR xep_catch ,
and
.I xep_finally
blocks.  Minimal use must include at least:
.PP
.RS
.nf
xep_begin();
xep_try {
.in +8
/* Code that might throw an exception. */
.in -8
}
xep_end();
.fi
.RE
.PP
A more complete skeleton looks like:
.PP
.RS
.nf
xep_begin();
xep_try {
.in +8
/* Code that might throw an exception. */
.in -8
}
xep_catch(_CW_XEPV_SOME_EXCEPTION) {
.in +8
/* Handle exception... */
xep_handled();
.in -8
}
xep_catch(_CW_XEPV_ANOTHER_EXCEPTION)
xep_mcatch(_CW_XEPV_YET_ANOTHER) {
.in +8
/* React to exception, but propagate... */
.in -8
}
xep_acatch {
.in +8
/* Handle all exceptions not explicitly handled above... */
xep_handled();
.in -8
}
xep_finally {
.in +8
/* Execute after everything else. */
.in -8
}
xep_end();
.fi
.RE
.PP
Note that there is some serious cpp macro magic behind the \fBxep\fR interface,
and as such, if usage deviates significantly from the above templates, compiler
errors may result.
.PP
Exception values are of type cw_xepv_t.
-1 to -127 are reserved by \fBlibstash\fR, and other ranges may be reserved by
other libraries.
See their documentation for details.
.PP
An exception is not implicitly handled if an exception handler is executed for
that exception.
Instead, \fBxep_handled\fR() must be manually called to avoid propagating the
exception up the handler chain.
.SH USAGE
.I void
.br
.B xep_begin
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin an exception handling code block.
.RE
.RE
.PP
.I void
.br
.B xep_end
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
End an exception handling block.
.RE
.RE
.PP
.B xep_try
.I "..."
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin a block of code that is to be executed, with the possibility that an
exception might be thrown.
.RE
.RE
.PP
.B xep_catch
.RI ( "cw_xepv_t a_xepv" )
.I "..."
.RS
Input(s):
.RS
.IR a_xepv :
.RS
Exception number.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin a block of code that catches an exception.
The exception is not considered handled unless \fBxep_handled\fR() is called.
.RE
.RE
.PP
.B xep_mcatch
.RI ( "cw_xepv_t a_xepv" )
.I "..."
.RS
Input(s):
.RS
.IR a_xepv :
.RS
Exception number.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin a block of code that catches an exception.
Must immediately follow a \fBxep_catch\fR() call.
This interface is used for the case where more than one exception type is to be
handled by the same code block.
The exception is not considered handled unless \fBxep_handled\fR() is called.
.RE
.RE
.PP
.B xep_acatch
.RI ( "void" )
.I "..."
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin a block of code that catches all exceptions not explicitly caught by
\fBxep_catch\fR() and \fBxep_mcatch\fR() blocks.
There may only be one \fBxep_acatch\fR() block within a try/catch block.
The exception is not considered handled unless \fBxep_handled\fR() is called.
.RE
.RE
.PP
.B xep_finally
.I "..."
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Begin a block of code that is executed if no exceptions are thrown in the
exception handling code block or if an exception handler is executed.
.RE
.RE
.PP
.I cw_xepv_t
.br
.B xep_value
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
.IR retval :
.RS
Value of the current exception being handled.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return the value of the current exception being handled.
.RE
.RE
.PP
.I void
.br
.B xep_throw_e
.RI ( "cw_xepv_t a_xepv" ", " "const char *a_filename" ", " 
.IR "cw_uint32_t a_line_num" )
.br
.I void
.br
.B xep_throw
.RI ( "cw_xepv_t a_xepv" )
.RS
Input(s):
.RS
.IR a_xepv :
.RS
Exception number to throw.
.RE
.IR a_filename :
.RS
Should be __FILE__.
.RE
.IR a_line_num :
.RS
Should be __LINE__.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
a_xepv.
.RE
Description:
.RS
Throw an exception.
.RE
.RE
.PP
.I void
.br
.B xep_retry
.RI ( "void" )
.RS
Input(s):
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Implicitly handle the current exception and retry the xep_try code block.
.RE
.RE
.PP
.I void
.br
.B xep_handled
.RI ( "void" )
.RS
None.
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Mark the current exception as handled.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

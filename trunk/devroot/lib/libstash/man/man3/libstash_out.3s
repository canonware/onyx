.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_out 3s "libstash, version <Version>"
.Nm libstash_out
.hy 1
.SH NAME
out, spec - Formatted output (printf(3) replacement) and format specifier
helpers.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR

.SS Type definitions
.I typedef cw_uint32_t
.br
.B cw_out_render_t
.RI ( "const char *a_format" ", " "cw_uint32_t a_format_len" ", "
.IR "const void *a_arg" ", " "cw_uint32_t a_max_len" ", " "cw_uint8_t *r_str" )

.SS General
.I cw_out_t *
.br
.B out_new
.RI ( "cw_out_t *a_out" ", " "cw_out_t *a_mem" )

.I void
.br
.B out_delete
.RI ( "cw_out_t *a_out" )

.I cw_bool_t
.br
.B out_register
.RI ( "cw_out_t *a_out" ", " "const char *a_type" ", " "cw_uint32_t a_size"
.RI ", " "cw_out_render_t *a_render_func" )

.I void
.br
.B out_merge
.RI ( "cw_out_t *a_a" ", " "cw_out_t *a_b" )

.I cw_sint32_t
.br
.B out_get_default_fd
.RI ( "cw_out_t *a_out" )

.I void
.br
.B out_set_default_fd
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" )

.I cw_sint32_t
.br
.B out_put
.RI ( "cw_out_t *a_out" ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put
.RI ( "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_e
.RI ( "cw_out_t *a_out" ", " "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_e
.RI ( "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_l
.RI ( "cw_out_t *a_out" ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_l
.RI ( "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_le
.RI ( "cw_out_t *a_out" ", " "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_le
.RI ( "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_n
.RI ( "cw_out_t *a_out" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_n
.RI ( "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_f
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_f
.RI ( "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_fe
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_file_name" ", " "cw_uint32_t a_line_num" ", "
.IR "const char *a_func_name" ", " "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_fl
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_fle
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_file_name" ", " "cw_uint32_t a_line_num" ", "
.IR "const char *a_func_name" ", " "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_fn
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", " "cw_uint32_t a_size"
.RI ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_fn
.RI ( "cw_sint32_t a_fd" ", " "cw_uint32_t a_size"
.RI ", " "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_fv
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "va_list a_p" )

.I cw_sint32_t
.br
.B out_put_fvn
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "va_list a_p" )

.I cw_sint32_t
.br
.B out_put_s
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "const char *a_format"
.RI ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_s
.RI ( "char *a_str" ", " "const char *a_format"
.RI ", " "..." )

.I cw_sint32_t
.br
.B out_put_sa
.RI ( "cw_out_t *a_out" ", " "char **r_str" ", " "const char *a_format"
.RI ", " "..." )

.I cw_sint32_t
.br
.B out_put_sn
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_sn
.RI ( "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )

.I cw_sint32_t
.br
.B out_put_sv
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "const char *a_format"
.RI ", " "va_list a_p" )

.I cw_sint32_t
.br
.B out_put_sva
.RI ( "cw_out_t *a_out" ", " "char **r_str" ", " "const char *a_format"
.RI ", " "va_list a_p" )

.I cw_sint32_t
.br
.B out_put_svn
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "va_list a_p" )

.I cw_sint32_t
.br
.B spec_type_get
.RI ( "const char *a_spec" ", " "cw_uint32_t a_spec_len" ", "
.IR "const char **r_val" )

.I cw_sint32_t
.br
.B spec_val_get
.RI ( "const char *a_spec" ", " "cw_uint32_t a_spec_len" ", "
.IR "const char *a_name" ", " "cw_uint32_t a_name_len" ", "
.IR "const cw_uint8_t **r_val" )

.SS Debugging (dbg) symbols
None.

.SH DESCRIPTION
The out class provides functionality similar to the printf family of functions,
with the additional capability of dynamically adding handlers for non-builtin
types.

The syntax of formatting specifiers is significantly different than what printf
uses, since arbitrary flags must be supported.  Formatting specifiers are
delimited by `[' and `]'.  Following are some examples of formatting strings,
followed by explanations.

\*(lq[[\*(rq
Print a `[' character.  Due to the way C strings and `\\' protection work,
it is necessary to use a different escape character (`[').

\*(lq[s]\*(rq
Print a string.

\*(lq[s|w:10]\*(rq
 Print a string, padded to be at least 10 bytes long.

\*(lq[i|b:16|p:0|w:8]\*(rq
Print a 32 bit integer in base 16.  Pad the output to 8 bytes, using `0' for
the padding character.

As can be seen above, flags are specified as name/value pairs.  Each name and
value is separated by `:', and name/value pairs are separated from each other
(and the type specifier) by `|'.  Names and values can be of arbitrary length
(nonzero for names), and can contain any characters except (in some cases)
`]', `|', `:', and `\0'.  The parser may let these characters slip through in
some cases, but such behavior should not be relied on.  Some or all of the
following flags are supported for the builtin types:

.IR \*(lqw\*(rq : 
Minimum number of bytes of output.

.IR \*(lqj\*(rq :
Justification.  Legal values:
.RS
.IR \*(lqr\*(rq :
Right.
.br
.IR \*(lql\*(rq :
Left.
.br
.IR \*(lqc\*(rq :
Center.
.RE

.IR \*(lqp\*(rq :
Padding character.

.IR \*(lqb\*(rq :
Numerical base.  Legal bases are (2 <= base <= 36).

.IR \*(lqs\*(rq :
Signed/unsigned.  Legal values:
.RS
.IR \*(lqu\*(rq :
Unsigned.
.br
.IR \*(lqs\*(rq :
Signed.
.RE

.IR \*(lq+\*(rq :
Show sign.  Legal values:
.RS
.IR \*(lq-\*(rq :
Only print sign if output is negative.
.br
.IR \*(lq+\*(rq :
Always print sign.
.RE

The following is a matrix of the builtin output types, supported flags, and flag
defaults:

.TS
center box linesize(6) tab(@);
cb.
Field key
_
.T&
l.
 Supported?
 Default value
.TE

.TS H
center box linesize(6) tab(@);
cb s s s s s s.
Formatting names/values
_
.T&
lb | lb | lb | lb | lb | lb | lb.
 Type@w@j@p@b@s@+
_
.T&
l | l | l | l | l | l | l.
 i@Yes@Yes@Yes@Yes@Yes@Yes
 int32@Fit@r@` '@10@u@-
_
 q@Yes@Yes@Yes@Yes@Yes@Yes
 int64@Fit@r@` '@10@u@-
_
 c@Yes@Yes@Yes@No@No@No
 char@Fit@r@` '@@@
_
 s@Yes@Yes@Yes@No@No@No
 string@Fit@r@` '@@@
_
 p@Yes@Yes@Yes@Yes@Yes@Yes
 pointer@Fit@r@` '@16@u@-
_
 b@Yes@Yes@Yes@No@No@No
 buf@Fit@r@` '@@@
.TE

.SH USAGE
.I typedef cw_uint32_t
.br
.B cw_out_render_t
.RI ( "const char *a_format" ", " "cw_uint32_t a_format_len" ", " 
.IR "const void *a_arg" ", " "cw_uint8_t *r_str" )
.RS
Input(s):
.RS
.IR a_format :
.RS
Pointer to a format specifier.
.RE
.IR a_format_len :
.RS
Length in bytes of a_format.
.RE
.IR a_arg :
.RS
Pointer to object to be output.
.RE
.IR a_max_len :
.RS
Maximum number of bytes to output.
.RE
.IR r_str :
.RS
Pointer to space to render to.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes of output space that the corresponding rendering function needs.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Print a_arg, given the specification pointed to by a_format.
.RE
.RE

.I cw_out_t *
.br
.B out_new
.RI ( "cw_out_t *a_out" ", " "cw_out_t *a_mem" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to space for an out, or NULL.
.RE
.IR a_mem :
.RS
Pointer to the allocator to use internally.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to an out.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B out_delete
.RI ( "cw_out_t *a_out" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I cw_bool_t
.br
.B out_register
.RI ( "cw_out_t *a_out" ", " "const char *a_type" ", " "cw_uint32_t a_size"
.RI ", " "cw_out_render_t *a_render_func" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_type :
.RS
Pointer to a NULL-terminated string that represents a data type specifier.  The
string length (not including the NULL terminator) must be _LIBSTASH_OUT_MAX_TYPE
bytes or less.
.RE
.IR a_size :
.RS
sizeof(<data type>).  In almost all cases this will be sizeof(<data type> *).
a_size must be 1, 2, 4, or 8.
.RE
.IR a_render_func :
.RS
Pointer to a rendering function.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Register a new type with a_out, so that non-builtin type specifiers can be
embedded in formatting strings.
.RE
.RE

.I void
.br
.B out_merge
.RI ( "cw_out_t *a_a" ", " "cw_out_t *a_b" )
.RS
Input(s):
.RS
.IR a_a :
.RS
Pointer to an out.
.RE
.IR a_b :
.RS
Pointer to an out.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Merge a_b's extended type handlers into a_a.
.RE
.RE

.I cw_sint32_t
.br
.B out_get_default_fd
.RI ( "cw_out_t *a_out" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
File descriptor number.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return a_out's default file descriptor.
.RE
.RE

.I void
.br
.B out_set_default_fd
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor number.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Set a_out's default file descriptor number.
.RE
.RE

.I cw_sint32_t
.br
.B out_put
.RI ( "cw_out_t *a_out" ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put
.RI ( "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_out's default file descriptor (2 if (NULL == a_out)).
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_e
.RI ( "cw_out_t *a_out" ", " "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_e
.RI ( "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_file_name :
.RS
Pointer to a string that represents the source file name, or NULL.
.RE
.IR a_line_num :
.RS
Source file line number.  Ignored if (NULL == a_file_name).
.RE
.IR a_func_name :
.RS
Pointer to a string that represents the source function name, or NULL.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_out's default file descriptor (2 if (NULL == a_out)).
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with optional
.br
\*(lqAt <file>, line <line>: <function>(): \*(rq
.br
prepended to the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_l
.RI ( "cw_out_t *a_out" ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_l
.RI ( "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_out's default file descriptor (2 if (NULL == a_out)).
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with \*(lq[yy/mm/dd hh:mm:ss (zz)]: \*(rq prepended to
the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_le
.RI ( "cw_out_t *a_out" ", " "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_le
.RI ( "const char *a_file_name" ", "
.IR "cw_uint32_t a_line_num" ", " "const char *a_func_name" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_file_name :
.RS
Pointer to a string that represents the source file name, or NULL.
.RE
.IR a_line_num :
.RS
Source file line number.  Ignored if (NULL == a_file_name).
.RE
.IR a_func_name :
.RS
Pointer to a string that represents the source function name, or NULL.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_out's default file descriptor (2 if (NULL == a_out)).
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with \*(lq[yy/mm/dd hh:mm:ss (zz)]: \*(rq and optional
\*(lqAt <file>, line <line>: <function>(): \*(rq prepended to the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_n
.RI ( "cw_out_t *a_out" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_n
.RI ( "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_size :
.RS
Maximum number of characters to output.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_out's default file descriptor (2 if (NULL == a_out)).
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print at most a_size bytes of formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_f
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_f
.RI ( "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fe
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_file_name" ", " "cw_uint32_t a_line_num" ", "
.IR "const char *a_func_name" ", " "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_file_name :
.RS
Pointer to a string that represents the source file name, or NULL.
.RE
.IR a_line_num :
.RS
Source file line number.  Ignored if (NULL == a_file_name).
.RE
.IR a_func_name :
.RS
Pointer to a string that represents the source function name, or NULL.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with optional
.br
\*(lqAt <file>, line <line>: <function>(): \*(rq
.br
prepended to the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fl
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with \*(lq[yy/mm/dd hh:mm:ss (zz)]: \*(rq prepended to
the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fle
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_file_name" ", " "cw_uint32_t a_line_num" ", "
.IR "const char *a_func_name" ", " "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_file_name :
.RS
Pointer to a string that represents the source file name, or NULL.
.RE
.IR a_line_num :
.RS
Source file line number.  Ignored if (NULL == a_file_name).
.RE
.IR a_func_name :
.RS
Pointer to a string that represents the source function name, or NULL.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output, with \*(lq[yy/mm/dd hh:mm:ss (zz)]: \*(rq and optional
\*(lqAt <file>, line <line>: <function>(): \*(rq prepended to the output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fn
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", " "cw_uint32_t a_size"
.RI ", " "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_fn
.RI ( "cw_sint32_t a_fd" ", " "cw_uint32_t a_size"
.RI ", " "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_size :
.RS
Maximum number of characters to output.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print at most a_size bytes of formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fv
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", "
.IR "const char *a_format" ", " "va_list a_p" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR a_p :
.RS
Variable argument list.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_fvn
.RI ( "cw_out_t *a_out" ", " "cw_sint32_t a_fd" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "va_list a_p" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_fd :
.RS
File descriptor_number.
.RE
.IR a_size :
.RS
Maximum number of characters to output.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR a_p :
.RS
Variable argument list.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Number of bytes output.
.br
-1: write() error.
.RE
Output printed to a_fd.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_s
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "const char *a_format"
.RI ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_s
.RI ( "char *a_str" ", " "const char *a_format"
.RI ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_str :
.RS
Pointer to output string.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.IR a_str :
.RS
Formatted output.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_sa
.RI ( "cw_out_t *a_out" ", " "char **r_str" ", " "const char *a_format"
.RI ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR r_str :
.RS
Pointer to a string pointer.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.RE
.IR *r_str :
.RS
Formatted output, or undefined if error.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Allocate space, then print formatted output to it.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_sn
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.br
.I cw_sint32_t
.br
.B _cw_out_put_sn
.RI ( "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "..." )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_str :
.RS
Pointer to output string.
.RE
.IR a_size :
.RS
Maximum number of characters to output.  If a_size is less than or equal to the
number of bytes that could be output, were there no limit, then no `\\0' string
termination byte is written.  Therefore, if the caller is depending on such
string termination, care should be taken to specify a_size as one less than the
total string length, and to make sure that if the string is completely filled
with output, that the last byte is set to `\\0'.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR ... :
.RS
Arguments that correspond to the specifiers in a_format.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.RE
.IR a_str :
.RS
Formatted output.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print at most a_size bytes of formatted output.

.RE
.RE

.I cw_sint32_t
.br
.B out_put_sv
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "const char *a_format"
.RI ", " "va_list a_p" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_str :
.RS
Pointer to output string.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR a_p :
.RS
Variable argument list.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.RE
.IR a_str :
.RS
Formatted output.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_sva
.RI ( "cw_out_t *a_out" ", " "char **r_str" ", " "const char *a_format"
.RI ", " "va_list a_p" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR r_str :
.RS
Pointer to a string pointer.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR a_p :
.RS
Variable argument list.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.RE
.IR *r_str :
.RS
Formatted output, or undefined if error.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Allocate space, then print formatted output to it.
.RE
.RE

.I cw_sint32_t
.br
.B out_put_svn
.RI ( "cw_out_t *a_out" ", " "char *a_str" ", " "cw_uint32_t a_size" ", "
.IR "const char *a_format" ", " "va_list a_p" )
.RS
Input(s):
.RS
.IR a_out :
.RS
Pointer to an out.
.RE
.IR a_str :
.RS
Pointer to output string.
.RE
.IR a_size :
.RS
Maximum number of characters to output.  If a_size is less than or equal to the
number of bytes that could be output, were there no limit, then no `\\0' string
termination byte is written.  Therefore, if the caller is depending on such
string termination, care should be taken to specify a_size as one less than the
total string length, and to make sure that if the string is completely filled
with output, that the last byte is set to `\\0'.
.RE
.IR a_format :
.RS
Pointer to a formatting specifier string.
.RE
.IR a_p :
.RS
Variable argument list.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes output, not including the terminating '\\0'.
.RE
.IR a_str :
.RS
Formatted output.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.br
_CW_XEPV_OUT_PARSE.
.RE
Description:
.RS
Print at most a_size bytes of formatted output.
.RE
.RE

.I cw_sint32_t
.br
.B spec_type_get
.RI ( "const char *a_spec" ", " "cw_uint32_t a_spec_len" ", "
.IR "const char **r_val" )
.RS
Input(s):
.RS
.IR a_spec :
.RS
Pointer to a specifier string.
.RE
.IR a_spec_len :
.RS
Length of a_spec.
.RE
.IR r_val :
.RS
Pointer to a string pointer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Length of type value string.
.RE
.IR *r_val :
.RS
Pointer to type value string.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return the length of the type value string, and set *r_val to point to it.
.RE
.RE

.I cw_sint32_t
.br
.B spec_val_get
.RI ( "const char *a_spec" ", " "cw_uint32_t a_spec_len" ", "
.IR "const char *a_name" ", " "cw_uint32_t a_name_len" ", "
.IR "const cw_uint8_t **r_val" )
.RS
Input(s):
.RS
.IR a_spec :
.RS
Pointer to a specifier string.
.RE
.IR a_spec_len :
.RS
Length of a_spec.
.RE
.IR a_name :
.RS
Pointer to a NULL-terminated name.
.RE
.IR a_name_len :
.RS
Length of a_name.
.RE
.IR r_val :
.RS
Pointer to a string pointer.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>= 0: Length of value string.
.br
-1: No such name.
.RE
.IR *r_val :
.RS
Pointer to value string.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return the length of the value string that corresponds to a_spec, and set *r_val
to point to it.
.RE
.RE

.SH SEE ALSO
libstash(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

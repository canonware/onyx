.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_ring 3s "libstash, version <Version>"
.Nm libstash_ring
.hy 1
.SH NAME
ring - Doubly linked ring, similar to a doubly linked list.
.SH SYNOPSIS
.SS Single-threaded
\fB#include <libstash/libstash.h>\fR

.SS Multi-threaded
\fB#include <libstash/libstash_r.h>\fR

.SS General
.I cw_ring_t *
.br
.B ring_new
.RI ( "cw_ring_t * a_ring" ", " 
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * ring)" ", " 
.IR "void * a_dealloc_arg" )

.I void
.br
.B ring_delete
.RI ( "cw_ring_t * a_ring" )

.I void
.br
.B ring_dump
.RI ( "cw_ring_t * a_ring" ", " "const char * a_prefix" )

.I void *
.br
.B ring_get_data
.RI ( "cw_ring_t * a_ring" )

.I void
.br
.B ring_set_data
.RI ( "cw_ring_t * a_ring" ", " "void * a_data" )

.I cw_ring_t *
.br
.B ring_next
.RI ( "cw_ring_t * a_ring" )

.I cw_ring_t *
.br
.B ring_prev
.RI ( "cw_ring_t * a_ring" )

.I void
.br
.B ring_meld
.RI ( "cw_ring_t * a_a" ", " "cw_ring_t * a_b" )

.I cw_ring_t *
.br
.B ring_cut
.RI ( "cw_ring_t * a_ring" )

.I void
.br
.B ring_split
.RI ( "cw_ring_t * a_a" ", " "cw_ring_t * a_b" )

.SS Debugging (dbg) symbols
None.

.SH DESCRIPTION
Rings have similar uses to doubly linked lists, but they are much faster and
simpler.  There is no concept of head and tail.  Every element in the ring can
be used in the same way.  That is, it is possible (and legitimate) to
simultaneously have pointers to more than one element in the ring and operate on
them in like ways.

Since all elements are effectively equal, and there is no head or tail, there is
no need for a master ring object.  This is a nice simplification, but has the
disadvantage of making built in thread safeness impractical.  Therefore
\fBring\fR operations are not thread safe.

.SH USAGE
.I cw_ring_t *
.br
.B ring_new
.RI ( "cw_ring_t * a_ring" ", " 
.IR "void (*a_dealloc_func)(void * dealloc_arg, void * ring)" ", " 
.IR "void * a_dealloc_arg" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.IR a_dealloc_func :
.RS
Pointer to a deallocation function, or NULL.  Ignored if (NULL == a_ring).
.RE
.IR a_dealloc_arg :
.RS
First argument to a_dealloc_func.  Not used if (NULL == a_ring) or (NULL ==
a_dealloc_func).
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a ring.
.br
NULL: Memory allocation error.  Can only happen if (NULL == a_ring).
.RE
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B ring_delete
.RI ( "cw_ring_t * a_ring" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I void
.br
.B ring_dump
.RI ( "cw_ring_t * a_ring" ", " "const char * a_prefix" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.IR a_prefix :
.RS
String constant that is used as a prefix for each line of output.
.RE
.RE
Output(s):
.RS
Output printed to cw_g_out.
.RE
Description:
.RS
Dump the internals of a_ring to cw_g_out.
.RE
.RE

.I void *
.br
.B ring_get_data
.RI ( "cw_ring_t * a_ring" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Data pointer.
.RE
.RE
Description:
.RS
Return the value of a_ring's data pointer.
.RE
.RE

.I void
.br
.B ring_set_data
.RI ( "cw_ring_t * a_ring" ", " "void * a_data" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.IR a_data :
.RS
Data pointer.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Set a_ring's data pointer to a_data.
.RE
.RE

.I cw_ring_t *
.br
.B ring_next
.RI ( "cw_ring_t * a_ring" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a ring.
.RE
.RE
Description:
.RS
Return a pointer to the next element in a_ring.
.RE
.RE

.I cw_ring_t *
.br
.B ring_prev
.RI ( "cw_ring_t * a_ring" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a ring.
.RE
.RE
Description:
.RS
Return a pointer to the previous element in a_ring.
.RE
.RE

.I void
.br
.B ring_meld
.RI ( "cw_ring_t * a_a" ", " "cw_ring_t * a_b" )
.br
Input(s):
.RS
.IR a_a :
.RS
Pointer to a ring.
.RE
.IR a_b :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
None.
.RE
.RE
Description:
.RS
Combine a_a and a_b into one ring.
.RE
.RE

.I cw_ring_t *
.br
.B ring_cut
.RI ( "cw_ring_t * a_ring" )
.br
Input(s):
.RS
.IR a_ring :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a ring.
.RE
.RE
Description:
.RS
Remove a_ring from the rest of the ring and return the new ring.
.RE
.RE

.I void
.br
.B ring_split
.RI ( "cw_ring_t * a_a" ", " "cw_ring_t * a_b" )
.br
Input(s):
.RS
.IR a_a :
.RS
Pointer to a ring.
.RE
.IR a_b :
.RS
Pointer to a ring.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Given a_a and a_b in the same ring, split the ring such that a_a and a_b are the
\*(lqheads\*(rq of the resulting rings.  This function is safe even for a ring
with only one node, and even if (a_a == a_b) for a ring with multiple nodes.
.RE
.RE

.SH SEE ALSO
libstash(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

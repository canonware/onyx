.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_ch 3s "libstash, version <Version>"
.hy 1
.SH NAME
ch - Chained hashing.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR
.PP
.I cw_ch_t *
.br
.B ch_new
.RI ( "cw_ch_t *a_ch" ", " "cw_mem_t *a_mem" ", " "cw_uint32_t a_table_size"
.RI ", " "cw_ch_hash_t *a_hash" ", " "cw_ch_key_comp_t *a_key_comp" )
.PP
.I void
.br
.B ch_delete
.RI ( "cw_ch_t *a_ch" )
.PP
.I cw_uint32_t
.br
.B ch_count
.RI ( "cw_ch_t *a_ch" )
.PP
.I void
.br
.B ch_insert
.RI ( "cw_ch_t *a_ch" ", " "const void *a_key" ", " "const void *a_data" 
.RI ", " "cw_chi_t *a_chi" )
.PP
.I cw_bool_t
.br
.B ch_remove
.RI ( "cw_ch_t *a_ch" ", " "const void *a_search_key" ", " "void **r_key" ", "
.IR "void **r_data" ", " "cw_chi_t **r_chi" )
.PP
.I cw_bool_t
.br
.B ch_search
.RI ( "cw_ch_t *a_ch" ", " "const void *a_key" ", " "void **r_data" )
.PP
.I cw_bool_t
.br
.B ch_get_iterate
.RI ( "cw_ch_t *a_ch" ", "  "void **r_key" ", " "void **r_data" )
.PP
.I cw_bool_t
.br
.B ch_remove_iterate
.RI ( "cw_ch_t *a_ch" ", " "void **r_key" ", " "void **r_data" ", "
.IR "cw_chi_t **r_chi" )
.PP
.I void
.br
.B ch_dump
.RI ( "cw_ch_t *a_ch" ", " "const char *a_prefix" )
.PP
.I cw_uint32_t
.br
.B ch_string_hash
.RI ( "const void *a_key" )
.PP
.I cw_uint32_t
.br
.B ch_direct_hash
.RI ( "const void *a_key" )
.PP
.I cw_bool_t
.br
.B ch_string_key_comp
.RI ( "const void *a_k1" ", " "const void *a_k2" )
.PP
.I cw_bool_t
.br
.B ch_direct_key_comp
.RI ( "const void *a_k1" ", " "const void *a_k2" )
.SS Debugging (dbg) symbols
None.
.SH DESCRIPTION
Chained hashing class.  This is a simple bucket chaining hash table
implementation.  Table size is set at creation time, and cannot be changed, so
performance will suffer if a \fBch\fR is over-filled.  The main \fBcw_ch_t\fR
data structure and the table are contiguously allocated, which means that care
must be taken when manually pre-allocating space for the structure (see details
in the USAGE section).  Each item that is inserted into the \fBch\fR is
encapsulated by a \fBcw_chi_t\fR object, for which space can optionally be
passed in as a parameter to \fBch_insert\fR().  If no space for the \fBchi\fR is
passed in, the \fBmem\fR class is used internally for allocation.
.PP
Multiple entries with the same key are allowed and are stored in LIFO order.
.PP
Calling \fBch_remove_iterate\fR() and \fBch_get_iterate\fR() are guaranteed to
operate on the oldest item in the hash table, which means that the hash code has
an integrated FIFO queue.
.PP
\fBch\fR is meant to be as small and simple as reasonably possible without
compromising performance.  Note that it is not well suited for situations where
the number of items can vary wildly.
.SH USAGE
.I cw_ch_t *
.br
.B ch_new
.RI ( "cw_ch_t *a_ch" ", " "cw_mem_t *a_mem" ", " "cw_uint32_t a_table_size"
.RI ", " "cw_ch_hash_t *a_hash" ", " "cw_ch_key_comp_t *a_key_comp" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to space for a ch with a_table_size slots, or NULL.  Use the
_CW_CH_TABLE2SIZEOF() macro to calculate the total space needed for a given
table size.
.RE
.IR a_mem :
.RS
Pointer to the allocator to use internally.
.RE
.IR a_table_size :
.RS
Number of slots in the hash table.
.RE
.IR a_hash :
.RS
Pointer to a hashing function.
.RE
.IR a_key_comp :
.RS
Pointer to a key comparison function.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a ch.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor.
.RE
.RE
.PP
.I void
.br
.B ch_delete
.RI ( "cw_ch_t *a_ch" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE
.PP
.I cw_uint32_t
.br
.B ch_count
.RI ( "cw_ch_t *a_ch" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of items in a_ch.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Return the number of items in a_ch.
.RE
.RE
.PP
.I void
.br
.B ch_insert
.RI ( "cw_ch_t *a_ch" ", " "const void *a_key" ", " "const void *a_data"
.RI ", " "cw_chi_t *a_chi" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR a_key :
.RS
Pointer to a key.
.RE
.IR a_data :
.RS
Pointer to data associated with a_key.
.RE
.IR a_chi :
.RS
Pointer to space for a chi, or NULL.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Insert a_data into a_ch, using key a_key.  Use a_chi for the internal chi
container if non-NULL.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_remove
.RI ( "cw_ch_t *a_ch" ", " "const void *a_search_key" ", " "void **r_key" ", "
.IR "void **r_data" ", " "cw_chi_t **r_chi" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR a_search_key :
.RS
Pointer to a key.
.RE
.IR r_key :
.RS
Pointer to a key pointer, or NULL.
.RE
.IR r_data :
.RS
Pointer to a data pointer, or NULL.
.RE
.IR r_chi :
.RS
Pointer to a chi pointer, or NULL.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Item with key a_search_key not found.
.RE
.IR *r_key :
.RS
If (r_key != NULL) and (retval == FALSE): Pointer to a key.
.br
Otherwise: Undefined.
.RE
.IR *r_data :
.RS
If (r_data != NULL) and (retval == FALSE): Pointer to data.
.br
Otherwise: Undefined.
.RE
.IR *r_chi :
.RS
If (r_chi != NULL) and (retval == FALSE): Pointer to space for a chi, or NULL.
.br
Otherwise: Undefined.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Remove the item from a_ch that was most recently inserted with key
a_search_key.  If successful, set *r_key and *r_data to point to the key,
data, and externally allocated chi, respectively.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_search
.RI ( "cw_ch_t *a_ch" ", " "const void *a_key" ", " "void **r_data" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR a_key :
.RS
Pointer to a key.
.RE
.IR r_data :
.RS
Pointer to a data pointer, or NULL.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Item with key a_key not found in a_ch.
.RE
.IR *r_data :
.RS
If (r_data != NULL) and (retval == FALSE): Pointer to data.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Search for the most recently inserted item with key a_key.  If found, *r_data to
point to the associated data.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_get_iterate
.RI ( "cw_ch_t *a_ch" ", "  "void **r_key" ", " "void **r_data" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR r_key :
.RS
Pointer to a key pointer, or NULL.
.RE
.IR r_data :
.RS
Pointer to a data pointer, or NULL.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: a_ch is empty.
.RE
.IR *r_key :
.RS
If (r_key != NULL) and (retval == FALSE): Pointer to a key.
.br
Otherwise: Undefined.
.RE
.IR *r_data :
.RS
If (r_data != NULL) and (retval == FALSE): Pointer to data.
.br
Otherwise: Undefined.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Set *r_key and *r_data to point to the oldest item in a_ch.  Promote the item so
that it is the newest item in a_ch.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_remove_iterate
.RI ( "cw_ch_t *a_ch" ", " "void **r_key" ", " "void **r_data" ", "
.IR "cw_chi_t **r_chi" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR r_key :
.RS
Pointer to a key pointer, or NULL.
.RE
.IR r_data :
.RS
Pointer to a data pointer, or NULL.
.RE
.IR r_chi :
.RS
Pointer to a chi pointer, or NULL.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: a_ch is empty.
.RE
.IR *r_key :
.RS
If (r_key != NULL) and (retval == FALSE): Pointer to a key.
.br
Otherwise: Undefined.
.RE
.IR *r_data :
.RS
If (r_data != NULL) and (retval == FALSE): Pointer to data.
.br
Otherwise: Undefined.
.RE
.IR *r_chi :
.RS
If (r_chi != NULL) and (retval == FALSE): Pointer to a chi, or NULL.
.br
Otherwise: Undefined.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Set *r_key and *r_data to point to the oldest item in a_ch, set *r_chi to point
to the item's container, if externally allocated, and remove the item from a_ch.
.RE
.RE
.PP
.I void
.br
.B ch_dump
.RI ( "cw_ch_t *a_ch" ", " "const char *a_prefix" )
.RS
Input(s):
.RS
.IR a_ch :
.RS
Pointer to a ch.
.RE
.IR a_prefix :
.RS
A text string to prefix to all output.
.RE
.RE
Output(s):
.RS
Internal state of a_ch printed to cw_g_out.
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Print the internal state of a_ch.
.RE
.RE
.PP
.I cw_uint32_t
.br
.B ch_string_hash
.RI ( "const void *a_key" )
.RS
Input(s):
.RS
.IR a_key :
.RS
Pointer to a key.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Hash result.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
NULL-terminated string hashing function.
.RE
.RE
.PP
.I cw_uint32_t
.br
.B ch_direct_hash
.RI ( "const void *a_key" )
.RS
Input(s):
.RS
.IR a_key :
.RS
Pointer to a key.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Hash result.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Direct (pointer) hashing function.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_string_key_comp
.RI ( "const void *a_k1" ", " "const void *a_k2" )
.RS
Input(s):
.RS
.IR a_k1 :
.RS
Pointer to a key.
.RE
.IR a_k2 :
.RS
Pointer to a key.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Not equal.
.br
TRUE: Equal.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Test two keys (NULL-terminated strings) for equality.
.RE
.RE
.PP
.I cw_bool_t
.br
.B ch_direct_key_comp
.RI ( "const void *a_k1" ", " "const void *a_k2" )
.RS
Input(s):
.RS
.IR a_k1 :
.RS
Pointer to a key.
.RE
.IR a_k2 :
.RS
Pointer to a key.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Not equal.
.br
TRUE: Equal.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Test two keys (pointers) for equality.
.RE
.RE
.SH SEE ALSO
libstash(3s).
.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

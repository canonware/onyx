.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libstash_sema 3s "libstash, version <Version>"
.Nm libstash_sema
.hy 1
.SH NAME
sema - Semaphore.
.SH SYNOPSIS
\fB#include <libstash/libstash.h>\fR

.I cw_sema_t *
.br
.B sema_new
.RI ( "cw_sema_t *a_sema" ", " "cw_sint32_t a_count" )

.I void
.br
.B sema_delete
.RI ( "cw_sema_t *a_sema" )

.I void
.br
.B sema_post
.RI ( "cw_sema_t *a_sema" )

.I void
.br
.B sema_wait
.RI ( "cw_sema_t *a_sema" )

.I cw_bool_t
.br
.B sema_timedwait
.RI ( "cw_sema_t *a_sema" ", " "struct timespec *a_timeout" )

.I cw_bool_t
.br
.B sema_trywait
.RI ( "cw_sema_t *a_sema" )

.I cw_sint32_t
.br
.B sema_getvalue
.RI ( "cw_sema_t *a_sema" )

.I void
.br
.B sema_adjust
.RI ( "cw_sema_t *a_sema" ", " "cw_sint32_t a_adjust" )

.SS Debugging (dbg) symbols
None.

.SH DESCRIPTION
\fBsem\fR implements semaphores.  This implementation is a bit different than
normal, in that it is possible to decrement the count to less than zero.  This
allows dynamic modification of resource pools locked by semaphores.

.SH USAGE
.I cw_sema_t *
.br
.B sema_new
.RI ( "cw_sema_t *a_sema" ", " "cw_sint32_t a_count" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to space for a sema.
.RE
.IR a_count :
.RS
Initial value of semaphore.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Pointer to a sema.
.RE
.RE
Exception(s):
.RS
_CW_XEPV_OOM.
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B sema_delete
.RI ( "cw_sema_t *a_sema" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I void
.br
.B sema_post
.RI ( "cw_sema_t *a_sema" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Post (increment) a_sema.
.RE
.RE

.I void
.br
.B sema_wait
.RI ( "cw_sema_t *a_sema" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Wait on (block until able to decrement) a_sema.
.RE
.RE

.I cw_bool_t
.br
.B sema_timedwait
.RI ( "cw_sema_t *a_sema" ", " "struct timespec *a_timeout" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.IR a_timeout :
.RS
Timeout, specified as an absolute time interval.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Failure.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Try to wait on (decrement) a_sema, but return after a_timeout has expired if
unable to.
.RE
.RE

.I cw_bool_t
.br
.B sema_trywait
.RI ( "cw_sema_t *a_sema" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Failure.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Try to wait on (decrement) a_sema, but return immediately instead of blocking if
unable to.
.RE
.RE

.I cw_sint32_t
.br
.B sema_getvalue
.RI ( "cw_sema_t *a_sema" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Value of semaphore.
.RE
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Get value of a_sema.
.RE
.RE

.I void
.br
.B sema_adjust
.RI ( "cw_sema_t *a_sema" ", " "cw_sint32_t a_adjust" )
.RS
Input(s):
.RS
.IR a_sema :
.RS
Pointer to a sema.
.RE
.IR a_adjust :
.RS
Amount to adjust the value of a_sema by.
.RE
.RE
Output(s):
.RS
None.
.RE
Exception(s):
.RS
None.
.RE
Description:
.RS
Adjust a_sema by a_adjust.
.RE
.RE

.SH SEE ALSO
libstash(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

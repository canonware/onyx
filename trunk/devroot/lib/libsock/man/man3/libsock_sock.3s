.ig \" -*-mode:nroff-*-

<Copyright = jasone>
<License>

Version: <Version>
..
.TH libsock_sock 3s "libsock, version <Version>"
.Nm libsock
.hy 1
.SH NAME
sock - Asynchronous TCP/IP socket I/O.
.SH SYNOPSIS
\fB#include <libsock/libsock.h>\fR

.I cw_sock_t
.br
.B sock_new
.RI ( "cw_sock_t *a_sock" ", " "cw_uint32_t a_in_max_buf_size" )

.I void
.br
.B sock_delete
.RI ( "cw_sock_t *a_sock" )

.I cw_bool_t
.br
.B sock_is_connected
.RI ( "cw_sock_t *a_sock" )

.I cw_uint32_t
.br
.B sock_get_port
.RI ( "cw_sock_t *a_sock" )

.I cw_sint32_t
.br
.B sock_connect
.RI ( "cw_sock_t *a_sock" ", " "const char *a_server_host" ", " "int a_port"
.RI ", " "struct timespec *a_timeout" )

.I cw_bool_t
.br
.B sock_wrap
.RI ( "cw_sock_t *a_sock" ", " "int a_sockfd" ", " "cw_bool_t a_init" )

.I cw_bool_t
.br
.B sock_disconnect
.RI ( "cw_sock_t *a_sock" )

.I cw_uint32_t
.br
.B sock_buffered_in
.RI ( "cw_sock_t *a_sock" )

.I cw_sint32_t
.br
.B sock_read
.RI ( "cw_sock_t *a_sock" ", " "cw_buf_t *a_spare" ", "
.IR "cw_sint32_t a_max_read" ", " "struct timespec *a_timeout" )

.I cw_bool_t
.br
.B sock_write
.RI ( "cw_sock_t *a_sock" ", " "cw_buf_t *a_buf" )

.I cw_bool_t
.br
.B sock_flush_out
.RI ( "cw_sock_t *a_sock" )

.I int
.br
.B sock_get_fd
.RI ( "cw_sock_t *a_sock" )

.SS Debugging (dbg) symbols
.TP
\*(lqsock_error\*(rq
Error conditions that indicate that there is either a communication channel
problem, or that there is something going wrong with the application.
.TP
\*(lqsock_sockopt\*(rq
Diagnostic information regarding sockets.

.SH DESCRIPTION
\fBsock\fR encapsulates a TCP/IP socket and provides an abstracted API that
allows completely asynchronous socket I/O.

.SH USAGE
.I cw_sock_t
.br
.B sock_new
.RI ( "cw_sock_t *a_sock" ", " "cw_uint32_t a_in_max_buf_size" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.IR a_in_max_buf_size :
.RS
Maximum number of bytes of incoming data to buffer.  A value of 0 will prevent
the I/O thread from ever trying to read from the discriptor.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
non-NULL: Pointer to a sock.
.br
NULL: Memory allocation error.
.RE
.RE
Description:
.RS
Constructor.
.RE
.RE

.I void
.br
.B sock_delete
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
None.
.RE
Description:
.RS
Destructor.
.RE
.RE

.I cw_bool_t
.br
.B sock_is_connected
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Not connected.
.br
TRUE: Connected.
.RE
.RE
Description:
.RS
Return TRUE if a_sock is connected.
.RE
.RE

.I cw_uint32_t
.br
.B sock_get_port
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Port number on this end of the connection.
.RE
.RE
Description:
.RS
Return the local port number for the socket.
.RE
.RE

.I cw_sint32_t
.br
.B sock_connect
.RI ( "cw_sock_t *a_sock" ", " "const char *a_server_host" ", " "int a_port"
.RI ", " "struct timespec *a_timeout" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.IR a_server_host :
.RS
String that represents remote hostname or IP address.
.RE
.IR a_port :
.RS
Remote port number to connect to.
.RE
.IR a_timeout :
.RS
Connect timeout, specified as an absolute time interval, or NULL for no timeout.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
-1: Already connected, \fBsocket\fR() error, \fBclose\fR() error,
\fBsock_p_config_socket\fR() error, \fBlibsock_l_get_host_ip\fR() error, or
\fBconnect\fR() error.
.br
0: Success.
.br
1: Timeout.
.RE
.RE
Description:
.RS
Connect to a remote socket.  If (retval == 1), \fBsock_connect\fR() can be
called again in order to attempt completing a non-blocking connect.
.RE
.RE

.I cw_bool_t
.br
.B sock_wrap
.RI ( "cw_sock_t *a_sock" ", " "int a_sockfd" ", " "cw_bool_t a_init" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.IR a_sock_fd :
.RS
File descriptor number.
.RE
.IR a_init :
.RS
FALSE: Use a_sockfd as is.
.br
TRUE: Initialize a_sockfd.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: \fBsock_p_config_socket\fR() error.
.RE
.RE
Description:
.RS
Wrap an open socket descriptor inside a sock.
.RE
.RE

.I cw_bool_t
.br
.B sock_disconnect
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Not connected, \fBfcntl\fR() error, or \fBclose\fR() error.
.RE
.RE
Description:
.RS
Disconnect a_sock.
.RE
.RE

.I cw_uint32_t
.br
.B sock_buffered_in
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
Number of bytes of buffered incoming data.
.RE
.RE
Description:
.RS
Return the number of bytes of buffered incoming data.
.RE
.RE

.I cw_sint32_t
.br
.B sock_read
.RI ( "cw_sock_t *a_sock" ", " "cw_buf_t *a_spare" ", "
.IR "cw_sint32_t a_max_read" ", " "struct timespec *a_timeout" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.IR a_spare :
.RS
Pointer to a spare cw_buf_t, to which data may be appended.
.RE
.IR a_max_read :
.RS
Maximum number of bytes to read into a_spare, or 0 for no limit.
.RE
.IR a_timeout :
.RS
Maximum time to wait for data before returning, or NULL to wait indefinitely.
To avoid blocking, pass a zero timeout value.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
-2: Error.  This should only happen if the socket has been closed.
.br
-1: Memory allocation error.
.br
0: Timeout.
.br
>0: Number of bytes of data read.
.RE
.RE
Description:
.RS
Read data from the socket, and don't return until there is data (not necessarily
a_max_read), or the timeout expires.
.RE
.RE

.I cw_bool_t
.br
.B sock_write
.RI ( "cw_sock_t *a_sock" ", " "cw_buf_t *a_buf" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.IR a_buf :
.RS
Pointer to a buf.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Error.
.RE
.RE
Description:
.RS
Queue the data in a_buf for writing.  Once the data has been added to the write
queue, notify the I/O thread.
.RE
.RE

.I cw_bool_t
.br
.B sock_flush_out
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
FALSE: Success.
.br
TRUE: Error.
.RE
.RE
Description:
.RS
Flush the outgoing data queue (actually, just wait until it has all been sent),
and don't return until done.
.RE
.RE

.I int
.br
.B sock_get_fd
.RI ( "cw_sock_t *a_sock" )
.RS
Input(s):
.RS
.IR a_sock :
.RS
Pointer to a sock.
.RE
.RE
Output(s):
.RS
.IR retval :
.RS
>=0: File descriptor corresponding to a_sock.
.br
-1: Not connected.
.RE
.RE
Description:
.RS
Return the number of the file descriptor for a_sock's socket.
.RE
.RE

.SH SEE ALSO
libsock(3s).

.SH HISTORY
Written by Jason Evans <jasone@canonware.com>.

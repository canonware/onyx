%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% Onyx tutorial portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Tutorial}
\label{onyxtut}

This manual includes a comprehensive \htmlref{Onyx Language Reference}{onyxlang}
chapter, which explains the details of what Onyx is.  However, that chapter is
rather dry, and more importantly, it does not discuss how to best utilize Onyx.
This chapter introduces concepts that are important when designing and
implementing Onyx programs.  Onyx is a stack-based language, so although the
ideas that are important to program design in other more traditional languages
still apply in many cases, there are different ways of approaching certain
problems that integrate better with the facilities provided by Onyx.

The most obvious example of this is that Onyx programs are more efficient if
written to use named variables as little as possible, relying instead on the
power of the operand stack.  Another example is error handling.  It is possible
to write procedures that check for every error condition, but Onyx provides a
form of exception handling that, if used correctly, can significantly improve
code readability and performance.

Accomplished PostScript programmers will find almost nothing new in this
chapter; Onyx differs from PostScript in the details, but the concepts are very
similar.  Accomplished Forth programmers will already be comfortable with stack
management, but the rest of the chapter discusses concepts that either have no
Forth equivalent, or that are significantly different from Forth, as is the case
for dictionaries.

\section{Syntax}

\section{Data types}

Onyx includes a rich set of data types.  In fact, Onyx code is represented as
data, which means that there is a whole range of possibilities when writing Onyx
programs that are difficult or impossible with compiled languages such as C
(lisp programmers also enjoy these benefits).  This aspect of Onyx is discussed
in Section\~ref{onyxtut:introspection}.



Not extensible.


\section{Memory management}

\section{Stacks}
\section{Dictionaries}

\section{Code organization}
\subsection{Procedures}
\subsection{Namespaces}

\section{Error handling}

\section{Introspection}
\label{onyxtut:introspection}

The following code defines a named procedure that calculates factorials.

\begin{verbatim}
% %n factorial %result
/factorial {
    dup 1 gt {
        % %n-1 factorial
        dup 1 sub factorial
    }{
        % Terminate recursion.
        1
    } ifelse

    mul
} def
\end{verbatim}

What this code actually does is create an executable array, which can be
examined and modified.  The following transcript shows the effects of modifying
the code.

\begin{verbatim}
onyx:0> 3 factorial 1 sprint
6
onyx:0> /factorial load 2 sprint
{dup 1 gt {dup 1 sub factorial} {1} ifelse mul}
onyx:0> /factorial load 4 {1 pstack} put
onyx:0> 3 factorial 
1
1
2
3
onyx:1> 1 sprint
6
onyx:0>
\end{verbatim}

First 3 factorial is calculated.  Then the ``else'' clause of the ifelse
construct is modified to print the stack and 3 factorial is recalculated.  As
can be seen, the stack is printed during the calculation.

\section{Threads}

\section{Optimization}

\section{Debugging}

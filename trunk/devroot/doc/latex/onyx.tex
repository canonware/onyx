%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% Onyx portion of Canonware Software Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx}
\label{onyxlang}

Onyx is a stack-based, threaded, interpreted language.  Its closest relative is
Adobe PostScript, followed by Forth.  Experienced PostScript programmers should
find most aspects of onyx familiar, but there are significant differences that
will prevent a knowledgeable PostScript programmer from programming in onyx
without first skimming this chapter.  This manual does not assume specific
knowledge of other programming languages, so stands as a definitive reference
manual for onyx.

Onyx is different from most languages in that it is not compiled, but rather
consumed.  For example, there are mechanisms for creating the equivalent of
named procedures that can be called at a later time, but behind the scenes, the
code is actually being interpreted as it is scanned in such a way that an
executable object is created.  As such, onyx is not suited for compilation,
native or byte code.  However, the language syntax is very simple and the
scanner/parser is extremely fast.  There is also a mechanism for binding
procedures, which makes interpreter performance approximately the same as would
be expected of a byte code interpreter.

Onyx is implemented as a C library that can be embedded in other programs.
Mechanisms are provided for extending the set of operators available.  This
manual only documents the base language; see application documentation for any
language extensions.

Following is a list of basic language features that are discussed in more detail
later in this manual:

\begin{itemize}
\item{Stack-based.  There are no named variables as in procedural languages.
Operations are done using various stacks, so onyx operations are coded in
postfix order.}
\item{Threaded.  Onyx's threading uses the native POSIX threads implementation
of the operating system.}
\item{Interpreted.  Onyx code is never compiled, but is instead interpreted as
it is encountered.}
\item{Garbage-collected.  There is no need to manually track memory allocation,
since the interpreter has an integrated automatic mark and sweep garbage
collector.}
\end{itemize}

\section{Objects}
\label{sec:onyx_objects}

An onyx object has three aspects: type, attribute, and value.

Objects fall into two categories according to type: simple and composite.  A
simple object takes up no memory of its own; it uses space within a stack,
array, or dictionary.  A composite object requires space of its own in addition
to the space taken up in stacks, arrays, or dictionaries to refer to the
composite object.  See Table~\ref{simple-composite} for object type
classifications.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Simple	& Composite	\\
\hline \hline
boolean	& array		\\
fino	& condition	\\
integer	& dict		\\
mark	& file		\\
name	& hook		\\
null	& mutex		\\
operator & stack	\\
pmark	& string	\\
	& thread	\\
\hline
\end{tabular}
\label{simple-composite}
\end{center}
\caption{Simple and composite types}
\end{table}

There can be multiple references that refer to the same memory backing composite
objects.  In most cases, composite objects that refer to the same memory are
indistinguishable, but for arrays and strings, composite objects may only be
able to access a subset of the total memory backing them.  This behavior is
described in detail later.

All objects have a literal or executable attribute associated with them.
Composite objects each have their own attribute, even for composite objects that
share the same backing memory.  An object is either literal or executable.  When
an executable file, hook, name, operator, or string is interpreted (encountered
directly by the interpreter), it is pushed onto the execution stack and
executed; otherwise the object is pushed onto the operand stack.  When an
executable array, file, hook, name, operator, or string is evaluated, it is
pushed onto the execution stack and executed; otherwise the object is pushed
onto the operand stack.  Note that executable arrays are the only objects that
behave differently when interpreted versus evaluated.

In practice, attributes are only useful for types that can be executed.
Attributes are not considered in equality test operations.

\begin{description}

\item[array: ] An array is an ordered sequence of objects of any type.  The
sequence of objects contained in an array is indexed starting at 0.  References
to existing arrays may be constructed such that a contiguous subsequence is
visible.  The following code creates such an array:

\begin{verbatim}
[0 1 2 3 4]
1 3 getinterval
\end{verbatim}

After the code executes, the array left on the operand stack looks like:

\begin{verbatim}
[1 2 3]
\end{verbatim}

Executable arrays are in effect procedures.  When an array is executed, its
elements are sequentially interpreted.  Executable arrays are uniquely handled
in comparison to other executable objects, in that they are only executed when
evaluated.

\item[boolean: ] A boolean can have two values: true or false.

\item[condition: ] A condition is used for thread synchronization.  The standard
operations on a condition are to wait and to signal.

\item[dict: ] A dict (short for dictionary) is a collection of key/value pairs.
Other names for dictionaries include ``associative array'' and ``hash''.  A key
can be of any type, though in most cases, keys are of type name.  A value can
also be of any type.

\item[file: ] A file is a handle to an ordered sequence of bytes with a current
position.  Read and write permissions are set when a file object is created.

When an executable file is executed, it is used as a source of onyx code.  Data
are sequentially read from the file and interpreted until the end of the file is
reached.

\item[fino: ] A fino is used as a stack marker when constructing stacks.

\item[hook: ] The hook type is not used by the core onyx language.  It can be
used by applications that extend the interpreter as a container object.  Hooks
can be executed, but the results are application dependent.

Each hook has a tag associated with it that can used by C extension code as a
form of type checking.  By default, the tag is a null object.  In most cases, an
application that extends the interpreter using hook objects will set hook tags
to be name objects.

\item[integer: ] An integer is a signed integer in the range $-2^{63}$ to
$2^{63} - 1$.

\item[mark: ] A mark is used as a stack marker for various stack operations.

\item[mutex: ] A mutex is a mutual exclusion lock.

\item[name: ] A name is a key that uniquely identifies a sequence of characters.
Two name objects that correspond to the same sequence of characters can be
compared for equality with the same approximate cost as comparing two integers
for equality.  Names are typically used as keys in dictionaries.

When an executable name is executed, the topmost value in the dictionary stack
associated with the name is evaluated.

\item[null: ] A null has no significance other than its existence.  When
an executable null is executed, it does nothing.

\item[operator: ] An operator is an operation that is built in to the
interpreter.  Operators can be executed.

\item[pmark: ] A pmark is used as a stack marker when creating procedures in
deferred execution mode (i.e. procedures that use the \{\} syntax).  The
application will only encounter pmarks in error conditions, and there is never a
reason for an application to explicitly create a pmark.

\item[stack: ] A stack provides LIFO (last in, first out) access to objects that
it contains, as well as some more advanced access methods.  An application can
create, then manipulate stacks in much the same way that the operand stack can
be manipulated.

\item[string: ] A string is an ordered sequence of 8 bit characters.  The bytes
contained in an string are indexed starting at 0.  References to existing
strings may be constructed such that a contiguous subsequence is visible.  The
following code creates such a string:

\begin{verbatim}
`abcde'
1 3 getinterval
\end{verbatim}

After the code executes, the string left on the operand stack looks like:

\begin{verbatim}
`bcd'
\end{verbatim}

When a string is executed, its contents are used as a source of onyx code.

\item[thread: ] A thread object serves as a handle for operations such as
detaching and joining.

\end{description}

\section{Syntax}
\label{sec:onyx_syntax}
Onyx's syntax is very simple in comparison to most languages.  The scanner and
parser are implemented as a human-understandable finite state machine (nested C
switch statements with a couple of auxiliary variables), which should give the
reader an idea of the simplicity of the language syntax.

CRNL (carriage return, newline) pairs are in all important cases converted to
newline during scanning.

The characters \%, /, {\lb}, {\rb}, \{, \}, (, ), `, ', {\lt}, and {\gt} are
special.  In most cases, any of the special characters and whitespace (space,
tab, newline, formfeed, null) terminate any preceding token.  All other
characters including non-printing characters are considered regular characters.

A comment starts with a \% character outside of a string context and extends to
the next newline or formfeed.

Procedures are actually executable arrays, but onyx provides special syntax for
declaring procedures.  Procedures are delimited by \{ and \}, and can be
nested.  Normally, the interpreter executes code as it is scanned, but inside of
procedure declarations, execution is deferred.  Instead of executing a procedure
body as it is encountered, the tokens of the procedure body are pushed onto the
operand stack until the closing \} is encountered, at which time an executable
array is constructed from the tokens in the procedure body and pushed onto the
operand stack.

A partial grammar specification, using BNF notation (where convenient) is as
follows:

\begin{description}
\item[{\lt}program{\gt} ::= ] {\lt}statement{\gt}

\item[{\lt}statement{\gt} ::= ] {\lt}procedure{\gt} {\lt}statement{\gt} {\pipe}
{\lt}object{\gt} {\lt}statement{\gt} {\pipe} $\epsilon$

\item[{\lt}procedure{\gt} ::= ] \{{\lt}statement{\gt}\}

\item[{\lt}object{\gt} ::= ] {\lt}integer{\gt} {\pipe} {\lt}name{\gt} {\pipe}
{\lt}string{\gt}

\item[{\lt}integer{\gt} ::= ] {\lt}dec\_integer{\gt} {\pipe}
{\lt}radix\_integer{\gt}

\item[{\lt}name{\gt} : ] Any token that cannot be interpreted as a number or a
string is interpreted as an executable name.  There are three syntaxes for
names: executable, literal and immediately evaluated.  Executable names are
looked up in the dictionary stack and executed (unless execution is deferred).
Literal names are simply pushed onto the operand stack.  Immediately evaluated
names are replaced by their values as defined in the dictionary stack, even if
execution is deferred.  Examples include:
\begin{verbatim}
foo     % executable
4noth3r % executable
/bar    % literal
//biz   % immediately evaluated
\end{verbatim}

\item[{\lt}string{\gt} ::= ] `'-delimited string.  Ticks may
be embedded in the string without escaping them, as long as the unescaped ticks
are balanced.  The following sequences have special meaning when escaped by a
``{\bs}'' character:
	\begin{description}
	\item[` ] ` character.
	\item[' ] ' character.
	\item[{\bs} ] {\bs} character.
	\item[n ] Newline.
	\item[r ] Carriage return.
	\item[t ] Tab.
	\item[b ] Backspace.
	\item[f ] Formfeed.
	\item[x{\lb}0-9a-fA-F{\rb}{\lb}0-9a-fA-F{\rb} ] Hex encoding for a byte.
	\item[{\bs}n (newline) ] Ignore.
	\item[{\bs}r{\bs}n (carriage return, newline) ] Ignore.
	\end{description}

``{\bs}'' has no special meaning unless followed by a character in the above
list.

Examples include:
\begin{verbatim}
`'
`A string.'
`An embedded \n newline.'
`Another embedded 
newline.'
`An ignored \
newline.'
`Balanced ` and ' are allowed.'
`Manually escaped \` tick.'
`Manually escaped \` tick and `balanced unescaped ticks'.'
`An actual \\ backslash.'
`Another actual \ backslash.'
\end{verbatim}

\item[{\lt}dec\_integer{\gt} : ] Signed integer in the range $-2^{63}$ to
$2^{63} - 1$.  The sign is optional.  Examples include:
\begin{verbatim}
0
42
-365
+17
\end{verbatim}

\item[{\lt}radix\_integer{\gt} : ] Integer with explicit base between 2 and 36,
inclusive, in the range $0$ to $2^{63} - 1$.  Integer digits are composed of
decimal numbers and lower case letters.  Examples include:
\begin{verbatim}
2#101
16#ff
10#42
9#18
35#7r3x
\end{verbatim}

\end{description}

Arrays do not have explicit syntactic support, but the [ and ] operators support
their construction.  Examples of array construction include:
\begin{verbatim}
[]
[0 `A string' `Another string.' true]
[5
42
false]
\end{verbatim}

Dictionaries do not have explicit syntactic support, but the {\lt} and
{\gt} operators support their construction.  Examples of dictionary
construction include:
\begin{verbatim}
<>
</answer 42 /question `Who knows' /translate {babelfish} >
\end{verbatim}

Stacks do not have explicit syntactic support, but the ( and ) operators support
their construction.  Examples of stack contstruction include:
\begin{verbatim}
()
(1 2 mark `a')
\end{verbatim}

\section{Stacks}

Stacks in onyx are the core data structure that programs act on.  Stacks store
objects in a last in, first out (LIFO) fashion.  Onyx includes a number of
operators that manipulate stacks.

Each onyx thread has four program-visible stacks associated with it:
\begin{description}
\item[Operand stack: ] Most direct object manipulations are done using the
	operand stack.  Operators use the operand stack for inputs and outputs,
	and code generally uses the operand stack for a place to store objects
	as they are being manipulated.
\item[Dictionary stack: ] The dictionary stack is used for looking up names.
	Each thread starts with with four dictionaries on its dictionary stack,
	which are, from top to bottom:
	\begin{itemize}
	\item{userdict}
	\item{globaldict}
	\item{systemdict}
	\item{threaddict}
	\end{itemize}
	The dictionary stack is manipulated via the
	\htmlref{\onyxop{}{begin}{}}{systemdict:begin} and
	\htmlref{\onyxop{}{end}{}}{systemdict:end} operators.  The initial
	dictionaries on the dictionary stack cannot be removed.
\item[Execution stack: ] The interpreter uses the execution stack to store
	objects that are being executed.  The application generally does not
	need to explicitly manipulate the execution stack, but its contents are
	accessible, mainly for debugging purposes.
\item[Index stack: ] The interpreter uses the index stack to store execution
	offsets for arrays that are being executed.  There is a one to one
	correspondence of the elements of the execution stack to the elements
	of the index stack, even though the elements of the index stack that
	don't correspond to arrays have no meaning.  The index stack does not
	affect execution, and exists purely to allow useful execution stack
	traces when errors occur.
\end{description}

The application can also create additional stacks and manipulate them in much
the same way as the operand stack can be manipulated.

\section{Interpretation, execution and evaluation}

During onyx interpreter initialization, an object file object corresponding to
stdin is usually pushed onto the execution stack.  However, depending on how the
interpreter is invoked, the initial object on the execution stack may be any
object.  The interpreter loop can be recursively invoked.  For example, if the
following code is executed, the eval operator recursively invokes the
interpreter loop to interpret the string.
\begin{verbatim}
`2 2 add' cvx eval
\end{verbatim}

The depth of the execution stack directly corresponds to the recursion depth of
the interpreter.  Execution stack depth is limited in order to catch unbounded
recursion.

\section{Error handling}

The error handling mechanisms in onyx are simple but flexible.  When an error
occurs, the following operations are performed as a result of executing
\htmlref{\onyxop{}{throw}{}}{systemdict:throw}:
\begin{enumerate}
\item{Store a snapshot of the thread state in the currenterror dictionary.}
\item{Push the object whose execution caused the error onto the operand stack.}
\item{Find an error handler in errordict corresponding to the current error.}
\item{Execute the error handler.  The standard error handlers in turn execute
errordict's \htmlref{\onyxop{}{handleerror}{}}{errordict:handleerror}.}
\item{Execute errordict's stop operator.}
\end{enumerate}

The onyx scanner handles syntax errors specially, in that it pushes an
executable string onto the operand stack that represents the code that caused
the syntax error and records the line and column numbers in currenterror before
invoking \htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

The onyx scanner also handles immediate name evaluation errors specially, in
that it pushes the name that could not be evaluated onto ostack before invoking
\htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

\section{Threads}

Onyx supports multiple threads of execution by using the operating system's
native threading facilities.  Along with threads comes the need for methods of
synchronization between threads.

\subsection{Implicit synchronization}

Implicit synchronization is a mandatory language feature, since objects such as
\htmlref{globaldict}{systemdict:globaldict} are implicitly accessed by the
interpreter, which makes it impossible to require the user to explicitly handle
all synchronization.  Onyx provides optional implicit synchronization
capabilities for composite objects on an object by object basis.  Each thread
has a setting which can be accessed via
\htmlref{\onyxop{}{currentlocking}{}}{systemdict:currentlocking} (initially set
to false) and set via \htmlref{\onyxop{}{setlocking}{}}{systemdict:setlocking}.
If implicit locking is active, then new objects will be created such that simple
accesses are synchronized.

Implicit synchronization can be a source of deadlock, so care must be taken when
accessing implicitly locked objects.  For example, if two threads copy two
implicitly locked strings to the other string, deadlock can result.

\begin{verbatim}
% Initialization.
/A `aaaaaa'
/B `bbbbbb'

...

% In thread A:
A B copy

...

% In thread B:
B A copy
\end{verbatim}

Following is a description of the implicit locking semantics for each type of
composite object:
\begin{description}
\item[array: ] Array copying is protected.  Array element modifications are
protected, but element reads are not protected.
\item[condition: ] No implicit locking is done for conditions.
\item[dict: ] All dict operations are protected.
\item[file: ] All file operations are protected.  There are no potential
deadlocks due to implicit file locking.
\item[hook: ] No implicit locking is done for hooks.
\item[mutex: ] No implicit locking is done for mutexes.
\item[stack: ] All stack operations are protected.  There are no potential
deadlocks due to implicit stack locking.  However, there are races in stack
copying, such that the results of copying a stack that is concurrently being
modified are unpredictable.
\item[string: ] String copying is protected.  Character access is protected by
many operators, but string copying is the only potential cause of deadlock for
string access.
\item[thread: ]  Implicit locking is not done for thread operations, since other
synchronization is adequate to protect thread objects.
\end{description}

\subsection{Explicit synchronization}

Onyx includes a foundation of mutexes and condition variable, with which all
other synchronization primitives can be constructed.

\section{Memory management}
Onyx programs do not need to track memory allocations, since memory reclamation
is done implicitly via automatic garbage collection.  Onyx uses an asynchronous
atomic mark and sweep garbage collector.  The garbage collector is asynchronous
in that it is a separate thread that can run at any time.  However, it is
atomic, which means that while the garbage collector is in the mark phase, no
other threads are running.

The atomic nature of garbage collection may sound worrisome with regard to
performance, but in fact there are tangible benefits and no significant negative
impacts for most applications.  Total throughput is improved, since minimal
locking is necessary.  Concurrent garbage collection would impose a significant
locking overhead.

On the down side, atomic garbage collection cannot make strong real-time
guarantees.  However, the garbage collector is very efficient, and for typical
applications, garbage collection delays are measured in microseconds up to tens
of milliseconds on current hardware as of the year 2000.  For interactive
applications, anything under about 100 milliseconds is undetectable by the user,
so under normal circumstances the user will not notice that garbage collection
is happening.

There are three parameters that can be used to customize garbage collection:
\begin{enumerate}
\item{The garbage collector can be turned off for situations where many objects
are being created over a short period of time.}
\item{The garbage collector is sent a message to run whenever a certain number
of composite objects have been created since the last collection.  This
threshold can be changed to suit the application.}
\item{If no composite objects have been created for an extended period of time
(seconds), the garbage collector will run if any composite objects have been
allocated since the last collection.  This idle timeout period can be changed.}
\end{enumerate}

There is one situation in which it is possible for garbage to never be
collected, despite the garbage collector being properly configured.  Suppose
that a program creates some objects, the garbage collector runs, then the
program enters a code path that clobbers object references, such that the
objects could be collected, but no new objects are allocated.  In such a
situation, neither the allocation inactivity timer (period), nor the object
allocation threshold will trigger a collection, and garbage will remain
uncollected.  In practice this situation is unlikely, and isn't a significant
problem since the program size is not growing.

Garbage collection is controlled via \htmlref{gcdict}{systemdict:gcdict}, which
is described in Section~\ref{sec:gcdict}.

\section{Dictionary reference}

All operators built in to onyx have corresponding names that are composed
entirely of lower case letters.  In order to avoid any possibility of namespace
collisions names defined by current and future versions of onyx, use at least
one character that is not a lower case letter in names (for example, capital
letters, numbers, underscore, etc.).

\subsection{currenterror}
\label{sec:currenterror}

Each thread has its own currenterror dictionary, which is used by the error
handling machinery to store error state.

\begin{longtable}{\optableformat{3}}
\caption[currenterror summary]{currenterror summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
-- & {\bf \htmlref{newerror}{currenterror:newerror}} & boolean & Set to true
during error handling. \\
\hline
-- & {\bf \htmlref{errorname}{currenterror:errorname}} & name & Name of most
recent error. \\
\hline
-- & {\bf \htmlref{line}{currenterror:line}} & number & Get line number of
syntax error. \\
\hline
-- & {\bf \htmlref{column}{currenterror:column}} & number & Get column number of
syntax error. \\
\hline
-- & {\bf \htmlref{ostack}{currenterror:ostack}} & stack & ostack snapshot. \\
\hline
-- & {\bf \htmlref{dstack}{currenterror:dstack}} & stack & dstack snaphot. \\
\hline
-- & {\bf \htmlref{estack}{currenterror:estack}} & stack & estack snapshot. \\
\hline
-- & {\bf \htmlref{istack}{currenterror:istack}} & stack & istack snapshot. \\
\end{longtable}

\begin{description}
\label{currenterror:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A dstack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is a dstack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin dstack end 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:errorname}
\index{errorname@\onyxop{}{errorname}{}}
\item[{\onyxop{--}{errorname}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			Name of the most recent error.  The name is usually one
			of the errors defined in
			\htmlref{errordict}{sec:errordict}.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the name of the most recent error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin errorname end 1 sprint
/undefined
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An estack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an estack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin estack end 1 sprint
(--start-- -file- x)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An istack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an istack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin istack end 1 sprint
(0 0 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:newerror}
\index{newerror@\onyxop{}{newerror}{}}
\item[{\onyxop{--}{newerror}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			False if there has been no error since the last time
			newerror was reset; true otherwise.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a boolean that represents whether there has been an error
		since the last time newerror was set to false (as during
		interpreter initialization).  It is the application's
		responsibility to reset newerror after each error if it expects
		the value to be useful across multiple errors.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currenterror begin
onyx:0> newerror 1 sprint
false
onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> newerror 1 sprint
true
onyx:1> /newerror false def
onyx:1> newerror 1 sprint
false
onyx:1> resume
onyx:1> y
Error /undefined
ostack: (x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      y
1:      -file-
2:      --start--
onyx:2> newerror 1 sprint
true
onyx:2>
		\end{verbatim}
	\end{description}
\label{currenterror:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An ostack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an ostack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin ostack end 1 sprint
()
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{envdict}
\label{sec:envdict}

The envdict dictionary contains keys of type name and values of type string that
correspond to the environment passed into the program.  The contents of envdict
are propagated as the environment to sub-processes by
\htmlref{\onyxop{}{exec}{}}{systemdict:exec}.  All threads share the same
envdict, which is implicitly locked.

\subsection{errordict}
\label{sec:errordict}

Each thread has its own errordict, which is used by default by the error
handling machinery.  \htmlref{\onyxop{}{throw}{}}{systemdict:throw} calls the
error handlers, which call errordict's
\htmlref{\onyxop{}{handleerror}{}}{errordict:handleerror}, after which
\htmlref{\onyxop{}{\onyxop{}{throw}{}}{}}{systemdict:throw} calls errordict's
\htmlref{\onyxop{}{stop}{}}{errordict:stop}.  Any of the names in errordict can
be redefined to suit the thread's or application's error handling requirements.

\begin{longtable}{\optableformat{3}}
\caption[errordict summary]{errordict summary by functional group} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{4}{|l|}{Control operators} \\
\hline \hline
-- & {\bf \htmlref{handleerror}{errordict:handleerror}} & -- & Print a state
dump. \\
\hline
-- & {\bf \htmlref{stop}{errordict:stop}} & -- & Last operation during error
handling. \\
\hline \hline
\multicolumn{4}{|l|}{Error operators} \\
\hline \hline
-- & {\bf \htmlref{dstackunderflow}{errordict:dstackunderflow}} & -- &
Dictionary stack underflow. \\
\hline
-- & {\bf \htmlref{estackoverflow}{errordict:estackoverflow}} & -- & Maximum
recursion depth exceeded. \\
\hline
-- & {\bf \htmlref{invalidaccess}{errordict:invalidaccess}} & -- & Permission
error. \\
\hline
-- & {\bf \htmlref{invalidexit}{errordict:invalidexit}} & -- & Exit outside of
any loop. \\
\hline
-- & {\bf \htmlref{invalidfileaccess}{errordict:invalidfileaccess}} & -- &
Insufficient file permissions. \\
\hline
-- & {\bf \htmlref{ioerror}{errordict:ioerror}} & -- & I/O error. \\
\hline
-- & {\bf \htmlref{limitcheck}{errordict:limitcheck}} & -- & Value outside of
legal range. \\
\hline
-- & {\bf \htmlref{rangecheck}{errordict:rangecheck}} & -- & Out of bounds
string or array access. \\
\hline
-- & {\bf \htmlref{stackunderflow}{errordict:stackunderflow}} & -- & Not enough
objects on ostack. \\
\hline
-- & {\bf \htmlref{syntaxerror}{errordict:syntaxerror}} & -- & Scanner syntax
error. \\
\hline
-- & {\bf \htmlref{typecheck}{errordict:typecheck}} & -- & Incorrect argument
type. \\
\hline
-- & {\bf \htmlref{undefined}{errordict:undefined}} & -- & Name not defined in
dstack. \\
\hline
-- & {\bf \htmlref{undefinedfilename}{errordict:undefinedfilename}} & -- & Bad
filename. \\
\hline
-- & {\bf \htmlref{undefinedresult}{errordict:undefinedresult}} & -- & Divide by
0. \\
\hline
-- & {\bf \htmlref{unmatchedfino}{errordict:unmatchedfino}} & -- & No fino on
ostack. \\
\hline
-- & {\bf \htmlref{unmatchedmark}{errordict:unmatchedmark}} & -- & No mark on
ostack. \\
\hline
-- & {\bf \htmlref{unregistered}{errordict:unregistered}} & -- & Non-enumerated
error. \\
\end{longtable}

\begin{description}
\label{dstackunderflow}
\label{errordict:dstackunderflow}
\index{dstackunderflow@\onyxop{}{dstackunderflow}{}}
\item[{\onyxop{--}{dstackunderflow}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		An attempt was made to remove one of the initial dictionaries
		from dstack.
	\end{description}
\label{estackoverflow}
\label{errordict:estackoverflow}
\index{estackoverflow@\onyxop{}{estackoverflow}{}}
\item[{\onyxop{--}{estackoverflow}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Maximum interpreter recursion was exceeded.
	\end{description}
\label{handleerror}
\label{errordict:handleerror}
\index{handleerror@\onyxop{}{handleerror}{}}
\item[{\onyxop{--}{handleerror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		Under normal conditions, no errors occur.  However, it is
		possible for the application to corrupt the error handling
		machinery to the point that an error will occur.  If that
		happens, the result is possible infinite recursion, and program
		crashes are a real possibility.
	\item[Description: ]
		Print a dump of the most recent error recorded in the
		currenterror dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {true {true 1 sprint x y} if} eval
true
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1> errordict begin handleerror end
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1>
		\end{verbatim}
	\end{description}
\label{invalidaccess}
\label{errordict:invalidaccess}
\index{invalidaccess@\onyxop{}{invalidaccess}{}}
\item[{\onyxop{--}{invalidaccess}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Permission error.
	\end{description}
\label{invalidexit}
\label{errordict:invalidexit}
\index{invalidexit@\onyxop{}{invalidexit}{}}
\item[{\onyxop{--}{invalidexit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Exit was called outside of any loop.  This error is generated as
		a result of catching an exit, so the execution state for where
		the error really happened is gone.
	\end{description}
\label{invalidfileaccess}
\label{errordict:invalidfileaccess}
\index{invalidfileaccess@\onyxop{}{invalidfileaccess}{}}
\item[{\onyxop{--}{invalidfileaccess}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Insufficient file permissions.
	\end{description}
\label{ioerror}
\label{errordict:ioerror}
\index{ioerror@\onyxop{}{ioerror}{}}
\item[{\onyxop{--}{ioerror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		I/O error (read(), write(), etc.).
	\end{description}
\label{limitcheck}
\label{errordict:limitcheck}
\index{limitcheck@\onyxop{}{limitcheck}{}}
\item[{\onyxop{--}{limitcheck}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Value outside of legal range.
	\end{description}
\label{rangecheck}
\label{errordict:rangecheck}
\index{rangecheck@\onyxop{}{rangecheck}{}}
\item[{\onyxop{--}{rangecheck}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Out of bounds string or array access.
	\end{description}
\label{stackunderflow}
\label{errordict:stackunderflow}
\index{stackunderflow@\onyxop{}{stackunderflow}{}}
\item[{\onyxop{--}{stackunderflow}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Not enough objects on ostack.
	\end{description}
\label{errordict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		This is called as the very last operation when an error occurs.
		Initially, its value is the same as that for the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operator in
		systemdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> errordict begin
onyx:0> /stop {`Custom stop\n' print flush quit} def
onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
Custom stop
		\end{verbatim}
	\end{description}
\label{syntaxerror}
\label{errordict:syntaxerror}
\index{syntaxerror@\onyxop{}{syntaxerror}{}}
\item[{\onyxop{--}{syntaxerror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Scanner syntax error.
	\end{description}
\label{typecheck}
\label{errordict:typecheck}
\index{typecheck@\onyxop{}{typecheck}{}}
\item[{\onyxop{--}{typecheck}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Incorrect argument type.
	\end{description}
\label{undefined}
\label{errordict:undefined}
\index{undefined@\onyxop{}{undefined}{}}
\item[{\onyxop{--}{undefined}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Name not defined in any of the dictionaries on dstack.
	\end{description}
\label{undefinedfilename}
\label{errordict:undefinedfilename}
\index{undefinedfilename@\onyxop{}{undefinedfilename}{}}
\item[{\onyxop{--}{undefinedfilename}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Bad filename.
	\end{description}
\label{undefinedresult}
\label{errordict:undefinedresult}
\index{undefinedresult@\onyxop{}{undefinedresult}{}}
\item[{\onyxop{--}{undefinedresult}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Attempt to divide by 0.
	\end{description}
\label{unmatchedfino}
\label{errordict:unmatchedfino}
\index{unmatchedfino@\onyxop{}{unmatchedfino}{}}
\item[{\onyxop{--}{unmatchedfino}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		No fino on ostack.
	\end{description}
\label{unmatchedmark}
\label{errordict:unmatchedmark}
\index{unmatchedmark@\onyxop{}{unmatchedmark}{}}
\item[{\onyxop{--}{unmatchedmark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		No mark on ostack.
	\end{description}
\label{unregistered}
\label{errordict:unregistered}
\index{unregistered@\onyxop{}{unregistered}{}}
\item[{\onyxop{--}{unregistered}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Non-enumerated error.
	\end{description}
\end{description}

\subsection{gcdict}
\label{sec:gcdict}

The gcdict dictionary provides garbage collection control and status
capabilities.

\begin{longtable}{\optableformat{3.75}}
\caption[gcdict summary]{gcdict summary by functional group}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{4}{|l|}{Control operators} \\
\hline \hline
-- & {\bf \htmlref{collect}{gcdict:collect}} & -- & Force a garbage
collection. \\
\hline
boolean & {\bf \htmlref{setactive}{gcdict:setactive}} & -- & Set whether the
garbage collector is active. \\
\hline
seconds & {\bf \htmlref{setperiod}{gcdict:setperiod}} & -- & Set the inactivity
period before the garbage collector will run. \\
\hline
count & {\bf \htmlref{setthreshold}{gcdict:setthreshold}} & -- & Set the number
of object allocations that will trigger a garbage collection. \\
\hline \hline
\multicolumn{4}{|l|}{State and statistics operators} \\
\hline \hline
-- & {\bf \htmlref{active}{gcdict:active}} & boolean & Get whether the garbage
collector is active. \\
\hline
-- & {\bf \htmlref{period}{gcdict:period}} & seconds & Get the inactivity period
befor the garbage collector will run. \\
\hline
-- & {\bf \htmlref{threshold}{gcdict:threshold}} & count & Get the number of
object allocations that will trigger a garbage collection. \\
\hline
-- & {\bf \htmlref{stats}{gcdict:stats}} & array & Get garbage collection
statistics. \\
\end{longtable}

\begin{description}
\label{gcdict:active}
\index{active@\onyxop{}{active}{}}
\item[{\onyxop{--}{active}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true, the garbage collector is active; otherwise it
			is not active.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get whether the garbage collector is active.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin active end 1 sprint
false
		\end{verbatim}
	\end{description}
\label{gcdict:collect}
\index{collect@\onyxop{}{collect}{}}
\item[{\onyxop{--}{collect}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Force a garbage collection.  The garbage collection occurs
		asynchronously, so there are no guarantees as to when the
		garbage collection will occur, only that a garbage collection
		will occur.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin collect end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:period}
\index{period@\onyxop{}{period}{}}
\item[{\onyxop{--}{period}{seconds}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin period end 1 sprint
60
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setactive}
\index{setactive@\onyxop{}{setactive}{}}
\item[{\onyxop{boolean}{setactive}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true (initial setting), activate the garbage
			collector; otherwise deactivate the garbage collector.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set whether the garbage collector is active.  This setting takes
		effect asynchronously, so it is possible for the garbage
		collector to run even after it has been deactivated.  This
		setting overrides the allocation inactivity period an allocation
		threshold settings, so that if this setting is set to false, the
		other settings have no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin false setactive end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setperiod}
\index{setperiod@\onyxop{}{setperiod}{}}
\item[{\onyxop{seconds}{setperiod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 60 setperiod end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setthreshold}
\index{setthreshold@\onyxop{}{setthreshold}{}}
\item[{\onyxop{count}{setthreshold}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of objects allocations since the last garbage
			collection that will trigger a garbage collection.  0 is
			treated specially to mean infinity.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the number of object allocations since the last garbage
		collection that will trigger a garbage collection.  This setting
		is disjoint from the inactivity period setting, and does not
		prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 40000 setthreshold end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:stats}
\index{sum@\onyxop{}{stats}{}}
\item[{\onyxop{--}{stats}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array with the format {\lb}collections new
			{\lb}ccount cmark csweep{\rb} {\lb}mcount mmark
			msweep{\rb} {\lb}scount smark ssweep{\rb}{\rb}, where
			the fields have the following meanings:
			\begin{description}\item[]
			\item[collections: ]
				Total number of collections the garbage
				collector has performed.
			\item[new: ]
				Number of objects created since the last garbage
				collection.
			\item[ccount: ]
				Current number of objects.
			\item[cmark: ]
				Number of microseconds taken by the most recent
				garbage collection mark phase.
			\item[csweep: ]
				Number of microseconds taken by the most recent
				garbage collection sweep phase.
			\item[mcount: ]
				Maximum number of objects that have ever 
				existed.
			\item[mmark: ]
				Maximum number of microseconds taken by any
				garbage collection mark phase.
			\item[msweep: ]
				Number of microseconds taken by any garbage
				collection sweep phase.
			\item[scount: ]
				Total number of objects that have ever existed.
			\item[smark: ]
				Total number of microseconds taken by all
				garbage collection mark phases.
			\item[ssweep: ]
				Total number of microseconds taken by all
				garbage collection sweep phase.
			\end{description}
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get statistics about the garbage collector.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin
onyx:0> stats 2 sprint
[3 3 [441 700 100] [577 784 1267] [606 2174 1499]]
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:threshold}
\index{threshold@\onyxop{}{threshold}{}}
\item[{\onyxop{--}{threshold}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of objects allocations since the last garbage
			collection that will trigger a garbage collection.  0 is
			treated specially to mean infinity.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of object allocations since the last garbage
		collection that will trigger a garbage collection.  This setting
		is disjoint from the inactivity period setting, and does not
		prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin threshold end 1 sprint
40000
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{globaldict}
\label{sec:globaldict}

All threads share the same globaldict, which is meant as a repository for
globally shared objects.  globaldict is empty when the onyx interpreter is
initialized, and is implicitly locked.

\subsection{sprintdict}
\label{sec:sprintdict}

The sprintdict dictionary is primarily used to support
\htmlref{\onyxop{}{sprint}{}}{systemdict:sprint}, but its contents may be of use
to an application that wishes to extend or modify syntactical printing.

There is an entry in sprintdict for each onyx type.  Each operator takes two
arguments: an object to print and an integer that represents printing recursion
depth.  Each operator removes the two arguments from ostack upon completion.  If
there is a syntactically valid representation for an object and the recursion
depth is greater than 0, the corresponding operator prints the object
syntactically.  Otherwise, a non-syntictical representation of the object is
printed.  If the recursion depth is greater than 0, the operators will
recursively print any contained objects.  All printing is done to
\htmlref{\onyxop{}{stdout}{}}{systemdict:stdout}.

The operators do not print whitespace before or after the object
representations, so if multiple objects are being sequentially printed
syntactically, care should be taken to insert whitespace delimiters.

The implementation of \htmlref{\onyxop{}{sprint}{}}{systemdict:sprint} is useful
in illustrating a useful method of doing type-dependent operations:

\begin{verbatim}
/sprint {
        1 index type /sprintdict load exch get eval
        `\n' print flush
} bind def
\end{verbatim}

\begin{longtable}{\optableformat{3}}
\caption[sprintdict summary]{sprintdict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
array depth & {\bf \htmlref{arraytype}{sprintdict:arraytype}} & -- &
Syntactically print array. \\
\hline
boolean depth & {\bf \htmlref{booleantype}{sprintdict:booleantype}} & -- &
Syntactically print boolean. \\
\hline
condition depth & {\bf \htmlref{conditiontype}{sprintdict:conditiontype}} & -- &
Syntactically print condition. \\
\hline
dict depth & {\bf \htmlref{dicttype}{sprintdict:dicttype}} & -- & Syntactically
print dict. \\
\hline
file depth & {\bf \htmlref{filetype}{sprintdict:filetype}} & -- & Syntactically
print file. \\
\hline
fino depth & {\bf \htmlref{finotype}{sprintdict:finotype}} & -- & Syntactically
print fino. \\
\hline
hook depth & {\bf \htmlref{hooktype}{sprintdict:hooktype}} & -- & Syntactically
print hook. \\
\hline
integer depth & {\bf \htmlref{integertype}{sprintdict:integertype}} & -- &
Syntactically print integer. \\
\hline
mark depth & {\bf \htmlref{marktype}{sprintdict:marktype}} & -- & Syntactically
print mark. \\
\hline
mutex depth & {\bf \htmlref{mutextype}{sprintdict:mutextype}} & -- &
Syntactically print mutex. \\
\hline
name depth & {\bf \htmlref{nametype}{sprintdict:nametype}} & -- & Syntactically
print name. \\
\hline
null depth & {\bf \htmlref{nulltype}{sprintdict:nulltype}} & -- & Syntactically
print null. \\
\hline
operator depth & {\bf \htmlref{operatortype}{sprintdict:operatortype}} & -- &
Syntactically print operator. \\
\hline
pmark depth & {\bf \htmlref{pmarktype}{sprintdict:pmarktype}} & -- &
Syntactically print pmark. \\
\hline
stack depth & {\bf \htmlref{stacktype}{sprintdict:stacktype}} & -- &
Syntactically print stack. \\
\hline
string depth & {\bf \htmlref{stringtype}{sprintdict:stringtype}} & -- &
Syntactically print string. \\
\hline
thread depth & {\bf \htmlref{threadtype}{sprintdict:threadtype}} & -- &
Syntactically print thread. \\
\end{longtable}

\begin{description}
\label{sprintdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array depth}{arraytype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{array} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{array} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup 0 arraytype `\n' print flush
-array-
onyx:1> dup 1 arraytype `\n' print flush
[1 -array- 4]
onyx:1> dup 2 arraytype `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean depth}{booleantype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{boolean} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{boolean} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> true
onyx:1> dup 0 booleantype `\n' print flush
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition depth}{conditiontype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{condition} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{condition} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> condition
onyx:1> dup 0 conditiontype `\n' print flush
-condition-
onyx:1> dup 1 conditiontype `\n' print flush
-condition-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict depth}{dicttype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{dict} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{dict} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> </a `a' /subdict </b `b'>>
onyx:1> dup 0 dicttype `\n' print flush
-dict-
onyx:1> dup 1 dicttype `\n' print flush
</subdict -dict- /a `a'>
onyx:1> dup 2 dicttype `\n' print flush
</subdict </b `b'> /a `a'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file depth}{filetype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{file} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{file} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> stdout
onyx:1> dup 0 filetype `\n' print flush
-file-
onyx:1> dup 1 filetype `\n' print flush
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino depth}{finotype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{fino} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{fino} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> (
onyx:1> dup 0 finotype `\n' print flush
-fino-
onyx:1> dup 1 finotype `\n' print flush
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:hooktype}
\index{hooktype@\onyxop{}{hooktype}{}}
\item[{\onyxop{hook depth}{hooktype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{hook} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{hook} to stdout.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a hook object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhook exists that
		creates a hook with a tag that is the name ``tagged'', and that
		an operator named untaggedhook exists that creates an untagged
		hook.
		\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> taggedhook
onyx:1> dup 0 hooktype `\n' print flush
=tagged=
onyx:1> 1 hooktype `\n' print flush
=tagged=
onyx:0> untaggedhook
onyx:1> dup 0 hooktype `\n' print flush
-hook-
onyx:1> 1 hooktype `\n' print flush
-hook-
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer depth}{integertype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{integer} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{integer} to stdout.
	\item[Example(s): ]\begin{verbatim}


onyx:0> sprintdict begin
onyx:0> 42
onyx:1> dup 0 integertype `\n' print flush
42
onyx:1> dup 1 integertype `\n' print flush
42
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark depth}{marktype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{mark} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{mark} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> mark
onyx:1> dup 0 marktype `\n' print flush
-mark-
onyx:1> dup 1 marktype `\n' print flush
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex depth}{mutextype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{mutex} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{mutex} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> mutex
onyx:1> dup 0 mutextype `\n' print flush
-mutex-
onyx:1> dup 1 mutextype `\n' print flush
-mutex-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name depth}{nametype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{name} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{name} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> /foo
onyx:1> dup 0 nametype `\n' print flush
/foo
onyx:1> dup 1 nametype `\n' print flush
/foo
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null depth}{nulltype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{null} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{null} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> null
onyx:1> dup 0 nulltype `\n' print flush
-null-
onyx:1> dup 1 nulltype `\n' print flush
-null-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator depth}{operatortype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{operator} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{operator} to stdout.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> //realtime
onyx:1> dup 0 operatortype `\n' print flush
--realtime--
onyx:1> 1 operatortype `\n' print flush
--realtime--
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark depth}{pmarktype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{pmark} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{pmark} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> { //x
Error /undefined
ostack: (-pmark- /x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> dup 0 pmarktype `\n' print flush
-pmark-
onyx:1> dup 1 pmarktype `\n' print flush
-pmark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack depth}{stacktype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{stack} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{stack} to stdout.
	\item[Example(s): ]\begin{verbatim}


onyx:0> sprintdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup 0 stacktype `\n' print flush
-stack-
onyx:1> dup 1 stacktype `\n' print flush
(1 -stack- 4)
onyx:1> dup 2 stacktype `\n' print flush
(1 (2 3) 4)
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string depth}{stringtype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{string} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{string} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> `abcd'
onyx:1> dup 0 stringtype `\n' print flush
`abcd'
onyx:1> dup 1 stringtype `\n' print flush
`abcd'
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread depth}{threadtype}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread to be syntactically printed.
		\item[depth: ]
			Printing recursion depth.
		\end{description}
	\item[Output(s): ]
		Syntactic representation of \oparg{thread} printed to stdout.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{thread} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintdict begin
onyx:0> thread
onyx:1> dup 0 threadtype `\n' print flush
-thread-
onyx:1> dup 1 threadtype `\n' print flush
-thread-
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}


\subsection{systemdict}
\label{sec:systemdict}

All threads share the same systemdict, which contains most of the operators that
are of general use.  Although there are no mechanisms that prevent modification
of systemdict, programs should not normally need to modify systemdict, since
globaldict provides a place for storing globally shared objects.  All threads
share the same systemdict, which is implicitly locked.

\begin{longtable}{\optableformat{2.5}}
\caption[systemdict summary]{systemdict summary by functional group} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{4}{|l|}{Operand stack operators} \\
\hline \hline
-- & {\bf \htmlref{mark}{systemdict:mark}} & mark & Create a mark. \\
\hline
-- & {\bf \htmlref{count}{systemdict:count}} & count & Get the number of objects
on ostack. \\
\hline
mark \dots & {\bf \htmlref{counttomark}{systemdict:counttomark}} & mark \dots
count & Get the depth of the topmost mark on ostack. \\
\hline
object & {\bf \htmlref{dup}{systemdict:dup}} & object object & Duplicate an
object. \\
\hline
object \dots index & {\bf \htmlref{index}{systemdict:index}} & object \dots
object & Duplicate object on ostack at a given index. \\
\hline
a b & {\bf \htmlref{exch}{systemdict:exch}} & b a & Exchange the top two objects
on ostack. \\
\hline
\oparg{region} \oparg{count} \oparg{amount} & {\bf
\htmlref{roll}{systemdict:roll}} & \oparg{rolled} & Roll the top
\oparg{count} objects up by \oparg{amount}. \\
\hline
any & {\bf \htmlref{pop}{systemdict:pop}} & -- & Remove the top object from the
operand stack. \\
\hline
objects & {\bf \htmlref{clear}{systemdict:clear}} & -- & Pop all objects off
ostack. \\
\hline
mark \dots & {\bf \htmlref{cleartomark}{systemdict:cleartomark}} & -- & Remove
objects from ostack through topmost mark. \\
\hline \hline
\multicolumn{4}{|l|}{Execution, control, and execution stack operators} \\
\hline \hline
object & {\bf \htmlref{eval}{systemdict:eval}} & -- & Evaluate object. \\
\hline
boolean object & {\bf \htmlref{if}{systemdict:if}} & -- & Conditionally evaluate
object. \\
\hline
boolean a b & {\bf \htmlref{ifelse}{systemdict:ifelse}} & -- & Conditionally
evaluate one of two objects. \\
\hline
init inc limit proc & {\bf \htmlref{for}{systemdict:for}} & -- & Iterate with a
control variable. \\
\hline
count proc & {\bf \htmlref{repeat}{systemdict:repeat}} & -- & Iterate a set
number of times. \\
\hline
proc & {\bf \htmlref{loop}{systemdict:loop}} & -- &  Iterate indefinitely. \\
\hline
-- & {\bf \htmlref{exit}{systemdict:exit}} & -- & Terminate innermost looping
context. \\
\hline
object & {\bf \htmlref{start}{systemdict:start}} & -- & Evaluate object. \\
\hline
-- & {\bf \htmlref{quit}{systemdict:quit}} & -- & Unwind to innermost start
context. \\
\hline
object & {\bf \htmlref{stopped}{systemdict:stopped}} & boolean & Evaluate
object. \\
\hline
-- & {\bf \htmlref{stop}{systemdict:stop}} & -- & Unwind to innermost stopped or
start context. \\
\hline
name & {\bf \htmlref{throw}{systemdict:throw}} & object & Throw an error. \\
\hline
-- & {\bf \htmlref{estack}{systemdict:estack}} & stack & Get a current estack
snapshot. \\
\hline
-- & {\bf \htmlref{countestack}{systemdict:countestack}} & count & Get current
estack depth. \\
\hline
-- & {\bf \htmlref{istack}{systemdict:istack}} & stack & Get a current istack
snapshot. \\
\hline
& {\bf \htmlref{die}{systemdict:die}} & & \\
\hline
& {\bf \htmlref{fork}{systemdict:fork}} & & \\
\hline
& {\bf \htmlref{exec}{systemdict:exec}} & & \\
\hline
& {\bf \htmlref{waitpid}{systemdict:waitpid}} & & \\
\hline
& {\bf \htmlref{system}{systemdict:system}} & & \\
\hline
& {\bf \htmlref{realtime}{systemdict:realtime}} & & \\
\hline
nanoseconds & {\bf \htmlref{nsleep}{systemdict:nsleep}} & -- & Nanosleep. \\
\hline \hline
\multicolumn{4}{|l|}{Stack operators} \\
\hline \hline
-- & {\bf \htmlref{(}{systemdict:sym_lp}} & fino & Begin a stack declaration. \\
\hline
fino objects & {\bf \htmlref{)}{systemdict:sym_rp}} & stack & Create a stack. \\
\hline
-- & {\bf \htmlref{stack}{systemdict:stack}} & stack & Create a stack. \\
\hline
stack object & {\bf \htmlref{spush}{systemdict:spush}} & stack & Push an object
onto a stack. \\
\hline
stack & {\bf \htmlref{scount}{systemdict:scount}} & stack count & Get the number
of objects on a stack. \\
\hline
stack & {\bf \htmlref{scounttomark}{systemdict:scounttomark}} & stack count &
Get the depth of the topmost mark on stack. \\
\hline
stack & {\bf \htmlref{sdup}{systemdict:sdup}} & stack & Duplicate an object. \\
\hline
stack index & {\bf \htmlref{sindex}{systemdict:sindex}} & stack & Duplicate
object in a stack at a given index. \\
\hline
stack & {\bf \htmlref{sexch}{systemdict:sexch}} & stack & Exchange top objects
on stack. \\
\hline
stack count amount & {\bf \htmlref{sroll}{systemdict:sroll}} & stack & Roll
objects on stack. \\
\hline
stack & {\bf \htmlref{spop}{systemdict:spop}} & stack object & Pop an object off
a stack. \\
\hline
stack & {\bf \htmlref{sclear}{systemdict:sclear}} & stack & Remove all objects
on stack. \\
\hline
stack & {\bf \htmlref{scleartomark}{systemdict:scleartomark}} & stack & Remove
objecs from stack down through topmost mark. \\
\hline \hline
\multicolumn{4}{|l|}{Polymorphic operators} \\
\hline \hline
[a] [b] & {\bf \htmlref{catenate}{systemdict:catenate}} & [a b] & \\
(a) (b) & {\bf \htmlref{catenate}{systemdict:catenate}} & (a b) & \\
`a' `b' & {\bf \htmlref{catenate}{systemdict:catenate}} & `ab' & \\
\hline
& {\bf \htmlref{token}{systemdict:token}} & & \\
\hline
& {\bf \htmlref{store}{systemdict:store}} & & \\
\hline
& {\bf \htmlref{put}{systemdict:put}} & & \\
\hline
& {\bf \htmlref{putinterval}{systemdict:putinterval}} & & \\
\hline
& {\bf \htmlref{length}{systemdict:length}} & & \\
\hline
& {\bf \htmlref{get}{systemdict:get}} & & \\
\hline
& {\bf \htmlref{getinterval}{systemdict:getinterval}} & & \\
\hline
& {\bf \htmlref{foreach}{systemdict:foreach}} & & \\
\hline
& {\bf \htmlref{copy}{systemdict:copy}} & & \\
\hline \hline
\multicolumn{4}{|l|}{Integer and math operators} \\
\hline \hline
a b & {\bf \htmlref{add}{systemdict:add}} & r & Add a and b. \\
\hline
a b & {\bf \htmlref{sub}{systemdict:sub}} & r & Subtract b from a. \\
\hline
a b & {\bf \htmlref{mul}{systemdict:mul}} & r & Multiply a and b. \\
\hline
a b & {\bf \htmlref{div}{systemdict:div}} & r & Divide a by b. \\
\hline
a b & {\bf \htmlref{mod}{systemdict:mod}} & r & Mod a by b. \\
\hline
a b & {\bf \htmlref{exp}{systemdict:exp}} & r & Raise a to the power of b. \\
\hline
a & {\bf \htmlref{abs}{systemdict:abs}} & r & Get the absolute value of a. \\
\hline
a & {\bf \htmlref{neg}{systemdict:neg}} & r & Get the negative of a. \\
\hline
seed & {\bf \htmlref{srand}{systemdict:srand}} & -- & Seed pseudo-random number
generator. \\
\hline
-- & {\bf \htmlref{rand}{systemdict:rand}} & integer & Get a pseudo-random
number. \\
\hline \hline
\multicolumn{4}{|l|}{String operators} \\
\hline \hline
& {\bf \htmlref{string}{systemdict:string}} & & \\
\hline \hline
\multicolumn{4}{|l|}{Array operators} \\
\hline \hline
& {\bf \htmlref{argv}{systemdict:argv}} & & \\
\hline
& {\bf \htmlref{[}{systemdict:sym_lb}} & & \\
\hline
& {\bf \htmlref{]}{systemdict:sym_rb}} & & \\
\hline
& {\bf \htmlref{aload}{systemdict:aload}} & & \\
\hline
& {\bf \htmlref{array}{systemdict:array}} & & \\
\hline
& {\bf \htmlref{astore}{systemdict:astore}} & & \\
\hline \hline
\multicolumn{4}{|l|}{Dictionary and dictionary stack operators} \\
\hline \hline
& {\bf \htmlref{envdict}{systemdict:envdict}} & & \\
\hline
& {\bf \htmlref{gcdict}{systemdict:gcdict}} & & \\
\hline
& {\bf \htmlref{globaldict}{systemdict:globaldict}} & & \\
\hline
& {\bf \htmlref{where}{systemdict:where}} & & \\
\hline
& {\bf \htmlref{undef}{systemdict:undef}} & & \\
\hline
& {\bf \htmlref{{\lt}}{systemdict:sym_lt}} & & \\
\hline
& {\bf \htmlref{{\gt}}{systemdict:sym_gt}} & & \\
\hline
& {\bf \htmlref{load}{systemdict:load}} & & \\
\hline
& {\bf \htmlref{known}{systemdict:known}} & & \\
\hline
& {\bf \htmlref{end}{systemdict:end}} & & \\
\hline
& {\bf \htmlref{dstack}{systemdict:dstack}} & & \\
\hline
& {\bf \htmlref{dict}{systemdict:dict}} & & \\
\hline
& {\bf \htmlref{def}{systemdict:def}} & & \\
\hline
& {\bf \htmlref{currentdict}{systemdict:currentdict}} & & \\
\hline
& {\bf \htmlref{countdstack}{systemdict:countdstack}} & & \\
\hline
& {\bf \htmlref{begin}{systemdict:begin}} & & \\
\hline
& {\bf \htmlref{cleardstack}{systemdict:cleardstack}} & & \\
\hline \hline
\multicolumn{4}{|l|}{File and filesystem operators} \\
\hline \hline
& {\bf \htmlref{truncate}{systemdict:truncate}} & & \\
\hline
& {\bf \htmlref{unlink}{systemdict:unlink}} & & \\
\hline
& {\bf \htmlref{write}{systemdict:write}} & & \\
\hline
& {\bf \htmlref{tell}{systemdict:tell}} & & \\
\hline
& {\bf \htmlref{test}{systemdict:test}} & & \\
\hline
& {\bf \htmlref{symlink}{systemdict:symlink}} & & \\
\hline
& {\bf \htmlref{status}{systemdict:status}} & & \\
\hline
& {\bf \htmlref{sprint}{systemdict:sprint}} & & \\
\hline
& {\bf \htmlref{seek}{systemdict:seek}} & & \\
\hline
& {\bf \htmlref{rename}{systemdict:rename}} & & \\
\hline
& {\bf \htmlref{read}{systemdict:read}} & & \\
\hline
& {\bf \htmlref{readline}{systemdict:readline}} & & \\
\hline
& {\bf \htmlref{pstack}{systemdict:pstack}} & & \\
\hline
& {\bf \htmlref{print}{systemdict:print}} & & \\
\hline
& {\bf \htmlref{open}{systemdict:open}} & & \\
\hline
& {\bf \htmlref{mkdir}{systemdict:mkdir}} & & \\
\hline
& {\bf \htmlref{link}{systemdict:link}} & & \\
\hline
& {\bf \htmlref{flush}{systemdict:flush}} & & \\
\hline
& {\bf \htmlref{flushfile}{systemdict:flushfile}} & & \\
\hline
path & {\bf \htmlref{cd}{systemdict:cd}} & -- & \\
\hline
-- & {\bf \htmlref{pwd}{systemdict:pwd}} & path & \\
\hline
path proc & {\bf \htmlref{dirforeach}{systemdict:dirforeach}} & -- & \\
\hline
& {\bf \htmlref{currentfile}{systemdict:currentfile}} & & \\
\hline
& {\bf \htmlref{bytesavailable}{systemdict:bytesavailable}} & & \\
\hline
& {\bf \htmlref{chmod}{systemdict:chmod}} & & \\
\hline
& {\bf \htmlref{chown}{systemdict:chown}} & & \\
\hline
& {\bf \htmlref{close}{systemdict:close}} & & \\
\hline \hline
\multicolumn{4}{|l|}{Logical and bitwise operators} \\
\hline \hline
a b & {\bf \htmlref{lt}{systemdict:lt}} & boolean & a less than b?
(integer, string) \\
\hline
a b & {\bf \htmlref{le}{systemdict:le}} & boolean & a less than or equal to b?
(integer, string) \\
\hline
a b & {\bf \htmlref{eq}{systemdict:eq}} & boolean & a equal to b? (any type) \\
\hline
a b & {\bf \htmlref{ne}{systemdict:ne}} & boolean & a not equal to b? (any type)
\\
\hline
a b & {\bf \htmlref{ge}{systemdict:ge}} & boolean & a greater than or equal to
b? (integer, string) \\
\hline
a b & {\bf \htmlref{gt}{systemdict:gt}} & boolean & a greater than b?
(integer, string) \\
\hline
a b & {\bf \htmlref{and}{systemdict:and}} & r & Logical/bitwise and.
(boolean/integer)  \\
\hline
a b & {\bf \htmlref{or}{systemdict:or}} & r & Logical/bitwise or.
(boolean/integer) \\
\hline
a b & {\bf \htmlref{xor}{systemdict:xor}} & r & Logical/bitwise exclusive or.
(boolean/ integer) \\
\hline
a & {\bf \htmlref{not}{systemdict:not}} & r & Logical/bitwise not.
(boolean/integer) \\
\hline
a shift & {\bf \htmlref{shift}{systemdict:shift}} & integer & Bitwise shift. \\
\hline
-- & {\bf \htmlref{false}{systemdict:false}} & false & Return true. \\
\hline
-- & {\bf \htmlref{true}{systemdict:true}} & true & Return false. \\
\hline \hline
\multicolumn{4}{|l|}{Type, conversion, and attribute operators} \\
\hline \hline
object & {\bf \htmlref{type}{systemdict:type}} & name & Get object type. \\
\hline
object & {\bf \htmlref{xcheck}{systemdict:xcheck}} & boolean & Executable? \\
\hline
object & {\bf \htmlref{cvx}{systemdict:cvx}} & object & Set executable
attribute. \\
\hline
object & {\bf \htmlref{cvlit}{systemdict:cvlit}} & object & Set literal
attribute. \\
\hline
string & {\bf \htmlref{cvn}{systemdict:cvn}} & name & Convert string to name. \\
\hline
object & {\bf \htmlref{cvs}{systemdict:cvs}} & string & Convert object to
string. \\
\hline
integer radix & {\bf \htmlref{cvrs}{systemdict:cvrs}} & string & Convert integer
to radix string. \\
\hline \hline
\multicolumn{4}{|l|}{Threading and synchronization operators} \\
\hline \hline
& {\bf \htmlref{wait}{systemdict:wait}} & & \\
\hline
& {\bf \htmlref{thread}{systemdict:thread}} & & \\
\hline
& {\bf \htmlref{timedwait}{systemdict:timedwait}} & & \\
\hline
& {\bf \htmlref{unlock}{systemdict:unlock}} & & \\
\hline
& {\bf \htmlref{yield}{systemdict:yield}} & & \\
\hline
& {\bf \htmlref{trylock}{systemdict:trylock}} & & \\
\hline
& {\bf \htmlref{signal}{systemdict:signal}} & & \\
\hline
& {\bf \htmlref{self}{systemdict:self}} & & \\
\hline
& {\bf \htmlref{setlocking}{systemdict:setlocking}} & & \\
\hline
& {\bf \htmlref{mutex}{systemdict:mutex}} & & \\
\hline
mutex proc & {\bf \htmlref{monitor}{systemdict:mutex}} & -- & Evaluate an object
under the protection of a mutex. \\
\hline
& {\bf \htmlref{lock}{systemdict:lock}} & & \\
\hline
& {\bf \htmlref{join}{systemdict:join}} & & \\
\hline
& {\bf \htmlref{detach}{systemdict:detach}} & & \\
\hline
object & {\bf \htmlref{lcheck}{systemdict:lcheck}} & boolean & Implicitly
locked? \\
\hline
& {\bf \htmlref{currentlocking}{systemdict:currentlocking}} & & \\
\hline
& {\bf \htmlref{broadcast}{systemdict:broadcast}} & & \\
\hline
& {\bf \htmlref{condition}{systemdict:condition}} & & \\
\hline \hline
\multicolumn{4}{|l|}{Miscellaneous operators} \\
\hline \hline
-- & {\bf \htmlref{\#!}{systemdict:sym_hash_bang}} & mark & Begin interpreter
magic. \\
\hline
mark names & {\bf \htmlref{!\#}{systemdict:sym_bang_hash}} & -- & End
interpreter magic. \\
\hline
-- & {\bf \htmlref{product}{systemdict:product}} & string & Get the product
string. \\
\hline
-- & {\bf \htmlref{version}{systemdict:version}} & string & Get the version
string. \\
\hline
proc & {\bf \htmlref{bind}{systemdict:bind}} & proc & Bind names to
operators. \\
\hline
-- & {\bf \htmlref{null}{systemdict:null}} & null & Create a null object. \\
\end{longtable}

\begin{description}
\label{systemdict:sym_bang_hash}
\index{"!#@\onyxop{}{"!\#}{}}
\item[{\onyxop{mark names}{!\#}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[names: ]
			Zero or more name objects.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove mark and name objects constructed as a side effect of
		interpreter magic.  This operator is an alias of
		\htmlref{cleartomark}{systemdict:cleartomark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> #!/usr/local/bin/onyx pstack
/onyx
/bin
/local
/usr
-mark-
onyx:5> !#
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_hash_bang}
\index{#"!@\onyxop{}{\#"!}{}}
\item[{\onyxop{--}{\#!}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a mark object in preparation for an interpreter path.
		This operator is an alias of \htmlref{mark}{systemdict:mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> #! pstack
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lp}
\index{(@\onyxop{}{(}{}}
\item[{\onyxop{--}{(}{fino}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a fino object onto the operand stack to denote the bottom
		of a stack that has not yet been constructed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (
onyx:1> pstack
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_rp}
\index{)@\onyxop{}{)}{}}
\item[{\onyxop{fino objects}{)}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object, usually created by the \onyxop{}{)}{}
			operator.
		\item[objects: ]
			0 or more objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedfino}{unmatchedfino}.]
		\end{description}
	\item[Description: ]
		Create a stack object and move all objects from the operand
		stack down to the first fino object to the new stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ()
onyx:1> 1 sprint
()
onyx:0> (1 2
onyx:3> pstack
2
1
-fino-
onyx:3> )
onyx:1> 1 sprint
(1 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lt}
\index{<@\onyxop{}{{\lt}}{}}
\item[{\onyxop{--}{{\lt}}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sym_gt}
\index{>@\onyxop{}{{\gt}}{}}
\item[{\onyxop{--}{{\gt}}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sym_lb}
\index{[@\onyxop{}{{\lb}}{}}
\item[{\onyxop{--}{{\lb}}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sym_rb}
\index{]@\onyxop{}{{\rb}}{}}
\item[{\onyxop{--}{{\rb}}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:abs}
\index{abs@\onyxop{}{abs}{}}
\item[{\onyxop{a}{abs}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Absolute value of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the absolute value of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 abs 1 sprint
5
onyx:0> -5 abs 1 sprint
5
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:add}
\index{add@\onyxop{}{add}{}}
\item[{\onyxop{a b}{add}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The sum of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the sum of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 2 add 1 sprint
4
onyx:0> -1 3 add 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:aload}
\index{aload@\onyxop{}{aload}{}}
\item[{\onyxop{--}{aload}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:and}
\index{and@\onyxop{}{and}{}}
\item[{\onyxop{a b}{and}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			and, otherwise their logical and.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise and of two integers, or the logical and of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false true and 1 sprint
false
onyx:0> true true and 1 sprint
true
onyx:0> 5 3 and 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:argv}
\index{argv@\onyxop{}{argv}{}}
\item[{\onyxop{--}{argv}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:array}
\index{array@\onyxop{}{array}{}}
\item[{\onyxop{--}{array}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:astore}
\index{astore@\onyxop{}{astore}{}}
\item[{\onyxop{--}{astore}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:begin}
\index{begin@\onyxop{}{begin}{}}
\item[{\onyxop{--}{begin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:bind}
\index{bind@\onyxop{}{bind}{}}
\item[{\onyxop{proc}{bind}{proc}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			A procedure (array).  \oparg{proc} will be bound even if
			it is literal, but contained literal arrays will not be
			recursively bound.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[proc: ]
			The same procedure as was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Recursively bind unbound procedures.  Executable names within a
		procedure are replaced with their values if defined in dstack,
		in any of the following cases:
		\begin{itemize}
		\item{The value is an executable operator.}
		\item{The value is a literal object.}
		\end{itemize}
	\item[Example(s): ]\begin{verbatim}

onyx:0> {pop product globaldict {pop product globaldict}}
onyx:1> dup 2 sprint
{pop product globaldict {pop product globaldict}}
onyx:1> bind
onyx:1> dup 2 sprint
{--pop-- `Canonware onyx' <> {--pop-- `Canonware onyx' -dict-}}
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:broadcast}
\index{broadcast@\onyxop{}{broadcast}{}}
\item[{\onyxop{--}{broadcast}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:bytesavailable}
\index{bytesavailable@\onyxop{}{bytesavailable}{}}
\item[{\onyxop{--}{bytesavailable}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:catenate}
\index{catenate@\onyxop{}{catenate}{}}
\item[{\onyxop{[a] [b]}{catenate}{[a b]}}: ]
\item[{\onyxop{(a) (b)}{catenate}{(a b)}}: ]
\item[{\onyxop{`a' `b'}{catenate}{`ab'}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An array, stack, or string.
		\item[b: ]
			An array, stack, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[ab: ]
			The catenation of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Catenate two arrays, strings, or stacks.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b'] catenate
onyx:1> 1 sprint
[`a' `b']
onyx:0> (`a') (`b') catenate
onyx:1> 1 sprint
(`a' `b')
onyx:0> `a' `b' catenate
onyx:1> 1 sprint
`ab'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cd}
\index{cd@\onyxop{}{cd}{}}
\item[{\onyxop{path}{cd}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Change the present working directory to \oparg{path}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd 1 sprint
`/usr/local'
onyx:0> `bin' cd
onyx:0> pwd 1 sprint
`/usr/local/bin'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:chmod}
\index{chmod@\onyxop{}{chmod}{}}
\item[{\onyxop{--}{chmod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:chown}
\index{chown@\onyxop{}{chown}{}}
\item[{\onyxop{--}{chown}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:clear}
\index{clear@\onyxop{}{clear}{}}
\item[{\onyxop{objects}{clear}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			All objects on ostack.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Pop all objects off of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 pstack
3
2
1
onyx:3> clear pstack
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cleardstack}
\index{cleardstack@\onyxop{}{cleardstack}{}}
\item[{\onyxop{--}{cleardstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:cleartomark}
\index{cleartomark@\onyxop{}{cleartomark}{}}
\item[{\onyxop{mark \dots}{cleartomark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[\dots: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from ostack down to and including the topmost
		mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 mark 1 0 pstack
0
1
-mark-
3
onyx:4> cleartomark pstack
3
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:close}
\index{close@\onyxop{}{close}{}}
\item[{\onyxop{--}{close}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:condition}
\index{condition@\onyxop{}{condition}{}}
\item[{\onyxop{--}{condition}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:copy}
\index{copy@\onyxop{}{copy}{}}
\item[{\onyxop{--}{copy}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:count}
\index{count@\onyxop{}{count}{}}
\item[{\onyxop{--}{count}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects on ostack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 1 0 count pstack
3
0
1
2
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:countdstack}
\index{countdstack@\onyxop{}{countdstack}{}}
\item[{\onyxop{--}{countdstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:countestack}
\index{countestack@\onyxop{}{countestack}{}}
\item[{\onyxop{--}{countestack}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects currently on the execution stack
			(recursion depth).
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the current number of objects on the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> countestack 1 sprint
3
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:counttomark}
\index{counttomark@\onyxop{}{counttomark}{}}
\item[{\onyxop{mark \dots}{counttomark}{mark \dots count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[\dots: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			The same mark that was passed in.
		\item[\dots: ]
			The same non-mark objects that were passed in.
		\item[count: ]
			The depth of \oparg{mark} on ostack.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 mark 2 1 0 counttomark 1 sprint
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:currentdict}
\index{currentdict@\onyxop{}{currentdict}{}}
\item[{\onyxop{--}{currentdict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:currentfile}
\index{currentfile@\onyxop{}{currentfile}{}}
\item[{\onyxop{--}{currentfile}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:currentlocking}
\index{currentlocking@\onyxop{}{currentlocking}{}}
\item[{\onyxop{--}{currentlocking}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:cvlit}
\index{cvlit@\onyxop{}{cvlit}{}}
\item[{\onyxop{object}{cvlit}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in, but with the literal
			attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the literal attribute for \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} cvlit 1 sprint
[1 2 3]
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvn}
\index{cvn@\onyxop{}{cvn}{}}
\item[{\onyxop{string}{cvn}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			A literal name that corresponds to \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{string} to a literal name.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `foo' cvn 1 sprint
/foo
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvrs}
\index{cvrs@\onyxop{}{cvrs}{}}
\item[{\onyxop{integer radix}{cvrs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer.
		\item[radix: ]
			A numerical base, from 2 to 36, inclusive.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{integer} to a string representation in base
		\oparg{radix}.  \oparg{integer} is treated as a 64 bit unsigned
		integer, so the results for negative integers will not generally
		be useful.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42 2 cvrs 1 sprint
`101010'
onyx:0> 42 16 cvrs 1 sprint
`2a'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvs}
\index{cvs@\onyxop{}{cvs}{}}
\item[{\onyxop{object}{cvs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{object}.  The string
			depends on the type of \oparg{object}:
			\begin{description}
			\item[boolean: ] {\tt `true'} or  {\tt `false'}.
			\item[name: ] The string representation of the name.
			\item[integer: ] The integer in base 10.
			\item[operator: ] The string representation of the
			operator name or {\tt `-operator-'}.
			\item[string: ] The same as \oparg{object}.
			\item[Other types: ] {\tt `--nostringval--'}.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{object} to a string representation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true cvs 1 sprint
`true'
onyx:0> /foo cvs 1 sprint
`foo'
onyx:0> 42 cvs 1 sprint
`42'
onyx:0> //pop cvs 1 sprint
`pop'
onyx:0> `foo' cvs 1 sprint
`foo'
onyx:0> mutex cvs 1 sprint
`--nostringval--'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvx}
\index{cvx@\onyxop{}{cvx}{}}
\item[{\onyxop{object}{cvx}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in, but with the
			executable attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the executable attribute for \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] cvx 1 sprint
{1 2 3}
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:def}
\index{def@\onyxop{}{def}{}}
\item[{\onyxop{--}{def}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:detach}
\index{detach@\onyxop{}{detach}{}}
\item[{\onyxop{--}{detach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:dict}
\index{dict@\onyxop{}{dict}{}}
\item[{\onyxop{--}{dict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:die}
\index{die@\onyxop{}{die}{}}
\item[{\onyxop{--}{die}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:dirforeach}
\index{dirforeach@\onyxop{}{dirforeach}{}}
\item[{\onyxop{path proc}{dirforeach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\item[proc: ]
			An object to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		For each entry in the directory represented by \oparg{path},
		push a string that represents the entry onto ostack and
		execute \oparg{proc}.  This operator supports the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd {1 sprint} dirforeach
`.'
`..'
`CVS'
`.cvsignore'
`Cookfile'
`Cookfile.inc'
`latex'
`ps'
`pdf'
`html'
onyx:0> pwd {`Cookfile.inc' search
     {pop `Yes: ' print 1 sprint pop exit}
     {`Not: ' print 1 sprint} ifelse
} dirforeach
Not: `.'
Not: `..'
Not: `CVS'
Not: `.cvsignore'
Not: `Cookfile'
Yes: `Cookfile.inc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:div}
\index{div@\onyxop{}{div}{}}
\item[{\onyxop{a b}{div}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The quotient of \oparg{a} divided by \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
		Return the quotient of \oparg{a} divided by \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 div 1 sprint
2
onyx:0> 5 2 div 1 sprint
2
onyx:0> 5 0 div
Error /undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --div--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:dup}
\index{dup@\onyxop{}{dup}{}}
\item[{\onyxop{object}{dup}{object object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the top object on ostack.  For composite
		objects, the new object is a reference to the same composite
		object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 dup pstack
1
1
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:end}
\index{end@\onyxop{}{end}{}}
\item[{\onyxop{--}{end}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:envdict}
\index{envdict@\onyxop{}{envdict}{}}
\item[{\onyxop{--}{envdict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:eq}
\index{eq@\onyxop{}{eq}{}}
\item[{\onyxop{a b}{eq}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for equality.  Equality has the following
		meaning, depending on the types of \oparg{a} and \oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are equal iff they refer to
		the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are equal iff they
		refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are equal iff they
		are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are equal iff they
		are the same value.
		\item[integer: ] \oparg{a} and \oparg{b} are equal iff they
		are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex eq 1 sprint
false
onyx:0> mutex dup eq 1 sprint
true
onyx:0> /foo `foo' eq 1 sprint
true
onyx:0> true true eq 1 sprint
true
onyx:0> true false eq 1 sprint
false
onyx:0> 1 1 eq 1 sprint
true
onyx:0> 1 2 eq 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the execution stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:eval}
\index{eval@\onyxop{}{eval}{}}
\item[{\onyxop{object}{eval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ``hi' 1 sprint' cvx eval
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exch}
\index{exch@\onyxop{}{exch}{}}
\item[{\onyxop{a b}{exch}{b a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			The same object that was passed in.
		\item[a: ]
			The same object that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 pstack
2
1
onyx:2> exch pstack
1
2
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:exec}
\index{exec@\onyxop{}{exec}{}}
\item[{\onyxop{--}{exec}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:exit}
\index{exit@\onyxop{}{exit}{}}
\item[{\onyxop{--}{exit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Exit the innermost enclosing looping context immediately.
		This operator can be called within the looping context of
		\htmlref{\onyxop{}{for}{}}{systemdict:for},
		\htmlref{\onyxop{}{repeat}{}}{systemdict:repeat},
		\htmlref{\onyxop{}{loop}{}}{systemdict:loop},
		\htmlref{\onyxop{}{foreach}{}}{systemdict:foreach}, and
		\htmlref{\onyxop{}{dirforeach}{}}{systemdict:dirforeach}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {`hi' 1 sprint exit `bye' 1 sprint} loop
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exp}
\index{exp@\onyxop{}{exp}{}}
\item[{\onyxop{a b}{exp}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-negative. integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} to the \oparg{b} power.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return \oparg{a} to the \oparg{b} power.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 0 exp 1 sprint
1
onyx:0> 5 1 exp 1 sprint
5
onyx:0> 5 2 exp 1 sprint
25
onyx:0> -5 3 exp 1 sprint
-125
onyx:0> 5 -3 exp 1 sprint
Error /rangecheck
ostack: (5 -3)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --exp--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:false}
\index{false@\onyxop{}{false}{}}
\item[{\onyxop{--}{false}{false}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[false: ]
			The boolean value false.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return false.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:flush}
\index{flush@\onyxop{}{flush}{}}
\item[{\onyxop{--}{flush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:flushfile}
\index{flushfile@\onyxop{}{flushfile}{}}
\item[{\onyxop{--}{flushfile}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:for}
\index{for@\onyxop{}{for}{}}
\item[{\onyxop{init inc limit proc}{for}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[init: ]
			Initial value of control variable.
		\item[inc: ]
			Amount to increment control variable by at the end of
			each iteration.
		\item[limit: ]
			Inclusive upper bound for control variable if less than
			or equal to \oparg{init}, otherwise inclusive lower
			bound for control variable.
		\item[proc: ]
			An object.
		\end{description}
	\item[Output(s): ]  At the beginning of each iteration, the current
		value of the control variable is pushed onto ostack.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Iteratively evaluate \oparg{proc}, pushing a control variable
		onto ostack at the beginning of each iteration, until the
		control variable has exceeded \oparg{limit}.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 3 {1 sprint} for
0
1
2
3
onyx:0> 0 -1 -3 {1 sprint} for
0
-1
-2
-3
onyx:0> 0 2 7 {1 sprint} for
0
2
4
6
onyx:0> 0 1 1000 {dup 1 sprint 3 eq {exit} if} for
0
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:foreach}
\index{foreach@\onyxop{}{foreach}{}}
\item[{\onyxop{--}{foreach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:fork}
\index{fork@\onyxop{}{fork}{}}
\item[{\onyxop{--}{fork}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:gcdict}
\index{gcdict@\onyxop{}{gcdict}{}}
\item[{\onyxop{--}{gcdict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:ge}
\index{ge@\onyxop{}{ge}{}}
\item[{\onyxop{a b}{ge}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or string.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two integers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 ge 1 sprint
false
onyx:0> 1 1 ge 1 sprint
true
onyx:0> 2 1 ge 1 sprint
true
onyx:0> `a' `b' ge 1 sprint
false
onyx:0> `a' `a' ge 1 sprint
true
onyx:0> `b' `a' ge 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:get}
\index{get@\onyxop{}{get}{}}
\item[{\onyxop{--}{get}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:getinterval}
\index{getinterval@\onyxop{}{getinterval}{}}
\item[{\onyxop{--}{getinterval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:gt}
\index{gt@\onyxop{}{gt}{}}
\item[{\onyxop{a b}{gt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or string.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two integers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 1 gt 1 sprint
false
onyx:0> 2 1 gt 1 sprint
true
onyx:0> `a' `a' gt 1 sprint
false
onyx:0> `b' `a' gt 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:if}
\index{if@\onyxop{}{if}{}}
\item[{\onyxop{boolean object}{if}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object} if \oparg{boolean} is true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes' 1 sprint} if
`yes'
onyx:0> false {`yes' 1 sprint} if
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ifelse}
\index{ifelse@\onyxop{}{ifelse}{}}
\item[{\onyxop{boolean a b}{ifelse}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{a} if \oparg{boolean} is true, evaluate
		\oparg{b} otherwise.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes'}{`no'} ifelse 1 sprint
`yes'
onyx:0> false {`yes'}{`no'} ifelse 1 sprint
`no'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:index}
\index{index@\onyxop{}{index}{}}
\item[{\onyxop{object \dots index}{index}{object \dots object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\item[\dots: ]
			\oparg{index} objects.
		\item[index: ]
			Depth (count starts at 0, not counting \oparg{index}) of
			the object to duplicate on ostack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in.
		\item[\dots: ]
			The same \oparg{index} objects that were passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on on ostack at depth
		\oparg{index}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 2 index pstack
2
0
1
2
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the index stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the index stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> istack 1 sprint
(0 0 0)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:join}
\index{join@\onyxop{}{join}{}}
\item[{\onyxop{--}{join}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:known}
\index{known@\onyxop{}{known}{}}
\item[{\onyxop{--}{known}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:lcheck}
\index{lcheck@\onyxop{}{lcheck}{}}
\item[{\onyxop{object}{lcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An array, dict, file, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{object} is implicitly locked, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Check if \oparg{object} is implicitly locked.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false setlocking
onyx:0> [1 2 3] lcheck 1 sprint
false
onyx:0> true setlocking
onyx:0> [1 2 3] lcheck 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:le}
\index{le@\onyxop{}{le}{}}
\item[{\onyxop{a b}{le}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or string.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two integers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 le 1 sprint
true
onyx:0> 1 1 le 1 sprint
true
onyx:0> 2 1 le 1 sprint
false
onyx:0> `a' `b' le 1 sprint
true
onyx:0> `a' `a' le 1 sprint
true
onyx:0> `b' `a' le 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:length}
\index{length@\onyxop{}{length}{}}
\item[{\onyxop{--}{length}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:link}
\index{link@\onyxop{}{link}{}}
\item[{\onyxop{--}{link}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:load}
\index{load@\onyxop{}{load}{}}
\item[{\onyxop{--}{load}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:lock}
\index{lock@\onyxop{}{lock}{}}
\item[{\onyxop{--}{lock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:loop}
\index{loop@\onyxop{}{loop}{}}
\item[{\onyxop{proc}{loop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Iteratively evaluate \oparg{proc} indefinitely.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 {1 add dup 1 sprint dup 3 eq {pop exit} if} loop
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:lt}
\index{lt@\onyxop{}{lt}{}}
\item[{\onyxop{a b}{lt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or string.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two integers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 lt 1 sprint
true
onyx:0> 1 1 lt 1 sprint
false
onyx:0> `a' `b' lt 1 sprint
true
onyx:0> `a' `a' lt 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mark}
\index{mark@\onyxop{}{mark}{}}
\item[{\onyxop{--}{mark}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a mark onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mark pstack
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:mkdir}
\index{mkdir@\onyxop{}{mkdir}{}}
\item[{\onyxop{--}{mkdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:mod}
\index{mod@\onyxop{}{mod}{}}
\item[{\onyxop{a b}{mod}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The modulus of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
			Return the modulus of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 mod 1 sprint
0
onyx:0> 5 2 mod 1 sprint
1
onyx:0> 5 0 mod
Error /undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --mod--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:monitor}
\index{monitor@\onyxop{}{monitor}{}}
\item[{\onyxop{mutex proc}{monitor}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex.
		\item[proc: ]
			Any object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Execute \oparg{proc} while holding \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex {`hello\n' print} monitor flush
hello
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mul}
\index{mul@\onyxop{}{mul}{}}
\item[{\onyxop{a b}{mul}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The product of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the product of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 17 mul 1 sprint
51
onyx:0> -5 -6 mul 1 sprint
30
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mutex}
\index{mutex@\onyxop{}{mutex}{}}
\item[{\onyxop{--}{mutex}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:ne}
\index{ne@\onyxop{}{ne}{}}
\item[{\onyxop{a b}{ne}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is not equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for inequality.  Inequality has the
		following meaning, depending on the types of \oparg{a} and
		\oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are not equal unless they
		refer to the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are not equal unless
		they refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are not equal iff
		they are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are not equal unless
		they are the same value.
		\item[integer: ] \oparg{a} and \oparg{b} are not equal unless
		they are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex ne 1 sprint
true
onyx:0> mutex dup ne 1 sprint
false
onyx:0> /foo `foo' ne 1 sprint
false
onyx:0> /foo /bar ne 1 sprint
true
onyx:0> true false ne 1 sprint
true
onyx:0> true true ne 1 sprint
false
onyx:0> 1 1 ne 1 sprint
false
onyx:0> 1 2 ne 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:neg}
\index{neg@\onyxop{}{neg}{}}
\item[{\onyxop{a}{neg}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The negative of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the negative of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 neg 1 sprint
0
onyx:0> 5 neg 1 sprint
-5
onyx:0> -5 neg 1 sprint
5
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:not}
\index{not@\onyxop{}{not}{}}
\item[{\onyxop{a}{not}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} is an integer, the bitwise negation of
			\oparg{a}, otherwise the logical negation of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise negation of an integer, or the logical
		negation of a boolean.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true not 1 sprint
false
onyx:0> false not 1 sprint
true
onyx:0> 1 not 1 sprint
-2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:nsleep}
\index{nsleep@\onyxop{}{nsleep}{}}
\item[{\onyxop{nanoseconds}{nsleep}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[nanoseconds: ]
			Minimum number of nanoseconds to sleep.  Must be greater
			than 0.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Sleep for at least \oparg{nanoseconds} nanonseconds.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1000 nsleep
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:null}
\index{null@\onyxop{}{null}{}}
\item[{\onyxop{--}{null}{null}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a null object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> null pstack
null
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:open}
\index{open@\onyxop{}{open}{}}
\item[{\onyxop{--}{open}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:or}
\index{or@\onyxop{}{or}{}}
\item[{\onyxop{a b}{or}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			or, otherwise their logical or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise or of two integers, or the logical or of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false false or 1 sprint
false
onyx:0> true false or 1 sprint
true
onyx:0> 5 3 or 1 sprint
7
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:pop}
\index{pop@\onyxop{}{pop}{}}
\item[{\onyxop{any}{pop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[any: ]
			Any object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Remove the top object off the operand stack and discard it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2
onyx:2> pstack
2
1
onyx:2> pop
onyx:1> pstack
1
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:print}
\index{print@\onyxop{}{print}{}}
\item[{\onyxop{--}{print}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:product}
\index{product@\onyxop{}{product}{}}
\item[{\onyxop{--}{product}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the product name, normally
			`Canonware onyx'.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the product string.  The string returned is a reference to
		the original product string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> product pstack
`Canonware onyx'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:put}
\index{put@\onyxop{}{put}{}}
\item[{\onyxop{--}{put}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:putinterval}
\index{putinterval@\onyxop{}{putinterval}{}}
\item[{\onyxop{--}{putinterval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:pwd}
\index{pwd@\onyxop{}{pwd}{}}
\item[{\onyxop{--}{pwd}{path}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents the present working directory.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\end{description}
	\item[Description: ]
		Push a string onto ostack that represents the present working
		directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd
onyx:1> pstack
`/usr/local/bin'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:quit}
\index{quit@\onyxop{}{quit}{}}
\item[{\onyxop{--}{quit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.  Under
		normal circumstances, there is always at least one such context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> estack 1 sprint
(--start-- -file- --start-- -file- --estack--)
onyx:0> quit
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rand}
\index{rand@\onyxop{}{rand}{}}
\item[{\onyxop{--}{rand}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			A pseudo-random non-negative integer, with 63 bits of
			psuedo-randomness.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return a pseudo-random integer.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 srand
onyx:0> rand 1 sprint
9018578418316157091
onyx:0> rand 1 sprint
8979240987855095636
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:read}
\index{read@\onyxop{}{read}{}}
\item[{\onyxop{--}{read}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:readline}
\index{readline@\onyxop{}{readline}{}}
\item[{\onyxop{--}{readline}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:realtime}
\index{realtime@\onyxop{}{realtime}{}}
\item[{\onyxop{--}{realtime}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:rename}
\index{rename@\onyxop{}{rename}{}}
\item[{\onyxop{--}{rename}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:repeat}
\index{repeat@\onyxop{}{repeat}{}}
\item[{\onyxop{count proc}{repeat}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of times to evaluate \oparg{proc} (non-negative).
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{proc} \oparg{count} times.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 {`hi' 1 sprint} repeat
`hi'
`hi'
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rmdir}
\index{rmdir@\onyxop{}{rmdir}{}}
\item[{\onyxop{--}{rmdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:roll}
\index{roll@\onyxop{}{roll}{}}
\item[{\onyxop{region count amount}{roll}{rolled}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[region: ]
			0 or more objects to be rolled.
		\item[count: ]
			Number of objects in \oparg{region}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[rolled: ]
			Rolled version of \oparg{region}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on the operand stack
		(not counting \oparg{count} and \oparg{amount}) by
		\oparg{amount} positions.  A positive \oparg{amount}
		indicates an upward roll, whereas a negative \oparg{amount}
		indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 
onyx:4> pstack
0
1
2
3
onyx:4> 3 1 roll
onyx:4> pstack
1
2
0
3
onyx:4> 3 -2 roll
onyx:4> pstack
2
0
1
3
onyx:4> 4 0 roll
onyx:4> pstack
2
0
1
3
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:sclear}
\index{sclear@\onyxop{}{sclear}{}}
\item[{\onyxop{stack}{sclear}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove all objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) pstack
(1 2 3 4)
onyx:1> sclear pstack
()
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scleartomark}
\index{scleartomark@\onyxop{}{scleartomark}{}}
\item[{\onyxop{stack}{scleartomark}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from \oparg{stack} down to and including the
		topmost mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) scleartomark pstack
(3)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scount}
\index{scount@\onyxop{}{scount}{}}
\item[{\onyxop{stack}{scount}{stack count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\item[count: ]
			The number of objects on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the number of objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) scount
onyx:2> pstack
2
(1 2)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:scounttomark}
\index{scounttomark@\onyxop{}{scounttomark}{}}
\item[{\onyxop{stack}{scounttomark}{stack count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\item[count: ]
			The depth of the topmost mark on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchemark}{unmatchemark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) scounttomark pstack
2
(3 -mark- 1 0)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sdup}
\index{sdup@\onyxop{}{sdup}{}}
\item[{\onyxop{stack}{sdup}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Duplicate the top object on \oparg{stack} and push it onto
		\oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1) sdup
onyx:1> pstack
(1 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:seek}
\index{seek@\onyxop{}{seek}{}}
\item[{\onyxop{--}{seek}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:self}
\index{self@\onyxop{}{self}{}}
\item[{\onyxop{--}{self}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:setlocking}
\index{setlocking@\onyxop{}{setlocking}{}}
\item[{\onyxop{--}{setlocking}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sexch}
\index{sexch@\onyxop{}{sexch}{}}
\item[{\onyxop{stack}{sexch}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3) sexch pstack
(1 3 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:shift}
\index{shift@\onyxop{}{shift}{}}
\item[{\onyxop{--}{shift}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[shift: ]
			An integer that represents a bitwise shift amount.
			Negative means right shift, and positive means left
			shift.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} shifted by \oparg{shift} bits.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Shift an integer bitwise.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 1 shift 1 sprint
8
onyx:0> 4 -1 shift 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:signal}
\index{signal@\onyxop{}{signal}{}}
\item[{\onyxop{--}{signal}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sindex}
\index{sindex@\onyxop{}{sindex}{}}
\item[{\onyxop{stack index}{sindex}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Depth (count starts at 0) of the object to duplicate in
			\oparg{stack}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on \oparg{stack} at depth
		\oparg{index} and push it onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) 2 sindex
onyx:1> pstack
(3 2 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sload}
\index{sload@\onyxop{}{sload}{}}
\item[{\onyxop{--}{sload}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:spop}
\index{spop@\onyxop{}{spop}{}}
\item[{\onyxop{stack}{spop}{stack object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\item[object: ]
			The object that was popped off of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop an object off of \oparg{stack} and push it onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) spop
onyx:2> pstack
2
(1)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sprint}
\index{sprint@\onyxop{}{sprint}{}}
\item[{\onyxop{--}{sprint}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sprintdict}
\index{sprintdict@\onyxop{}{sprintdict}{}}
\item[{\onyxop{--}{sprintdict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:spush}
\index{spush@\onyxop{}{spush}{}}
\item[{\onyxop{stack object}{spush}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{object} onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> () 1 spush
onyx:1> pstack
(1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:srand}
\index{srand@\onyxop{}{srand}{}}
\item[{\onyxop{seed}{srand}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seed: ]
			A non-negative integer.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Seed the pseudo-random number generator with \oparg{seed}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 srand
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sroll}
\index{sroll@\onyxop{}{sroll}{}}
\item[{\onyxop{--}{sroll}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects to roll in \oparg{stack}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The same stack that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on \oparg{stack} by
		\oparg{amount} positions.  A positive \oparg{amount}
		indicates an upward roll, whereas a negative \oparg{amount}
		indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) pstack
(3 2 1 0)
onyx:1> 3 1 sroll pstack
(3 0 2 1)
onyx:1> 3 -2 sroll pstack
(3 1 0 2)
onyx:1> 4 0 sroll pstack
(3 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sstore}
\index{sstore@\onyxop{}{sstore}{}}
\item[{\onyxop{--}{sstore}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:stack}
\index{stack@\onyxop{}{stack}{}}
\item[{\onyxop{--}{stack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An empty stack object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a new stack object and push it onto the operand stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stack
onyx:1> pstack
()
		\end{verbatim}
	\end{description}
\label{systemdict:start}
\index{start@\onyxop{}{start}{}}
\item[{\onyxop{object}{start}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  This operator provides a context that
		silently terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit},
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}, and
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operators.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> quit
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:status}
\index{status@\onyxop{}{status}{}}
\item[{\onyxop{--}{status}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:stderr}
\index{stderr@\onyxop{}{stderr}{}}
\item[{\onyxop{--}{stderr}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:stdin}
\index{stdin@\onyxop{}{stdin}{}}
\item[{\onyxop{--}{stdin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:stdout}
\index{stdout@\onyxop{}{stdout}{}}
\item[{\onyxop{--}{stdout}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{stopped}{}}{systemdict:stopped} or
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stopped}
\index{stopped@\onyxop{}{stopped}{}}
\item[{\onyxop{object}{stopped}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if stop operator was executed, false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidexit}{invalidexit}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  This operator provides a context that
		terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop}.  It will also
		terminate execution stack unwinding due to the 
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator, but will
		throw an \htmlref{invalidexit}{invalidexit} error, then do the
		equivalent of calling
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0> {} stopped 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:store}
\index{store@\onyxop{}{store}{}}
\item[{\onyxop{--}{store}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:string}
\index{string@\onyxop{}{string}{}}
\item[{\onyxop{--}{string}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sub}
\index{sub@\onyxop{}{sub}{}}
\item[{\onyxop{a b}{sub}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The value of \oparg{b} subtracted from \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Subtract \oparg{b} from \oparg{a} and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 3 sub 1 sprint
2
onyx:0> -3 4 sub 1 sprint
-7
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:symlink}
\index{symlink@\onyxop{}{symlink}{}}
\item[{\onyxop{--}{symlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:tell}
\index{tell@\onyxop{}{tell}{}}
\item[{\onyxop{--}{tell}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:test}
\index{test@\onyxop{}{test}{}}
\item[{\onyxop{--}{test}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:thread}
\index{thread@\onyxop{}{thread}{}}
\item[{\onyxop{--}{thread}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:throw}
\index{throw@\onyxop{}{throw}{}}
\item[{\onyxop{name}{throw}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ] The name of an error, which can be any of the
		following:
			\begin{description}
			\item[\htmlref{\onyxop{}{dstackunderflow}{}}
			{errordict:dstackunderflow}.]
			\item[\htmlref{\onyxop{}{estackoverflow}{}}
			{errordict:estackoverflow}.]
			\item[\htmlref{\onyxop{}{invalidaccess}{}}
			{errordict:invalidaccess}.]
			\item[\htmlref{\onyxop{}{invalidcontext}{}}
			{errordict:invalidcontext}.]
			\item[\htmlref{\onyxop{}{invalidexit}{}}
			{errordict:invalidexit}.]
			\item[\htmlref{\onyxop{}{invalidfileaccess}{}}
			{errordict:invalidfileaccess}.]
			\item[\htmlref{\onyxop{}{ioerror}{}}
			{errordict:ioerror}.]
			\item[\htmlref{\onyxop{}{limitcheck}{}}
			{errordict:limitcheck}.]
			\item[\htmlref{\onyxop{}{rangecheck}{}}
			{errordict:rangecheck}.]
			\item[\htmlref{\onyxop{}{stackunderflow}{}}
			{errordict:stackunderflow}.]
			\item[\htmlref{\onyxop{}{syntaxerror}{}}
			{errordict:syntaxerror}.]
			\item[\htmlref{\onyxop{}{typecheck}{}}
			{errordict:typecheck}.]
			\item[\htmlref{\onyxop{}{undefined}{}}
			{errordict:undefined}.]
			\item[\htmlref{\onyxop{}{undefinedfilename}{}}
			{errordict:undefinedfilename}.]
			\item[\htmlref{\onyxop{}{undefinedresult}{}}
			{errordict:undefinedresult}.]
			\item[\htmlref{\onyxop{}{unmatchedmark}{}}
			{errordict:unmatchedmark}.]
			\item[\htmlref{\onyxop{}{unmatchedfino}{}}
			{errordict:unmatchedfino}.]
			\item[\htmlref{\onyxop{}{unregistered}{}}
			{errordict:unregistered}.]
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The object that was being executed when the error was
			thrown.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Throw an error.  This operator goes through the following steps:
		\begin{enumerate}
		\item{Set newerror in the currenterror dictionary to true.}
		\item{Set errorname in the currenterror dictionary to
		\oparg{name}.}
		\item{Set ostack, dstack, estack, and istack in the currenterror
		dictionary to be current stack snapshots.}
		\item{Push the object that was being executed before throw was
		called onto ostack.}
		\item{Evaluate the error handler in the errordict dictionary
		that corresponds to \oparg{name}.}
		\item{Evaluate the errordict dictionary's
		\htmlref{\onyxop{}{stop}{}}{errordict:stop}.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> /unregistered throw
Error /unregistered
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:1> pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:timedwait}
\index{timedwait@\onyxop{}{timedwait}{}}
\item[{\onyxop{--}{timedwait}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:token}
\index{token@\onyxop{}{token}{}}
\item[{\onyxop{--}{token}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:truncate}
\index{truncate@\onyxop{}{truncate}{}}
\item[{\onyxop{--}{truncate}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:true}
\index{true@\onyxop{}{true}{}}
\item[{\onyxop{--}{true}{true}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[true: ]
			The boolean value true.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:trylock}
\index{trylock@\onyxop{}{trylock}{}}
\item[{\onyxop{--}{trylock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:type}
\index{type@\onyxop{}{type}{}}
\item[{\onyxop{object}{type}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			An executable name that corresponds to the type of
			\oparg{object}:
			\begin{description}
			\item[array: ] arraytype.
			\item[boolean: ] booleantype.
			\item[condition: ] conditiontype.
			\item[dict: ] dicttype.
			\item[file: ] filetype.
			\item[fino: ] finotype.
			\item[hook: ] hooktype.
			\item[integer: ] integertype.
			\item[mark: ] marktype.
			\item[mutex: ] mutextype.
			\item[name: ] nametype.
			\item[null: ] nulltype.
			\item[operator: ] operatortype.
			\item[pmark: ] pmarktype.
			\item[stack: ] stacktype.
			\item[string: ] stringtype.
			\item[thread: ] threadtype.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Get a name that represent the type of \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true type 1 sprint
booleantype
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:undef}
\index{undef@\onyxop{}{undef}{}}
\item[{\onyxop{--}{undef}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:unlink}
\index{unlink@\onyxop{}{unlink}{}}
\item[{\onyxop{--}{unlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:unlock}
\index{unlock@\onyxop{}{unlock}{}}
\item[{\onyxop{--}{unlock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:version}
\index{version@\onyxop{}{version}{}}
\item[{\onyxop{--}{version}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the version name.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the version string.  The string returned is a reference to
		the original version string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> version pstack
`2.0.0'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:wait}
\index{wait@\onyxop{}{wait}{}}
\item[{\onyxop{--}{wait}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:waitpid}
\index{waitpid@\onyxop{}{waitpid}{}}
\item[{\onyxop{--}{waitpid}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:where}
\index{where@\onyxop{}{where}{}}
\item[{\onyxop{--}{where}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:write}
\index{write@\onyxop{}{write}{}}
\item[{\onyxop{--}{write}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:xcheck}
\index{xcheck@\onyxop{}{xcheck}{}}
\item[{\onyxop{object}{xcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{object} has the executable attribute,
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Check \oparg{object} for executable attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} xcheck 1 sprint
true
onyx:0> [1 2 3] xcheck 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:xor}
\index{xor@\onyxop{}{xor}{}}
\item[{\onyxop{a b}{xor}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			exclusive or, otherwise their logical exclusive or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise exclusive or of two integers, or the logical
		exclusive or of two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true false xor 1 sprint
true
onyx:0> true true xor 1 sprint
false
onyx:0> 5 3 xor 1 sprint
6
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:yield}
\index{yield@\onyxop{}{yield}{}}
\item[{\onyxop{--}{yield}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\end{description}

\subsection{threaddict}
\label{sec:threaddict}

Each thread has its own threaddict, which is not shared with any other threads.
threaddict is meant to be used for thread-specific definitions that would
otherwise go in systemdict.

\begin{longtable}{\optableformat{3}}
\caption[threaddict summary]{threaddict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
& {\bf \htmlref{threaddict}{threaddict:threaddict}} & & \\
\hline
& {\bf \htmlref{userdict}{threaddict:userdict}} & & \\
\hline
& {\bf \htmlref{currenterror}{threaddict:currenterror}} & & \\
\hline
& {\bf \htmlref{errordict}{threaddict:errordict}} & & \\
\end{longtable}

\begin{description}
\label{threaddict:currenterror}
\index{currenterror@\onyxop{}{currenterror}{}}
\item[{\onyxop{--}{currenterror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{threaddict:errordict}
\index{errordict@\onyxop{}{errordict}{}}
\item[{\onyxop{--}{errordict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{threaddict:threaddict}
\index{threaddict@\onyxop{}{threaddict}{}}
\item[{\onyxop{--}{threaddict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{threaddict:userdict}
\index{userdict@\onyxop{}{userdict}{}}
\item[{\onyxop{--}{userdict}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{XXX stackunderflow}{XXX stackunderflow}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\end{description}

\subsection{userdict}
\label{sec:userdict}

Each thread has its own userdict, which is not shared with any other threads.
userdict is meant to be used for general storage of definitions that do not need
to be shared among threads.  userdict starts out empty when a thread is
created.

%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx reference portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Reference}
\label{onyxlang}

Onyx is a stack-based, threaded, interpreted language.  Its closest relative is
Adobe PostScript, followed by Forth.  Experienced PostScript programmers should
find most aspects of Onyx familiar, but there are significant differences that
will prevent a knowledgeable PostScript programmer from programming in Onyx
without first skimming this chapter.  This chapter does not assume specific
knowledge of other programming languages, so stands as a definitive reference
for Onyx.

Onyx is different from most languages in that it is not compiled, but rather
consumed.  For example, there are mechanisms for creating the equivalent of
named procedures that can be called at a later time, but behind the scenes, the
code is actually being interpreted as it is scanned in such a way that an
executable object is created.  As such, Onyx is not suited for compilation,
native or byte code.  However, the language syntax is very simple and the
scanner/parser is extremely fast.  There is also an operator called
\htmlref{\onyxop{}{bind}{}}{systemdict:bind} that optimizes interpreted code
execution to approximately the same performance level as would be expected of a
byte code interpreter.

Onyx is implemented as a C library that can be embedded in other programs.
Mechanisms are provided for extending the set of operators available.  This
manual only documents the base language; see application-specific documentation
for any language extensions.

Following is a list of basic language features that are discussed in more detail
later in this chapter:

\begin{itemize}
\item{Stack-based.  There are no named variables as in procedural languages.
Operations are done using various stacks, so Onyx operations are coded in
postfix order.}
\item{Threaded.  Onyx's threading uses the native POSIX threads implementation
of the operating system (or GNU pth, if so configured).}
\item{Interpreted.  Onyx code is never compiled, but is instead interpreted as
it is encountered.}
\item{Garbage-collected.  There is no need to manually track memory allocation,
since the interpreter has an integrated automatic mark and sweep garbage
collector.}
\end{itemize}

\section{Objects}
\label{sec:onyx_objects}

An Onyx object has three aspects: type, attribute, and value.

Objects fall into two categories according to type: simple and composite.  A
simple object takes up no memory of its own; it uses space within a stack,
array, or dictionary.  A composite object requires space of its own in addition
to the space taken up in stacks, arrays, or dictionaries to refer to the
composite object.  See Table~\ref{simple-composite} for object type
classifications.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Simple	& Composite	\\
\hline \hline
boolean	& array		\\
fino	& condition	\\
integer	& dict		\\
mark	& file		\\
name	& hook		\\
null	& mutex		\\
operator & regex	\\
pmark	& regsub	\\
real	& stack		\\
	& string	\\
	& thread	\\
\hline
\end{tabular}
\end{center}
\caption{\label{simple-composite}
Simple and composite types}
\end{table}

There can be multiple references that refer to the same memory backing composite
objects.  In most cases, composite objects that refer to the same memory are
indistinguishable, but for arrays and strings, composite objects may only be
able to access a subset of the total memory backing them.  This behavior is
described in detail later.

All objects have a literal, executable, or evaluatable attribute associated with
them.  Composite objects each have their own attribute, even for composite
objects that share the same backing memory.  Objects are ``interpreted'' when
they are encountered directly by the interpreter.  Objects can also be
``evaluated''.  One of two actions is taken when an object is interpreted or
evaluated:

\begin{itemize}
\item{The object may be treated as code (executed).  When executed, an object is
pushed onto the execution stack and executed.}
\item{The object may be treated as data.  A data object is push onto the operand
stack.}
\end{itemize}

Table~\ref{interp-act} enumerates under what circumstances object interpretation
results in execution.  Table~\ref{eval-act} enumerates under what circumstances
object evaluation results in execution.  Note that executable arrays are the
only objects that behave differently when interpreted versus evaluated.

In practice, attributes are only useful for types that can be executed.
Attributes are not considered in equality test operations.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Type		& \multicolumn{3}{|c|}{Attribute}	\\
\cline{2-4}
		& literal & executable & evaluatable	\\
\hline \hline
array		& data	& data	& code	\\
\hline
boolean		& data	& data	& data	\\
\hline
condition	& data	& data	& data	\\
\hline
dict		& data	& data	& data	\\
\hline
file		& data	& code	& code	\\
\hline
fino		& data	& data	& data	\\
\hline
hook		& data	& code	& code	\\
\hline
integer		& data	& data	& data	\\
\hline
mark		& data	& data	& data	\\
\hline
mutex		& data	& data	& data	\\
\hline
name		& data	& code	& code	\\
\hline
null		& data	& code	& code	\\
\hline
operator	& data	& code	& code	\\
\hline
pmark		& data	& data	& data	\\
\hline
real		& data	& data	& data	\\
\hline
regex		& data	& data	& data	\\
\hline
regsub		& data	& data	& data	\\
\hline
stack		& data	& data	& data	\\
\hline
string		& data	& code	& code	\\
\hline
thread		& data	& data	& data	\\
\hline
\end{tabular}
\end{center}
\caption{\label{interp-act}
Interpretation of objects by type and attribute}
\end{table}

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Type		& \multicolumn{3}{|c|}{Attribute}	\\
\cline{2-4}
		& literal & executable & evaluatable	\\
\hline \hline
array		& data	& code	& code	\\
\hline
boolean		& data	& data	& data	\\
\hline
condition	& data	& data	& data	\\
\hline
dict		& data	& data	& data	\\
\hline
file		& data	& code	& code	\\
\hline
fino		& data	& data	& data	\\
\hline
hook		& data	& code	& code	\\
\hline
integer		& data	& data	& data	\\
\hline
mark		& data	& data	& data	\\
\hline
mutex		& data	& data	& data	\\
\hline
name		& data	& code	& code	\\
\hline
null		& data	& code	& code	\\
\hline
operator	& data	& code	& code	\\
\hline
pmark		& data	& data	& data	\\
\hline
real		& data	& data	& data	\\
\hline
regex		& data	& data	& data	\\
\hline
regsub		& data	& data	& data	\\
\hline
stack		& data	& data	& data	\\
\hline
string		& data	& code	& code	\\
\hline
thread		& data	& data	& data	\\
\hline
\end{tabular}
\end{center}
\caption{\label{eval-act}
Evaluation of objects by type and attribute}
\end{table}

\begin{description}

\item[array: ] An array is an ordered sequence of objects of any type.  The
sequence of objects contained in an array is indexed starting at 0.  References
to existing arrays may be constructed such that a contiguous subsequence is
visible.  The following code creates such an array:

\begin{verbatim}
[0 1 2 3 4]
1 3 getinterval
\end{verbatim}

After the code executes, the array left on the operand stack looks like:

\begin{verbatim}
[1 2 3]
\end{verbatim}

Executable arrays are in effect procedures.  When an array is executed, its
elements are sequentially interpreted.

\item[boolean: ] A boolean can have two values: true or false.

\item[condition: ] A condition is used for thread synchronization.  The standard
operations on a condition are to wait and to signal.

\item[dict: ] A dict (short for dictionary) is a collection of key/value pairs.
Other names for dictionaries include ``associative array'' and ``hash''.  A key
can be of any type, though in most cases, keys are of type name.  A value can
also be of any type.

\item[file: ] A file is a handle to an ordered sequence of bytes with a current
position.  Read and write permissions are set when a file object is created.

When an executable file is executed, it is used as a source of Onyx code.  Data
are sequentially read from the file and interpreted until the end of the file is
reached.

\item[fino: ] A fino (first in, never out) is used as a stack marker when
constructing stacks.

\item[hook: ] The hook type is not used by the core Onyx language.  It can be
used by applications that extend the interpreter as a container object.  Hooks
can be executed, but the results are application dependent.

Each hook has a tag associated with it that can used by C extension code as a
form of type checking.  By default, the tag is a null object.  In most cases, an
application that extends the interpreter using hook objects will set hook tags
to be name objects.

\item[integer: ] An integer is a signed integer in the range $-2^{63}$ to
$2^{63} - 1$.

\item[mark: ] A mark is used as a stack marker for various stack operations.

\item[mutex: ] A mutex is a mutual exclusion lock.  Mutexes cannot be acquired
recursively, and the application must take care to unlock mutexes before
allowing them to be garbage collected (whether during normal program execution
or at program termination).

\item[name: ] A name is a key that uniquely identifies a sequence of characters.
Two name objects that correspond to the same sequence of characters can be
compared for equality with the same approximate cost as comparing two integers
for equality.  Names are typically used as keys in dictionaries.

When an executable name is executed, the topmost value in the dictionary stack
associated with the name is evaluated.

\item[null: ] A null has no significance other than its existence.  When an
executable null is executed, it does nothing.  Executable nulls can be useful as
place holders that can later be replaced with useful code, or for replacing
obsolete code so that the code is no longer executed.

\item[operator: ] An operator is an operation that is built in to the
interpreter.  Operators can be executed.

\item[pmark: ] A pmark is used as a stack marker when creating procedures in
deferred execution mode (i.e. procedures that use the \{\} syntax).  The
application will only encounter pmarks in error conditions, and there is never a
reason for an application to explicitly create a pmark.

\item[real: ] A real is a double precision (64 bit) floating point number.

\item[regex: ] A regex encapsulates a regular expression and associated flags,
which can be used to find substring matches within an input string.

\item[regsub: ] A regsub encapsulates a regular expression, substitution
template, and associated flags, which can be used to do substring substitutions
matches and create an output string from input string.

\item[stack: ] A stack provides LIFO (last in, first out) access to objects that
it contains, as well as some more advanced access methods.  An application can
create, then manipulate stacks in much the same way that the operand stack can
be manipulated.

\item[string: ] A string is an ordered sequence of 8 bit characters.  The bytes
contained in an string are indexed starting at 0.  References to existing
strings may be constructed such that a contiguous subsequence is visible.  The
following code creates such a string:

\begin{verbatim}
`abcde'
1 3 getinterval
\end{verbatim}

After the code executes, the string left on the operand stack looks like:

\begin{verbatim}
`bcd'
\end{verbatim}

When an executable string is executed, its contents are used as a source of Onyx
code.

\item[thread: ] A thread object serves as a handle for operations such as
detaching and joining.

\end{description}

\section{Syntax}
\label{sec:onyx_syntax}
Onyx's syntax is very simple in comparison to most languages.  The scanner and
parser are implemented as a human-understandable finite state machine (nested C
switch statements with a couple of auxiliary variables), which should give the
reader an idea of the simplicity of the language syntax.

CRNL (carriage return, newline) pairs are in all important cases converted to
newlines during scanning.

The characters \#, !, \$, {\twid}, {\lb}, {\rb}, \{, \}, (, ), `, ', {\lt}, and
{\gt} are special.  In most cases, any of the special characters and whitespace
(space, tab, newline, formfeed, null) terminate any preceding token.  All other
characters including non-printing characters are considered regular characters.

A comment starts with a \# character outside of a string context and extends to
the next newline or formfeed.

Procedures are actually executable arrays, but Onyx provides special syntax for
declaring procedures.  Procedures are delimited by \{ and \}, and can be
nested.  Normally, the interpreter executes code as it is scanned, but inside of
procedure declarations, execution is deferred.  Instead of executing a procedure
body as it is encountered, the tokens of the procedure body are pushed onto the
operand stack until the closing \} is encountered, at which time an executable
array is constructed from the tokens in the procedure body and pushed onto the
operand stack.

A partial grammar specification, using BNF notation (where convenient) is as
follows:

\begin{description}
\item[{\lt}program{\gt} ::= ] {\lt}statement{\gt}

\item[{\lt}statement{\gt} ::= ] {\lt}procedure{\gt} {\lt}statement{\gt} {\pipe}
{\lt}object{\gt} {\lt}statement{\gt} {\pipe} $\epsilon$

\item[{\lt}procedure{\gt} ::= ] \{{\lt}statement{\gt}\}

\item[{\lt}object{\gt} ::= ] {\lt}integer{\gt} {\pipe} {\lt}real{\gt} {\pipe}
{\lt}name{\gt} {\pipe} {\lt}string{\gt}

\item[{\lt}integer{\gt} ::= ] {\lt}dec\_integer{\gt} {\pipe}
{\lt}radix\_integer{\gt}

\item[{\lt}real{\gt} ::= ] {\lt}dec\_real{\gt} {\pipe} {\lt}exp\_real{\gt}

\item[{\lt}name{\gt} : ] Any token that cannot be interpreted as a number or a
string is interpreted as an executable name.  There are four syntaxes for names:
executable, evaluatable, literal, and immediately evaluated.  Executable and
evaluatable names are looked up in the dictionary stack and executed (unless
execution is deferred).  Evaluatable names behave the same as executable names,
except when bing processed by the \htmlref{\onyxop{}{bind}{}}{systemdict:bind}
operator.  Literal names are simply pushed onto the operand stack.  Immediately
evaluated names are replaced by their values as defined in the dictionary stack,
even if execution is deferred.  Examples include:
\begin{verbatim}
foo     # executable
4noth3r # executable
!bar    # evaluatable
$biz    # literal
~baz    # immediately evaluated
\end{verbatim}

If the result of an immediately evaluated name is an executable array, the
evaluatable attribute is set for the array so that when the array is
interpreted, it is executed.  This allows immediate evaluation to be
indiscriminately used without concern for whether the result is an executable
array or, say, an executable operator.

\item[{\lt}string{\gt} ::= ] `'-delimited string.  Ticks may
be embedded in the string without escaping them, as long as the unescaped ticks
are balanced.  The following sequences have special meaning when escaped by a
{\bs} character:
	\begin{description}
	\item[` ] ` character.
	\item[' ] ' character.
	\item[{\bs} ] {\bs} character.
	\item[0 ] Nul.
	\item[n ] Newline.
	\item[r ] Carriage return.
	\item[t ] Tab.
	\item[b ] Backspace.
	\item[f ] Formfeed.
	\item[a ] Alarm.
	\item[e ] Escape.
	\item[x{\lb}0-9a-fA-F{\rb}{\lb}0-9a-fA-F{\rb} ] Hex encoding for a byte.
	\item[c{\lb}a-zA-Z{\rb} ] Control character.
	\item[{\bs}n (newline) ] Ignore.
	\item[{\bs}r{\bs}n (carriage return, newline) ] Ignore.
	\end{description}

{\bs} has no special meaning unless followed by a character in the above list.

Examples include:
\begin{verbatim}
`'
`A string.'
`An embedded \n newline.'
`Another embedded 
newline.'
`An ignored \
newline.'
`Balanced ` and ' are allowed.'
`Manually escaped \` tick.'
`Manually escaped \` tick and `balanced unescaped ticks'.'
`An actual \\ backslash.'
`Another actual \ backslash.'
\end{verbatim}

\item[{\lt}dec\_integer{\gt} : ] Signed integer in the range $-2^{63}$ to
$2^{63} - 1$.  The sign is optional.  Examples include:
\begin{verbatim}
0
42
-365
+17
\end{verbatim}

\item[{\lt}radix\_integer{\gt} : ] Signed integer with explicit base between 2
and 36, inclusive, in the range $-2^{63}$ to $2^{63} - 1$.  Integer digits are
composed of decimal numbers and lower or upper case letters.  The sign is
optional.  Examples include:
\begin{verbatim}
2@101
16@ff
16@Ff
16@FF
-10@42
10@42
+10@42
9@18
35@7r3x
35@7R3x
\end{verbatim}

\item[{\lt}dec\_real{\gt} : ] Double precision floating point number in decimal
notation.  At least one decimal digit and a decimal point are required.
Examples include:
\begin{verbatim}
0.
.0
3.
.141
3.141
42.75
+3.50
-5.0
\end{verbatim}

\item[{\lt}exp\_real{\gt} : ] Floating point number in exponential notation.
The format is the same as for {\lt}dec\_real{\gt}, except that an exponent is
appended.  The exponent is composed of an ``e'' or ``E'', an optional sign, and
a base 10 integer that is limited by the precision of the floating point format
(approximately $-308$ to $307$).  Examples include:
\begin{verbatim}
6.022e23
60.22e22
6.022e+23
1.661e-24
1.661E-24
\end{verbatim}

\end{description}

Arrays do not have explicit syntactic support, but the [ and ] operators support
their construction.  Examples of array construction include:
\begin{verbatim}
[]
[0 `A string' `Another string.' true]
[5
42
false]
\end{verbatim}

Dictionaries do not have explicit syntactic support, but the {\lt} and
{\gt} operators support their construction.  Examples of dictionary
construction include:
\begin{verbatim}
<>
<$answer 42 $question `Who knows' $translate {babelfish} >
\end{verbatim}

Stacks do not have explicit syntactic support, but the ( and ) operators support
their construction.  Examples of stack contstruction include:
\begin{verbatim}
()
(1 2 mark `a')
\end{verbatim}

\section{Stacks}

Stacks in Onyx are the core data structure that programs act on.  Stacks store
objects in a last in, first out (LIFO) order.  Onyx includes a number of
operators that manipulate stacks.

Each Onyx thread has four program-visible stacks associated with it:
\begin{description}
\item[Operand stack (ostack): ] Most direct object manipulations are done using
	the operand stack.  Operators use the operand stack for inputs and
	outputs, and code generally uses the operand stack for a place to store
	objects as they are being manipulated.
\item[Dictionary stack (dstack): ] The dictionary stack is used for looking up
	names.  Each thread starts with with four dictionaries on its dictionary
	stack, which are, from top to bottom:
	\begin{itemize}
		\item{userdict}
		\item{globaldict}
		\item{systemdict}
		\item{threaddict}
	\end{itemize}
	The dictionary stack is normally manipulated via the
	\htmlref{\onyxop{}{begin}{}}{systemdict:begin} and
	\htmlref{\onyxop{}{end}{}}{systemdict:end} operators.  The initial
	dictionaries on the dictionary stack should not generally be removed,
	since doing so can cause interpreter crashes.
\item[Execution stack (estack): ] The interpreter uses the execution stack to
	store objects that are being executed.  The application generally does
	not need to explicitly manipulate the execution stack, but its contents
	are accessible, mainly for debugging purposes.
\item[Index stack (istack): ] The interpreter uses the index stack to store
	execution offsets for arrays that are being executed.  There is a one to
	one correspondence of the elements of the execution stack to the
	elements of the index stack, even though the elements of the index stack
	that do not correspond to arrays have no meaning.  The index stack does
	not affect execution, and exists purely to allow useful execution stack
	traces when errors occur.
\end{description}

The application can also create additional stacks and manipulate them in much
the same way as the operand stack can be manipulated.

\section{Standard I/O}
\label{sec:onyx_standard_io}

Onyx provides operators to access the standard I/O file objects:
\htmlref{\onyxop{}{stdin}{}}{systemdict:stdin},
\htmlref{\onyxop{}{stdout}{}}{systemdict:stdout}, and
\htmlref{\onyxop{}{stderr}{}}{systemdict:stderr}.  Under normal circumstances,
these operators are adequate for all standard I/O operations.  However, it may
be desirable to replace these files on a per-thread basis.  This can be
accomplished using \htmlref{\onyxop{}{setstdin}{}}{systemdict:setstdin},
\htmlref{\onyxop{}{setstdout}{}}{systemdict:setstdout}, and
\htmlref{\onyxop{}{setstderr}{}}{systemdict:setstderr}.  Furthermore, the file
objects that are inherited by new threads can be accessed and modified via
\htmlref{\onyxop{}{gstdin}{}}{systemdict:gstdin},
\htmlref{\onyxop{}{gstdout}{}}{systemdict:gstdout},
\htmlref{\onyxop{}{gstderr}{}}{systemdict:gstderr},
\htmlref{\onyxop{}{setgstdin}{}}{systemdict:setgstdin},
\htmlref{\onyxop{}{setgstdout}{}}{systemdict:setgstdout}, and
\htmlref{\onyxop{}{setgstderr}{}}{systemdict:setgstderr}.

\section{Interpreter recursion}

During typical Onyx interpreter initialization, the
\htmlref{\onyxop{}{start}{}}{systemdict:start} operator is executed, which in
turn executes a file object corresponding to stdin.  However, depending on how
the interpreter is invoked, the initial execution stack state may differ.

The interpreter can be recursively invoked.  For example, if the following code
is executed, the \htmlref{\onyxop{}{eval}{}}{systemdict:eval} operator
recursively invokes the interpreter to interpret the string.
\begin{verbatim}
`2 2 add' cvx eval
\end{verbatim}

The depth of the execution stack directly corresponds to the recursion depth of
the interpreter.  Execution stack depth is limited in order to catch unbounded
recursion.

Onyx converts tail calls in order to prevent unbounded execution stack growth
due to tail recursion.  For example, the following code does not cause the
execution stack to grow:

\begin{verbatim}
$foo {foo} def
foo
\end{verbatim}

The following code will result in an execution stack overflow:

\begin{verbatim}
$foo {foo `filler'} def
foo
\end{verbatim}

\section{Error handling}

The error handling mechanisms in Onyx are simple but flexible.  When an error
occurs, \htmlref{\onyxop{}{throw}{}}{systemdict:throw} is called.  An error can
have any name, but only the following error names are generated internally by
Onyx:
\begin{description}
\label{argcheck}
\index{argcheck}
\item[argcheck: ] Incorrect argument value.
\label{estackoverflow}
\index{estackoverflow}
\item[estackoverflow: ] Maximum interpreter recursion was exceeded.
\label{invalidaccess}
\index{invalidaccess}
\item[invalidaccess: ] Permission error.
\label{invalidexit}
\index{invalidexit}
\item[invalidexit: ] The \onyxop{}{exit}{} operator was called outside of any
loop.  This error is generated as a result of catching an exit, so the execution
state for where the error really happened is gone.
\label{invalidfileaccess}
\index{invalidfileaccess}
\item[invalidfileaccess: ] Insufficient file permissions.
\label{ioerror}
\index{ioerror}
\item[ioerror: ] I/O error (read(), write(), etc.).
\label{limitcheck}
\index{limitcheck}
\item[limitcheck: ] Value outside of legal range.
\label{neterror}
\index{neterror}
\item[neterror: ] Network error (refused connection, timeout, unreachable net,
etc.).
\label{rangecheck}
\index{rangecheck}
\item[rangecheck: ] Out of bounds string or array access, or out of bounds
value.
\label{regexerror}
\index{regexerror}
\item[regexerror: ] Regular expression syntax error.
\label{stackunderflow}
\index{stackunderflow}
\item[stackunderflow: ] Not enough objects on stack.
\label{syntaxerror}
\index{syntaxerror}
\item[syntaxerror: ] Scanner syntax error.
\label{typecheck}
\index{typecheck}
\item[typecheck: ] Incorrect argument type.
\label{undefined}
\index{undefined}
\item[undefined: ] Name not defined in any of the dictionaries on dstack.
\label{undefinedfilename}
\index{undefinedfilename}
\item[undefinedfilename: ] Bad filename.
\label{undefinedresult}
\index{undefinedresult}
\item[undefinedresult: ] Attempt to divide by 0.
\label{unmatchedfino}
\index{unmatchedfino}
\item[unmatchedfino: ] No fino on ostack.
\label{unmatchedmark}
\index{unmatchedmark}
\item[unmatchedmark: ] No mark on ostack.
\label{unregistered}
\index{unregistered}
\item[unregistered: ] Non-enumerated error.
\end{description}

The Onyx scanner handles syntax errors specially, in that it pushes an
executable string onto the operand stack that represents the code that caused
the syntax error and records the line and column numbers in currenterror before
invoking \htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

The Onyx scanner also handles immediate name evaluation errors specially, in
that it pushes the name that could not be evaluated onto ostack before invoking
\htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

\section{Threads}

Onyx supports multiple threads of execution by using the operating system's
native threading facilities.  Along with threads comes the need for methods of
synchronization between threads.

\subsection{Implicit synchronization}
\label{sec:onyx_implicit_synchronization}

Implicit synchronization is a mandatory language feature, since objects such as
\htmlref{globaldict}{systemdict:globaldict} are implicitly accessed by the
interpreter, which makes it impossible to require the user to explicitly handle
all synchronization.  Onyx provides optional implicit synchronization
capabilities for composite objects on an object by object basis.  Each thread
has a setting which can be accessed via
\htmlref{\onyxop{}{currentlocking}{}}{systemdict:currentlocking} (initially set
to false) and set via \htmlref{\onyxop{}{setlocking}{}}{systemdict:setlocking}.
If implicit locking is active, then new objects will be created such that simple
accesses are synchronized.

Implicit synchronization can be a source of deadlock, so care must be taken when
accessing implicitly locked objects.  For example, if two threads copy two
implicitly locked strings to the other string, deadlock can result.

\begin{verbatim}
# Initialization.
$A `aaaaaa'
$B `bbbbbb'

...

# In thread A:
A B copy

...

# In thread B:
B A copy
\end{verbatim}

The following are descriptions of the implicit locking semantics for each type
of composite object:
\begin{description}
\item[array: ] Array copying is protected.  Array element modifications are
protected, but element reads are not protected.
\item[condition: ] No implicit locking is done for conditions.
\item[dict: ] All dict operations are protected.
\item[file: ] All file operations are protected.  There are no potential
deadlocks due to implicit file locking.
\item[hook: ] No implicit locking is done for hooks.
\item[mutex: ] No implicit locking is done for mutexes.
\item[stack: ] All stack operations are protected.  There are no potential
deadlocks due to implicit stack locking.  However, there are races in stack
copying, such that the results of copying a stack that is concurrently being
modified are unpredictable.  In addition, removing an object that is being
concurrently accessed from a stack is unsafe.
\item[string: ] String copying is protected.  Character access is protected by
many operators, but string copying is the only potential cause of deadlock for
string access.
\item[thread: ]  Implicit locking is not done for thread operations, since other
synchronization is adequate to protect thread objects.
\end{description}

\subsection{Explicit synchronization}

Onyx includes a foundation of mutexes and condition variables, with which all
other synchronization primitives can be constructed.

\section{Memory management}
Onyx programs do not need to track memory allocations, since memory reclamation
is done implicitly via automatic garbage collection.  Onyx uses an atomic mark
and sweep garbage collector.

The atomic nature of garbage collection may sound worrisome with regard to
performance, but in fact there are tangible benefits and no significant negative
impacts for most applications.  Total throughput is improved, since minimal
locking is necessary.  Concurrent garbage collection would impose a significant
locking overhead.

On the down side, atomic garbage collection cannot make strong real-time
guarantees.  However, the garbage collector is very efficient, and for typical
applications, garbage collection delays are measured in microseconds up to tens
of milliseconds on current hardware as of the year 2000.  For interactive
applications, anything under about 100 milliseconds is undetectable by the user,
so under normal circumstances the user will not notice that garbage collection
is happening.

There are three parameters that can be used to control garbage collection:
\begin{enumerate}
\item{The garbage collector can be turned off for situations where many objects
are being created over a short period of time.}
\item{The garbage collector runs whenever a certain number of bytes of memory
have been allocated since the last collection.  This threshold can be changed or
disabled.}
\item{If no composite objects have been created for an extended period of time
(seconds), the garbage collector will run if any composite objects have been
allocated since the last collection.  This idle timeout period can be changed or
disabled.}
\end{enumerate}

There is one situation in which it is possible for garbage to never be
collected, despite the garbage collector being properly configured.  Suppose
that a program creates some objects, the garbage collector runs, then the
program enters a code path that clobbers object references, such that the
objects could be collected, but no new objects are allocated.  In such a
situation, neither the allocation inactivity timer (period), nor the object
allocation threshold will trigger a collection, and garbage will remain
uncollected.  In practice this situation is unlikely, and is not a significant
problem since the program size is not growing.

Garbage collection is controlled via the \htmlref{gcdict}{systemdict:gcdict}
dictionary, which is described in Section~\ref{sec:gcdict}.

\section{Regular expressions}
\label{sec:onyx_regular_expressions}

Regular expression support is provided by the PCRE library package, which is
open source software, written by Philip Hazel, and copyright by the University
of Cambridge, England.  PCRE stands for ``Perl-compatible regular
expressions''.  This manual only documents how Onyx interfaces with PCRE.  For
more information about how PCRE's regular expressions work, see the following:

\begin{itemize}
\item{The pcre(3) manual page.}
\item{The official PCRE website: \htmlurl{http://www.pcre.org/}.}
\item{The official PCRE download site:
\htmlurl{ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/}.}
\end{itemize}

For general information about Perl regular expressions, the following are
recommended:

\begin{itemize}
\item{Perl 5.6.1 regular expression documentation:
\htmlurl{http://www.perldoc.com/perl5.6.1/pod/perlre.html}.}
\item{\underline{Mastering Regular Expressions, 2nd Ed.}, by Jeffrey
E. F. Friedl.  ISBN 0-596-00289-0.}
\item{\underline{Perl 5 Pocket Reference, 3rd Ed.}, by Johan Vromans.  ISBN
0-596-00032-4.}
\item{\underline{Programming Perl, 3rd Ed.}, by Larry Wall, Tom Christiansen,
and Jon Orwant.  ISBN 0-596-00027-8.}
\end{itemize}

There are two special Onyx object types that support regular expressions: regex
and regsub.  Objects of these types are created via the
\htmlref{\onyxop{}{regex}{}}{systemdict:regex} and
\htmlref{\onyxop{}{regsub}{}}{systemdict:regsub} operators, respectively.  The
\htmlref{\onyxop{}{match}{}}{systemdict:match} operator applies a regular
expression to an input string, and the
\htmlref{\onyxop{}{offsets}{}}{systemdict:offsets} operator returns the offsets
of the matches found within the input string.  The
\htmlref{\onyxop{}{subst}{}}{systemdict:subst} operator finds regular expression
matches within an input string and applies a substitution template to the
matches, thereby creating an output string.  See Section~\ref{sec:systemdict}
for detailed documentation on the above-mentioned operators.  The rest of this
section documents the syntax and semantics of Onyx's flavor of regular
expressions.

Regular expressions are written as strings in Onyx, so all of the standard
special sequences within strings are interpreted directly by the Onyx scanner.
Note that the {\bs} character is only special within strings if it is followed
by a special sequence.  This allows regular expressions to seamlessly extend the
set of special sequences within strings while maintaining a reasonably
consistent syntax.

The following sequences have special meaning within strings that specify
substitution templates:

\begin{longtable}{\rxtableformat{5.50}}
\caption{Substitution template special characters} \\
\hline
Sequence & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Sequence & Description \\
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
{\tt {\bs}0} & Refer to the entire matched expression. \\
\hline
{\tt {\bs}1..{\bs}9} & Refer to captured expressions 1 through 9. \\
\end{longtable}

\section{Dictionary reference}

All operators built in to Onyx have corresponding names that are composed
entirely of lower case letters (with the exception of syntax-supporting
operators like {\lb}).  In order to avoid any possibility of namespace
collisions with names defined by current and future versions of Onyx, use at
least one character that is not a lower case letter in names (for example,
capital letters, numbers, underscore, etc.).  In practice, namespace collisions
usually aren't a problem, even if they happen, since the only effect is that the
program-defined definition shadows the built in definition during name lookups.

\subsection{currenterror}
\label{sec:currenterror}
\index{currenterror@\onyxop{}{currenterror}{}}

Each thread has its own currenterror dictionary, which is used by the error
handling machinery to store error state.

\begin{longtable}{\optableformat{4.10}}
\caption{currenterror summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{--}
	{{\bf \htmlref{newerror}{currenterror:newerror}}}
	{boolean}
	{Set to true during error handling.}
\hline
\optableent
	{--}
	{{\bf \htmlref{errorname}{currenterror:errorname}}}
	{name}
	{Name of most recent error.}
\hline
\optableent
	{--}
	{{\bf \htmlref{line}{currenterror:line}}}
	{number}
	{Get line number of syntax error.}
\hline
\optableent
	{--}
	{{\bf \htmlref{column}{currenterror:column}}}
	{number}
	{Get column number of syntax error.}
\hline
\optableent
	{--}
	{{\bf \htmlref{ostack}{currenterror:ostack}}}
	{stack}
	{ostack snapshot.}
\hline
\optableent
	{--}
	{{\bf \htmlref{dstack}{currenterror:dstack}}}
	{stack}
	{dstack snaphot.}
\hline
\optableent
	{--}
	{{\bf \htmlref{estack}{currenterror:estack}}}
	{stack}
	{estack snapshot.}
\hline
\optableent
	{--}
	{{\bf \htmlref{istack}{currenterror:istack}}}
	{stack}
	{istack snapshot.}
\end{longtable}

\begin{description}
\label{currenterror:column}
\index{column@\onyxop{}{column}{}}
\item[{\onyxop{--}{column}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			Column number, valid only if the error was a
			syntaxerror.  Column numbering starts at 0.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the column number that a syntaxerror occurred on.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2 3}' cvx eval
At line 1, column 5: Error $syntaxerror
ostack: (1 2 3 `}')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..3):
0:      `1 2 3}'
1:      --eval--
2:      -file-
3:      --start--
onyx:5> currenterror $column get 1 sprint
5
onyx:5>
		\end{verbatim}
	\end{description}
\label{currenterror:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A dstack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is a dstack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin dstack end 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:errorname}
\index{errorname@\onyxop{}{errorname}{}}
\item[{\onyxop{--}{errorname}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			Name of the most recent error.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the name of the most recent error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin errorname end 1 sprint
$undefined
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An estack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an estack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin estack end 1 sprint
(--start-- -file- x)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An istack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an istack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin istack end 1 sprint
(0 0 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:newerror}
\index{newerror@\onyxop{}{newerror}{}}
\item[{\onyxop{--}{newerror}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			False if there has been no error since the last time
			newerror was reset; true otherwise.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a boolean that represents whether there has been an error
		since the last time newerror was set to false (as during
		interpreter initialization).  It is the application's
		responsibility to reset newerror after each error if it expects
		the value to be useful across multiple errors.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currenterror begin
onyx:0> newerror 1 sprint
false
onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> newerror 1 sprint
true
onyx:1> $newerror false def
onyx:1> newerror 1 sprint
false
onyx:1> resume
onyx:1> y
Error $undefined
ostack: (x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      y
1:      -file-
2:      --start--
onyx:2> newerror 1 sprint
true
onyx:2>
		\end{verbatim}
	\end{description}
\label{currenterror:line}
\index{line@\onyxop{}{line}{}}
\item[{\onyxop{--}{line}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			Line number, valid only if the error was a syntaxerror.
			Line numbering starts at 1.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the line number that a syntaxerror occurred on.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2 3}' cvx eval
At line 1, column 5: Error $syntaxerror
ostack: (1 2 3 `}')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..3):
0:      `1 2 3}'
1:      --eval--
2:      -file-
3:      --start--
onyx:5> currenterror $line get 1 sprint
1
onyx:5>
		\end{verbatim}
	\end{description}
\label{currenterror:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An ostack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an ostack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin ostack end 1 sprint
()
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{envdict}
\label{sec:envdict}
\index{envdict@\onyxop{}{envdict}{}}

The envdict dictionary contains keys of type name and values of type string that
correspond to the environment passed into the program.  All threads share the
same envdict, which is implicitly locked.  Modifications to envdict should be
made via the \htmlref{\onyxop{}{setenv}{}}{systemdict:setenv} and
\htmlref{\onyxop{}{unsetenv}{}}{systemdict:unsetenv} operators.  If envdict is
modified directly, the changes will not be visible to programs such as
\binname{ps}.

\subsection{errordict}
\label{sec:errordict}
\index{errordict@\onyxop{}{errordict}{}}

Each thread has its own errordict, which is used by default by the error
handling machinery.

\begin{longtable}{\optableformat{4.10}}
\caption{errordict summary} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{--}
	{{\bf \htmlref{handleerror}{errordict:handleerror}}}
	{--}
	{Print a state dump.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stop}{errordict:stop}}}
	{--}
	{Last operation during error handling.}
\end{longtable}

\begin{description}
\label{handleerror}
\label{errordict:handleerror}
\index{handleerror@\onyxop{}{handleerror}{}}
\item[{\onyxop{--}{handleerror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		Under normal conditions, no errors occur.  However, it is
		possible for the application to corrupt the error handling
		machinery to the point that an error will occur.  If that
		happens, the result is possible infinite recursion, and program
		crashes are a real possibility.
	\item[Description: ]
		Print a dump of the most recent error recorded in the
		currenterror dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {true {true 1 sprint x y} if} eval
true
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1> errordict begin handleerror end
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1>
		\end{verbatim}
	\end{description}
\label{errordict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		This is called as the very last operation when an error occurs.
		Initially, its value is the same as that for the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operator in
		systemdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> errordict begin
onyx:0> $stop {`Custom stop\n' print flush quit} def
onyx:0> x
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
Custom stop
		\end{verbatim}
	\end{description}
\end{description}

\subsection{gcdict}
\label{sec:gcdict}
\index{gcdict@\onyxop{}{gcdict}{}}

The gcdict dictionary provides garbage collection control and status
capabilities.

\begin{longtable}{\optableformat{4.10}}
\caption{gcdict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{2}{|l|}{Control operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{collect}{gcdict:collect}}}
	{--}
	{Force a garbage collection.}
\hline
\optableent
	{boolean}
	{{\bf \htmlref{setactive}{gcdict:setactive}}}
	{--}
	{Set whether the garbage collector is active.}
\hline
\optableent
	{seconds}
	{{\bf \htmlref{setperiod}{gcdict:setperiod}}}
	{--}
	{Set the inactivity period before the garbage collector will run.}
\hline
\optableent
	{count}
	{{\bf \htmlref{setthreshold}{gcdict:setthreshold}}}
	{--}
	{Set the number of bytes of memory allocation that will trigger a garbage collection.}
\hline \hline
\multicolumn{2}{|l|}{State and statistics operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{active}{gcdict:active}}}
	{boolean}
	{Get whether the garbage collector is active.}
\hline
\optableent
	{--}
	{{\bf \htmlref{period}{gcdict:period}}}
	{seconds}
	{Get the inactivity period before the garbage collector will run.}
\hline
\optableent
	{--}
	{{\bf \htmlref{threshold}{gcdict:threshold}}}
	{count}
	{Get the number of bytes of memory allocation that will trigger a garbage collection.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stats}{gcdict:stats}}}
	{array}
	{Get garbage collection statistics.}
\end{longtable}

\begin{description}
\label{gcdict:active}
\index{active@\onyxop{}{active}{}}
\item[{\onyxop{--}{active}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true, the garbage collector is active; otherwise it
			is not active.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get whether the garbage collector is active.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin active end 1 sprint
false
		\end{verbatim}
	\end{description}
\label{gcdict:collect}
\index{collect@\onyxop{}{collect}{}}
\item[{\onyxop{--}{collect}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Force a garbage collection.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin collect end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:period}
\index{period@\onyxop{}{period}{}}
\item[{\onyxop{--}{period}{seconds}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin period end 1 sprint
60
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setactive}
\index{setactive@\onyxop{}{setactive}{}}
\item[{\onyxop{boolean}{setactive}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true (initial setting), activate the garbage
			collector; otherwise deactivate the garbage collector.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set whether the garbage collector is active.  This setting takes
		effect asynchronously, so it is possible for the garbage
		collector to run even after it has been deactivated.  This
		setting overrides the allocation inactivity period and
		allocation threshold settings, so that if this setting is set to
		false, the other settings have no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin false setactive end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setperiod}
\index{setperiod@\onyxop{}{setperiod}{}}
\item[{\onyxop{seconds}{setperiod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 60 setperiod end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setthreshold}
\index{setthreshold@\onyxop{}{setthreshold}{}}
\item[{\onyxop{count}{setthreshold}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of bytes of memory allocation since the last
			garbage collection that will trigger a garbage
			collection.  0 is treated specially to mean infinity.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the number of bytes of memory allocation since the last
		garbage collection that will trigger a garbage collection.  This
		setting is disjoint from the inactivity period setting, and does
		not prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 40000 setthreshold end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:stats}
\index{stats@\onyxop{}{stats}{}}
\item[{\onyxop{--}{stats}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array with the format {\lb}collections count
			{\lb}ccount cmark csweep{\rb} {\lb}mcount mmark
			msweep{\rb} {\lb}scount smark ssweep{\rb}{\rb}, where
			the fields have the following meanings:
			\begin{description}%\item[]
			\item[collections: ]
				Total number of collections the garbage
				collector has performed.
			\item[count: ]
				Current number of bytes of memory allocated.
			\item[ccount: ]
				Number of bytes of memory allocated as of the
				end of the most recent garbage collection.
			\item[cmark: ]
				Number of microseconds taken by the most recent
				garbage collection mark phase.
			\item[csweep: ]
				Number of microseconds taken by the most recent
				garbage collection sweep phase.
			\item[mcount: ]
				Largest number of bytes of memory ever allocated
				at any point in time.
			\item[mmark: ]
				Maximum number of microseconds taken by any
				garbage collection mark phase.
			\item[msweep: ]
				Number of microseconds taken by any garbage
				collection sweep phase.
			\item[scount: ]
				Total number of bytes of memory ever allocated.
			\item[smark: ]
				Total number of microseconds taken by all
				garbage collection mark phases.
			\item[ssweep: ]
				Total number of microseconds taken by all
				garbage collection sweep phases.
			\end{description}
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get statistics about the garbage collector.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin
onyx:0> stats 2 sprint
[23 72673 [72268 754 3467] [4752223 930 36492] [51057886 17448 136807]]
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:threshold}
\index{threshold@\onyxop{}{threshold}{}}
\item[{\onyxop{--}{threshold}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of bytes of memory allocation since the last
			garbage collection that will trigger a garbage
			collection.  0 is treated specially to mean infinity.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of bytes of memory allocation since the last
		garbage collection that will trigger a garbage collection.  This
		setting is disjoint from the inactivity period setting, and does
		not prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin threshold end 1 sprint
65536
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{globaldict}
\label{sec:globaldict}
\index{globaldict@\onyxop{}{globaldict}{}}

All threads share the same globaldict, which is meant as a repository for
globally shared objects.  globaldict is empty when the Onyx interpreter is
initialized, and is implicitly locked.

\subsection{onyxdict}
\label{sec:onyxdict}
\index{onyxdict@\onyxop{}{onyxdict}{}}

Various portions of Onyx use the onyxdict dictionary for storage of
miscellaneous objects that normally should not be part of the namespace visible
to dstack searches.

\begin{longtable}{\optableformat{4.10}}
\caption{onyxdict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{--}
	{{\bf \htmlref{mpath\_post}{onyxdict:mpath_post}}}
	{array}
	{Get path searched by \htmlref{mrequire}{systemdict:mrequire}.}
\hline
\optableent
	{--}
	{{\bf \htmlref{mpath\_pre}{onyxdict:mpath_pre}}}
	{array}
	{Get path searched by \htmlref{mrequire}{systemdict:mrequire}.}
\hline
\optableent
	{--}
	{{\bf \htmlref{rpath\_post}{onyxdict:rpath_post}}}
	{array}
	{Get path searched by \htmlref{require}{systemdict:require}.}
\hline
\optableent
	{--}
	{{\bf \htmlref{rpath\_pre}{onyxdict:rpath_pre}}}
	{array}
	{Get path searched by \htmlref{require}{systemdict:require}.}
\end{longtable}

\begin{description}
\label{onyxdict:mpath_post}
\index{mpath_post@\onyxop{}{mpath\_post}{}}
\item[{\onyxop{--}{mpath\_post}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{mrequire}{systemdict:mrequire} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict $mpath_post get 1 sprint
[`/usr/local/share/onyx-3.0.0/nxm']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:mpath_pre}
\index{mpath_pre@\onyxop{}{mpath\_pre}{}}
\item[{\onyxop{--}{mpath\_pre}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{mrequire}{systemdict:mrequire} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict $mpath_pre get 1 sprint
[`' `.']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:rpath_post}
\index{rpath_post@\onyxop{}{rpath\_post}{}}
\item[{\onyxop{--}{rpath\_post}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{require}{systemdict:require} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict $rpath_post get 1 sprint
[`/usr/local/share/onyx-3.0.0/nx']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:rpath_pre}
\index{rpath_pre@\onyxop{}{rpath\_pre}{}}
\item[{\onyxop{--}{rpath\_pre}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{require}{systemdict:require} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict $rpath_pre get 1 sprint
[`' `.']
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{outputsdict}
\label{sec:outputsdict}
\index{outputsdict@\onyxop{}{outputsdict}{}}

The outputsdict dictionary is primarily used to support
\htmlref{\onyxop{}{outputs}{}}{systemdict:outputs}, but its contents may be of
use to an application that wishes to extend or modify formatted printing.

There is an entry in outputsdict for each Onyx type.  Each entry renders objects
that correspond to its name using optional flags stored in a dictionary.  The
following flags are supported for all types:
\begin{description}
\item[{\tt \$n}: ]
	Maximum length, in bytes.  Default: disabled.
\item[{\tt \$w}: ]
	Minimum length, in bytes.  Default: disabled.
\item[{\tt \$j}: ]
	Justification.  Legal values:
	\begin{description}
	\item[{\tt \$l}: ]
		Left.
	\item[{\tt \$c}: ]
		Center.
	\item[{\tt \$r}: ]
		Right (default).
	\end{description}
\item[{\tt \$p}: ]
	Padding character.  Default: {\tt ` '}.
\item[{\tt \$r}: ]
	Syntactic rendering recursion depth.  Default: 1.
\end{description}

The following additional flags are supported for integers:
\begin{description}
\item[{\tt \$b}: ]
	Base, from 2 to 36.  Default: 10.
\item[{\tt \$s}: ]
	Sign.  Legal values:
	\begin{description}
	\item[{\tt \$-}: ]
		Only print sign if output is negative (default).
	\item[{\tt \$+}: ]
		Always print sign.
	\end{description}
\end{description}

The following additional flags are supported for reals:
\begin{description}
\item[{\tt \$d}: ]
	Digits of precision past decimal point.  Default: 6.
\item[{\tt \$e}: ]
	Exponential notation, if true.  Default: false.
\end{description}

\begin{longtable}{\optableformat{4.10}}
\caption{outputsdict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{array flags}
	{{\bf \htmlref{arraytype}{outputsdict:arraytype}}}
	{string}
	{Create formatted string from array.}
\hline
\optableent
	{boolean flags}
	{{\bf \htmlref{booleantype}{outputsdict:booleantype}}}
	{string}
	{Create formatted string from boolean.}
\hline
\optableent
	{condition flags}
	{{\bf \htmlref{conditiontype}{outputsdict:conditiontype}}}
	{string}
	{Create formatted string from condition.}
\hline
\optableent
	{dict flags}
	{{\bf \htmlref{dicttype}{outputsdict:dicttype}}}
	{string}
	{Create formatted string from dict.}
\hline
\optableent
	{file flags}
	{{\bf \htmlref{filetype}{outputsdict:filetype}}}
	{string}
	{Create formatted string from file.}
\hline
\optableent
	{fino flags}
	{{\bf \htmlref{finotype}{outputsdict:finotype}}}
	{string}
	{Create formatted string from fino.}
\hline
\optableent
	{hook flags}
	{{\bf \htmlref{hooktype}{outputsdict:hooktype}}}
	{string}
	{Create formatted string from hook.}
\hline
\optableent
	{integer flags}
	{{\bf \htmlref{integertype}{outputsdict:integertype}}}
	{string}
	{Create formatted string from integer.}
\hline
\optableent
	{mark flags}
	{{\bf \htmlref{marktype}{outputsdict:marktype}}}
	{string}
	{Create formatted string from mark.}
\hline
\optableent
	{mutex flags}
	{{\bf \htmlref{mutextype}{outputsdict:mutextype}}}
	{string}
	{Create formatted string from mutex.}
\hline
\optableent
	{name flags}
	{{\bf \htmlref{nametype}{outputsdict:nametype}}}
	{string}
	{Create formatted string from name.}
\hline
\optableent
	{null flags}
	{{\bf \htmlref{nulltype}{outputsdict:nulltype}}}
	{string}
	{Create formatted string from null.}
\hline
\optableent
	{operator flags}
	{{\bf \htmlref{operatortype}{outputsdict:operatortype}}}
	{string}
	{Create formatted string from operator.}
\hline
\optableent
	{pmark flags}
	{{\bf \htmlref{pmarktype}{outputsdict:pmarktype}}}
	{string}
	{Create formatted string from pmark.}
\hline
\optableent
	{real flags}
	{{\bf \htmlref{realtype}{outputsdict:realtype}}}
	{string}
	{Create formatted string from real.}
\hline
\optableent
	{regex flags}
	{{\bf \htmlref{regextype}{outputsdict:regextype}}}
	{string}
	{Create formatted string from regex.}
\hline
\optableent
	{regsub flags}
	{{\bf \htmlref{regsubtype}{outputsdict:regsubtype}}}
	{string}
	{Create formatted string from regsub.}
\hline
\optableent
	{stack flags}
	{{\bf \htmlref{stacktype}{outputsdict:stacktype}}}
	{string}
	{Create formatted string from stack.}
\hline
\optableent
	{string flags}
	{{\bf \htmlref{stringtype}{outputsdict:stringtype}}}
	{string}
	{Create formatted string from string.}
\hline
\optableent
	{thread flags}
	{{\bf \htmlref{threadtype}{outputsdict:threadtype}}}
	{string}
	{Create formatted string from thread.}
\end{longtable}

\begin{description}
\label{outputsdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array flags}{arraytype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{array}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{array}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup <$w 9 $p `_' $r 0> arraytype print `\n' print flush
__-array-
onyx:1> dup <$w 9 $p `_' $r 1> arraytype print `\n' print flush
[1 -array- 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{outputsdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean flags}{booleantype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{boolean}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> false
onyx:1> dup <$n 3> booleantype print `\n' print flush
fal
onyx:1> dup <$n 7> booleantype print `\n' print flush
false
onyx:1>
		\end{verbatim}
	\end{description}
\label{outputsdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition flags}{conditiontype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{condition}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{condition}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> condition
onyx:1> <$w 15 $p `_' $j $c> booleantype print `\n' print flush
__-condition-__
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict flags}{dicttype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{dict}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> <$foo `foo'> <$w 30 $p `.' $j $r> dicttype print `\n' print flush
..................<$foo `foo'>
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file flags}{filetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> stdin
onyx:1> <$w 30 $p `.' $j $c> filetype print `\n' print flush
............-file-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino flags}{finotype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{fino}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{fino}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> (
onyx:1> <$w 30 $p `.' $j $c> finotype print `\n' print flush
............-fino-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:hooktype}
\index{hooktype@\onyxop{}{hooktype}{}}
\item[{\onyxop{hook flags}{hooktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{hook}.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a hook object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhook exists that
		creates a hook with a tag that is the name ``tagged''.
		\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> taggedhook
onyx:1> <$w 30 $p `.' $j $l hooktype print `\n' print flush
=tagged=......................
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer flags}{integertype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{integer}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{integer}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> 42 <$w 6 $p `_' $j $c $s $-> integertype print `\n' print flush
__42__
onyx:0> 42 <$w 6 $p `_' $j $c $s $+> integertype print `\n' print flush
_+42__
onyx:0> `0x' print 42 <$w 6 $p `0' $b 16> integertype print `\n' print flush
0x00002a
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark flags}{marktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{mark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> mark
onyx:1> <$w 30 $p `.' $j $c> marktype print `\n' print flush
............-mark-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex flags}{mutextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{mutex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> mutex
onyx:1> <$w 30 $p `.' $j $c> mutextype print `\n' print flush
...........-mutex-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name flags}{nametype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{name}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{name}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> $foo
onyx:1> <$w 30 $p `.' $j $c> nametype print `\n' print flush
.............$foo.............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null flags}{nulltype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{null}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{null}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> null
onyx:1> <$w 30 $p `.' $j $c> nulltype print `\n' print flush
.............null.............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator flags}{operatortype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{operator}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{operator}.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> ~realtime
onyx:1> <$w 30 $p `.' $j $c> operatortype print `\n' print flush
.........--realtime--.........
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark flags}{pmarktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{pmark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{pmark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> { ~x
Error $undefined
ostack: (-pmark- $x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> <$w 30 $p `.' $j $c> pmarktype print `\n' print flush
...........-pmark-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:realtype}
\index{realtype@\onyxop{}{realtype}{}}
\item[{\onyxop{real flags}{realtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{real}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{real}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> 6.022e23 <$d 4> realtype print `\n' print flush
602200000000000027262976.0000
onyx:0> 6.022e23 <$d 4 $e true> realtype print `\n' print flush
6.0220e+23
onyx:0> 6.022e23 <$d 0 $e true> realtype print `\n' print flush
6e+23
onyx:0> 6.022e23 <$d 4 $w 40 $p `0'> realtype print `\n' print flush
00000000000602200000000000027262976.0000
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:regextype}
\index{regextype@\onyxop{}{regextype}{}}
\item[{\onyxop{regex flags}{regextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regex: ]
			A regex object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{regex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{regex}.
	\item[Example(s): ]\begin{verbatim}

XXX
		\end{verbatim}
	\end{description}
\label{outputsdict:regsubtype}
\index{regsubtype@\onyxop{}{regsubtype}{}}
\item[{\onyxop{regsub flags}{regsubtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regsub: ]
			A regsub object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{regsub}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{regsub}.
	\item[Example(s): ]\begin{verbatim}

XXX
		\end{verbatim}
	\end{description}
\label{outputsdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack flags}{stacktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup <$w 9 $p `_' $r 0> stacktype print `\n' print flush
__-stack-
onyx:1> <$w 9 $p `_' $r 1> stacktype print `\n' print flush
(1 -stack- 4)
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string flags}{stringtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> `A string'
onyx:1> <$w 30 $p `.' $j $c> stringtype print `\n' print flush
...........A string...........
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread flags}{threadtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> () {} thread
onyx:1> <$w 30 $p `.' $j $c> threadtype print `\n' print flush
...........-thread-...........
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{sprintsdict}
\label{sec:sprintsdict}
\index{sprintsdict@\onyxop{}{sprintsdict}{}}

The sprintsdict dictionary is primarily used to support
\htmlref{\onyxop{}{sprints}{}}{systemdict:sprints}, but its contents may be of
use to an application that wishes to extend or modify syntactical printing.

There is an entry in sprintsdict for each Onyx type.  If there is a
syntactically valid representation for an object and the recursion depth is
greater than 0, the corresponding operator creates a string that syntactically
represents the object.  Otherwise, a string with a non-syntictical
representation of the object is created, except for booleans, integers, names,
nulls, reals, and strings, for which the results are always syntactical.  If the
recursion depth is greater than 0, the operators will recursively convert any
contained objects.

The implementation of \htmlref{\onyxop{}{sprints}{}}{systemdict:sprints} is
useful in illustrating a useful method of doing type-dependent operations:

\begin{verbatim}
$sprints {
        1 idup type $sprintsdict load exch get eval
} def
\end{verbatim}

\begin{longtable}{\optableformat{4.10}}
\caption{sprintsdict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{array depth}
	{{\bf \htmlref{arraytype}{sprintsdict:arraytype}}}
	{string}
	{Create syntactical string from array.}
\hline
\optableent
	{boolean depth}
	{{\bf \htmlref{booleantype}{sprintsdict:booleantype}}}
	{string}
	{Create syntactical string from boolean.}
\hline
\optableent
	{condition depth}
	{{\bf \htmlref{conditiontype}{sprintsdict:conditiontype}}}
	{string}
	{Create syntactical string from condition.}
\hline
\optableent
	{dict depth}
	{{\bf \htmlref{dicttype}{sprintsdict:dicttype}}}
	{string}
	{Create syntactical string from dict.}
\hline
\optableent
	{file depth}
	{{\bf \htmlref{filetype}{sprintsdict:filetype}}}
	{string}
	{Create syntactical string from file.}
\hline
\optableent
	{fino depth}
	{{\bf \htmlref{finotype}{sprintsdict:finotype}}}
	{string}
	{Create syntactical string from fino.}
\hline
\optableent
	{hook depth}
	{{\bf \htmlref{hooktype}{sprintsdict:hooktype}}}
	{string}
	{Create syntactical string from hook.}
\hline
\optableent
	{integer depth}
	{{\bf \htmlref{integertype}{sprintsdict:integertype}}}
	{string}
	{Create syntactical string from integer.}
\hline
\optableent
	{mark depth}
	{{\bf \htmlref{marktype}{sprintsdict:marktype}}}
	{string}
	{Create syntactical string from mark.}
\hline
\optableent
	{mutex depth}
	{{\bf \htmlref{mutextype}{sprintsdict:mutextype}}}
	{string}
	{Create syntactical string from mutex.}
\hline
\optableent
	{name depth}
	{{\bf \htmlref{nametype}{sprintsdict:nametype}}}
	{string}
	{Create syntactical string from name.}
\hline
\optableent
	{null depth}
	{{\bf \htmlref{nulltype}{sprintsdict:nulltype}}}
	{string}
	{Create syntactical string from null.}
\hline
\optableent
	{operator depth}
	{{\bf \htmlref{operatortype}{sprintsdict:operatortype}}}
	{string}
	{Create syntactical string from operator.}
\hline
\optableent
	{pmark depth}
	{{\bf \htmlref{pmarktype}{sprintsdict:pmarktype}}}
	{string}
	{Create syntactical string from pmark.}
\hline
\optableent
	{real depth}
	{{\bf \htmlref{realtype}{sprintsdict:realtype}}}
	{string}
	{Create syntactical string from real.}
\hline
\optableent
	{regex depth}
	{{\bf \htmlref{regextype}{sprintsdict:regextype}}}
	{string}
	{Create syntactical string from regex.}
\hline
\optableent
	{regsub depth}
	{{\bf \htmlref{regsubtype}{sprintsdict:regsubtype}}}
	{string}
	{Create syntactical string from regsub.}
\hline
\optableent
	{stack depth}
	{{\bf \htmlref{stacktype}{sprintsdict:stacktype}}}
	{string}
	{Create syntactical string from stack.}
\hline
\optableent
	{string depth}
	{{\bf \htmlref{stringtype}{sprintsdict:stringtype}}}
	{string}
	{Create syntactical string from string.}
\hline
\optableent
	{thread depth}
	{{\bf \htmlref{threadtype}{sprintsdict:threadtype}}}
	{string}
	{Create syntactical string from thread.}
\end{longtable}

\begin{description}
\label{sprintsdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array depth}{arraytype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{array}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{array}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup 0 arraytype print `\n' print flush
-array-
onyx:1> dup 1 arraytype print `\n' print flush
[1 -array- 4]
onyx:1> dup 2 arraytype print `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean depth}{booleantype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{boolean}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> true
onyx:1> dup 0 booleantype print `\n' print flush
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition depth}{conditiontype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{condition}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{condition}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> condition
onyx:1> dup 0 conditiontype print `\n' print flush
-condition-
onyx:1> dup 1 conditiontype print `\n' print flush
-condition-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict depth}{dicttype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{dict}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> <$a `a' $subdict <$b `b'>>
onyx:1> dup 0 dicttype print `\n' print flush
-dict-
onyx:1> dup 1 dicttype print `\n' print flush
<$subdict -dict- $a `a'>
onyx:1> dup 2 dicttype print `\n' print flush
<$subdict <$b `b'> $a `a'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file depth}{filetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> stdout
onyx:1> dup 0 filetype print `\n' print flush
-file-
onyx:1> dup 1 filetype print `\n' print flush
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino depth}{finotype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{fino}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{fino}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (
onyx:1> dup 0 finotype print `\n' print flush
-fino-
onyx:1> dup 1 finotype print `\n' print flush
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:hooktype}
\index{hooktype@\onyxop{}{hooktype}{}}
\item[{\onyxop{hook depth}{hooktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{hook}.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a hook object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhook exists that
		creates a hook with a tag that is the name ``tagged'', and that
		an operator named untaggedhook exists that creates an untagged
		hook.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> taggedhook
onyx:1> dup 0 hooktype print `\n' print flush
=tagged=
onyx:1> 1 hooktype print `\n' print flush
=tagged=
onyx:0> untaggedhook
onyx:1> dup 0 hooktype print `\n' print flush
-hook-
onyx:1> 1 hooktype print `\n' print flush
-hook-
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer depth}{integertype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{integer}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{integer}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42
onyx:1> dup 0 integertype print `\n' print flush
42
onyx:1> dup 1 integertype print `\n' print flush
42
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark depth}{marktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mark
onyx:1> dup 0 marktype print `\n' print flush
-mark-
onyx:1> dup 1 marktype print `\n' print flush
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex depth}{mutextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mutex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mutex
onyx:1> dup 0 mutextype print `\n' print flush
-mutex-
onyx:1> dup 1 mutextype print `\n' print flush
-mutex-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name depth}{nametype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{name}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{name}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> $foo
onyx:1> dup 0 nametype print `\n' print flush
$foo
onyx:1> dup 1 nametype print `\n' print flush
$foo
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null depth}{nulltype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{null}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{null}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> null
onyx:1> dup 0 nulltype print `\n' print flush
-null-
onyx:1> dup 1 nulltype print `\n' print flush
-null-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator depth}{operatortype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{operator}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{operator}.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> ~realtime
onyx:1> dup 0 operatortype print `\n' print flush
--realtime--
onyx:1> 1 operatortype print `\n' print flush
--realtime--
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark depth}{pmarktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{pmark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{pmark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> { ~x
Error $undefined
ostack: (-pmark- $x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> dup 0 pmarktype print `\n' print flush
-pmark-
onyx:1> dup 1 pmarktype print `\n' print flush
-pmark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:regextype}
\index{regextype@\onyxop{}{regextype}{}}
\item[{\onyxop{regex depth}{regextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regex: ]
			A regex object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{regex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{regex}.
	\item[Example(s): ]\begin{verbatim}

XXX
		\end{verbatim}
	\end{description}
\label{sprintsdict:regsubtype}
\index{regsubtype@\onyxop{}{regsubtype}{}}
\item[{\onyxop{regsub depth}{regsubtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[regsub: ]
			A regsub object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{regsub}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{regsub}.
	\item[Example(s): ]\begin{verbatim}

XXX
		\end{verbatim}
	\end{description}
\label{sprintsdict:realtype}
\index{realtype@\onyxop{}{realtype}{}}
\item[{\onyxop{real depth}{realtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{real}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{real}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42.0
onyx:1> dup 0 realtype print `\n' print flush
4.200000e+01
onyx:1> dup 1 realtype print `\n' print flush
4.200000e+01
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack depth}{stacktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup 0 stacktype print `\n' print flush
-stack-
onyx:1> dup 1 stacktype print `\n' print flush
(1 -stack- 4)
onyx:1> dup 2 stacktype print `\n' print flush
(1 (2 3) 4)
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string depth}{stringtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> `abcd'
onyx:1> dup 0 stringtype print `\n' print flush
`abcd'
onyx:1> dup 1 stringtype print `\n' print flush
`abcd'
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread depth}{threadtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> thread
onyx:1> dup 0 threadtype print `\n' print flush
-thread-
onyx:1> dup 1 threadtype print `\n' print flush
-thread-
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{systemdict}
\label{sec:systemdict}
\index{systemdict@\onyxop{}{systemdict}{}}

The systemdict dictionary contains most of the operators that are of general
use.  Although there are no mechanisms that prevent modification of systemdict,
programs should not normally need to modify systemdict, since globaldict
provides a place for storing globally shared objects.  All threads share the
same systemdict, which is implicitly locked.

\begin{longtable}{\optableformat{4.10}}
\caption{systemdict summary} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{2}{|l|}{Operand stack operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{mark}{systemdict:mark}}}
	{mark}
	{Create a mark.}
\hline
\optableent
	{\commas obj}
	{{\bf \htmlref{aup}{systemdict:aup}}}
	{obj \commas}
	{Rotate stack up one position.}
\hline
\optableent
	{obj \commas}
	{{\bf \htmlref{adn}{systemdict:adn}}}
	{\commas obj}
	{Rotate stack down one position.}
\hline
\optableent
	{--}
	{{\bf \htmlref{count}{systemdict:count}}}
	{count}
	{Get the number of objects on ostack.}
\hline
\optableent
	{mark \dots}
	{{\bf \htmlref{counttomark}{systemdict:counttomark}}}
	{mark \dots count}
	{Get the depth of the topmost mark on ostack.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{dup}{systemdict:dup}}}
	{obj dup}
	{Duplicate an object.}
\hline
\optableent
	{obj \commas}
	{{\bf \htmlref{bdup}{systemdict:bdup}}}
	{obj \commas dup}
	{Duplicate bottom object.}
\hline
\optableent
	{objects count}
	{{\bf \htmlref{ndup}{systemdict:ndup}}}
	{objects objects}
	{Duplicate objects.}
\hline
\optableent
	{obj \dots index}
	{{\bf \htmlref{idup}{systemdict:idup}}}
	{obj \dots dup}
	{Duplicate object on ostack at index.}
\hline
\optableent
	{\dots obj \commas index}
	{{\bf \htmlref{ibdup}{systemdict:ibdup}}}
	{\dots obj \commas dup}
	{Duplicate object on ostack at index from bottom.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{tuck}{systemdict:tuck}}}
	{b a b}
	{Tuck duplicate of top object under second object.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{under}{systemdict:under}}}
	{a a b}
	{Duplicate second object.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{over}{systemdict:over}}}
	{a b a}
	{Duplicate second object.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{exch}{systemdict:exch}}}
	{b a}
	{Exchange top two objects.}
\hline
\optableent
	{a b c}
	{{\bf \htmlref{up}{systemdict:up}}}
	{c a b}
	{Roll top three objects up one.}
\hline
\optableent
	{a \dots b count}
	{{\bf \htmlref{nup}{systemdict:nup}}}
	{b a \dots}
	{Roll count objects up one.}
\hline
\optableent
	{a b c}
	{{\bf \htmlref{dn}{systemdict:dn}}}
	{b c a}
	{Roll top three objects down one.}
\hline
\optableent
	{a \dots b count}
	{{\bf \htmlref{ndn}{systemdict:ndn}}}
	{\dots b a}
	{Roll count objects down one.}
\hline
\optableent
	{\dots amount}
	{{\bf \htmlref{rot}{systemdict:rot}}}
	{\dots}
	{Rotate stack up by \oparg{amount}.}
\hline
\optableent
	{region count amount}
	{{\bf \htmlref{roll}{systemdict:roll}}}
	{rolled}
	{Roll \oparg{count} objects up by \oparg{amount}.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{pop}{systemdict:pop}}}
	{--}
	{Remove object.}
\hline
\optableent
	{obj \commas}
	{{\bf \htmlref{bpop}{systemdict:bpop}}}
	{\commas}
	{Remove bottom object.}
\hline
\optableent
	{objects count}
	{{\bf \htmlref{npop}{systemdict:npop}}}
	{--}
	{Remove count objects.}
\hline
\optableent
	{objects \dots count}
	{{\bf \htmlref{nbpop}{systemdict:nbpop}}}
	{\dots}
	{Remove count objects from bottom.}
\hline
\optableent
	{obj \dots index}
	{{\bf \htmlref{ipop}{systemdict:ipop}}}
	{\dots}
	{Remove object at index.}
\hline
\optableent
	{\dots obj \commas index}
	{{\bf \htmlref{ibpop}{systemdict:ibpop}}}
	{\dots \commas}
	{Remove object at index from bottom.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{nip}{systemdict:nip}}}
	{b}
	{Remove second object.}
\hline
\optableent
	{objects}
	{{\bf \htmlref{clear}{systemdict:clear}}}
	{--}
	{Pop all objects off ostack.}
\hline
\optableent
	{mark \dots}
	{{\bf \htmlref{cleartomark}{systemdict:cleartomark}}}
	{--}
	{Remove objects from ostack through topmost mark.}
\hline
\optableent
	{--}
	{{\bf \htmlref{ostack}{systemdict:ostack}}}
	{stack}
	{Get a current ostack snapshot.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{threadostack}{systemdict:threadostack}}}
	{stack}
	{Get a reference to thread's ostack.}
\hline \hline
\multicolumn{2}{|l|}{Execution, control, and execution stack operators} \\
\hline \hline
\optableent
	{obj}
	{{\bf \htmlref{eval}{systemdict:eval}}}
	{--}
	{Evaluate object.}
\hline
\optableent
	{boolean obj}
	{{\bf \htmlref{if}{systemdict:if}}}
	{--}
	{Conditionally evaluate object.}
\hline
\optableent
	{boolean a b}
	{{\bf \htmlref{ifelse}{systemdict:ifelse}}}
	{--}
	{Conditionally evaluate one of two objects.}
\hline
\optableent
	{init inc limit proc}
	{{\bf \htmlref{for}{systemdict:for}}}
	{--}
	{Iterate with a control variable.}
\hline
\optableent
	{count proc}
	{{\bf \htmlref{repeat}{systemdict:repeat}}}
	{--}
	{Iterate a set number of times.}
\hline
\optableent
	{cond proc}
	{{\bf \htmlref{while}{systemdict:while}}}
	{--}
	{ Loop while cond is true.}
\hline
\optableent
	{proc cond}
	{{\bf \htmlref{until}{systemdict:until}}}
	{--}
	{ Loop until cond is false.}
\hline
\optableent
	{proc}
	{{\bf \htmlref{loop}{systemdict:loop}}}
	{--}
	{ Loop indefinitely.}
\hline
\optableent
	{array proc}
	{{\bf \htmlref{foreach}{systemdict:foreach}}}
	{--}
	{Iterate on array elements.}
\optableent
	{dict proc}
	{{\bf \htmlref{foreach}{systemdict:foreach}}}
	{--}
	{Iterate on dictionary key/value pairs.}
\optableent
	{stack proc}
	{{\bf \htmlref{foreach}{systemdict:foreach}}}
	{--}
	{Iterate on stack elements.}
\optableent
	{string proc}
	{{\bf \htmlref{foreach}{systemdict:foreach}}}
	{--}
	{Iterate on string elements.}
\hline
\optableent
	{--}
	{{\bf \htmlref{exit}{systemdict:exit}}}
	{--}
	{Terminate innermost looping context.}
\hline
\optableent
	{file/string}
	{{\bf \htmlref{token}{systemdict:token}}}
	{false}
	{Unsuccessfully scan for a token.}
\optableent
	{file/string}
	{{\bf \htmlref{token}{systemdict:token}}}
	{rem obj true}
	{Successfully scan for a token}
\hline
\optableent
	{obj}
	{{\bf \htmlref{start}{systemdict:start}}}
	{--}
	{Evaluate object.}
\hline
\optableent
	{--}
	{{\bf \htmlref{quit}{systemdict:quit}}}
	{--}
	{Unwind to innermost start context.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{stopped}{systemdict:stopped}}}
	{boolean}
	{Evaluate object.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stop}{systemdict:stop}}}
	{--}
	{Unwind to innermost stopped or start context.}
\hline
\optableent
	{name}
	{{\bf \htmlref{throw}{systemdict:throw}}}
	{obj}
	{Throw an error.}
\hline
\optableent
	{--}
	{{\bf \htmlref{estack}{systemdict:estack}}}
	{stack}
	{Get a current estack snapshot.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{threadestack}{systemdict:threadestack}}}
	{stack}
	{Get a reference to thread's estack.}
\hline
\optableent
	{--}
	{{\bf \htmlref{countestack}{systemdict:countestack}}}
	{count}
	{Get current estack depth.}
\hline
\optableent
	{--}
	{{\bf \htmlref{istack}{systemdict:istack}}}
	{stack}
	{Get a current istack snapshot.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{threadistack}{systemdict:threadistack}}}
	{stack}
	{Get a reference to thread's istack.}
\hline
\optableent
	{status}
	{{\bf \htmlref{die}{systemdict:die}}}
	{--}
	{Exit program.}
\hline
\optableent
	{path symbol}
	{{\bf \htmlref{modload}{systemdict:modload}}}
	{--}
	{Load a module.}
\hline
\optableent
	{file symbol}
	{{\bf \htmlref{mrequire}{systemdict:mrequire}}}
	{--}
	{Search for and load a module.}
\hline
\optableent
	{file}
	{{\bf \htmlref{require}{systemdict:require}}}
	{--}
	{Search for and evaluate a source file.}
\hline
\optableent
	{args}
	{{\bf \htmlref{exec}{systemdict:exec}}}
	{--}
	{Overlay a new program and execute it.}
\hline
\optableent
	{args}
	{{\bf \htmlref{forkexec}{systemdict:forkexec}}}
	{pid}
	{Fork and exec a new process.}
\hline
\optableent
	{pid}
	{{\bf \htmlref{waitpid}{systemdict:waitpid}}}
	{status}
	{Wait for a program to terminate.}
\hline
\optableent
	{args}
	{{\bf \htmlref{system}{systemdict:system}}}
	{status}
	{Execute a program.}
\hline
\optableent
	{--}
	{{\bf \htmlref{pid}{systemdict:pid}}}
	{pid}
	{Get process ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{ppid}{systemdict:ppid}}}
	{pid}
	{Get parent's process ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{uid}{systemdict:uid}}}
	{uid}
	{Get the process's user ID.}
\hline
\optableent
	{uid}
	{{\bf \htmlref{setuid}{systemdict:setuid}}}
	{boolean}
	{Set the process's user ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{euid}{systemdict:euid}}}
	{uid}
	{Get the process's effective user ID.}
\hline
\optableent
	{uid}
	{{\bf \htmlref{seteuid}{systemdict:seteuid}}}
	{boolean}
	{Set the process's effective user ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{gid}{systemdict:gid}}}
	{gid}
	{Get the process's group ID.}
\hline
\optableent
	{gid}
	{{\bf \htmlref{setgid}{systemdict:setgid}}}
	{boolean}
	{Set the process's group ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{egid}{systemdict:egid}}}
	{gid}
	{Get the process's effective group ID.}
\hline
\optableent
	{gid}
	{{\bf \htmlref{setegid}{systemdict:setegid}}}
	{boolean}
	{Set the process's effective group ID.}
\hline
\optableent
	{--}
	{{\bf \htmlref{realtime}{systemdict:realtime}}}
	{nsecs}
	{Get the number of nanoseconds since the epoch.}
\hline
\optableent
	{nanoseconds}
	{{\bf \htmlref{nsleep}{systemdict:nsleep}}}
	{--}
	{Nanosleep.}
\hline \hline
\multicolumn{2}{|l|}{Stack operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{(}{systemdict:sym_lp}}}
	{fino}
	{Begin a stack declaration.}
\hline
\optableent
	{fino objects}
	{{\bf \htmlref{)}{systemdict:sym_rp}}}
	{stack}
	{Create a stack.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stack}{systemdict:stack}}}
	{stack}
	{Create a stack.}
\hline
\optableent
	{stack obj}
	{{\bf \htmlref{spush}{systemdict:spush}}}
	{--}
	{Push object onto stack.}
\hline
\optableent
	{stack obj}
	{{\bf \htmlref{sbpush}{systemdict:sbpush}}}
	{--}
	{Push object onto bottom of stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{scount}{systemdict:scount}}}
	{count}
	{Get the number of objects on a stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{scounttomark}{systemdict:scounttomark}}}
	{count}
	{Get the depth of the topmost mark on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sdup}{systemdict:sdup}}}
	{--}
	{Duplicate an object.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sbdup}{systemdict:sbdup}}}
	{--}
	{Duplicate bottom object.}
\hline
\optableent
	{stack count}
	{{\bf \htmlref{sndup}{systemdict:sndup}}}
	{--}
	{Duplicate objects on stack.}
\hline
\optableent
	{stack index}
	{{\bf \htmlref{sidup}{systemdict:sidup}}}
	{--}
	{Duplicate object on stack at index.}
\hline
\optableent
	{stack index}
	{{\bf \htmlref{sibdup}{systemdict:sibdup}}}
	{--}
	{Duplicate object on stack at index from bottom.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{stuck}{systemdict:stuck}}}
	{--}
	{Tuck duplicate of top object on stack under next object on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sunder}{systemdict:sunder}}}
	{--}
	{Duplicate second object on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sover}{systemdict:sover}}}
	{--}
	{Duplicate second object on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sexch}{systemdict:sexch}}}
	{--}
	{Exchange top objects on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sup}{systemdict:sup}}}
	{--}
	{Roll top three objects on stack up one.}
\hline
\optableent
	{stack count}
	{{\bf \htmlref{snup}{systemdict:snup}}}
	{--}
	{Roll count objects on stack up one.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{saup}{systemdict:saup}}}
	{--}
	{Roll objects on stack up one.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sdn}{systemdict:sdn}}}
	{--}
	{Roll top three objects on stack down one.}
\hline
\optableent
	{stack count}
	{{\bf \htmlref{sndn}{systemdict:sndn}}}
	{--}
	{Roll count objects on stack down one.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sadn}{systemdict:sadn}}}
	{--}
	{Roll objects on stack down one.}
\hline
\optableent
	{stack amount}
	{{\bf \htmlref{srot}{systemdict:srot}}}
	{--}
	{Rotate objects on stack up by \oparg{amount}.}
\hline
\optableent
	{stack count amount}
	{{\bf \htmlref{sroll}{systemdict:sroll}}}
	{--}
	{Roll objects on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{spop}{systemdict:spop}}}
	{obj}
	{Pop object off stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sbpop}{systemdict:sbpop}}}
	{obj}
	{Pop object off bottom of stack.}
\hline
\optableent
	{stack count}
	{{\bf \htmlref{snpop}{systemdict:snpop}}}
	{array}
	{Pop count objects off stack.}
\hline
\optableent
	{stack count}
	{{\bf \htmlref{snbpop}{systemdict:snbpop}}}
	{array}
	{Pop count objects off bottom of stack.}
\hline
\optableent
	{stack index}
	{{\bf \htmlref{sipop}{systemdict:sipop}}}
	{obj}
	{Remove object on stack at index.}
\hline
\optableent
	{stack index}
	{{\bf \htmlref{sibpop}{systemdict:sibpop}}}
	{obj}
	{Remove object on stack at index from bottom.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{snip}{systemdict:snip}}}
	{obj}
	{Remove second object on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{sclear}{systemdict:sclear}}}
	{--}
	{Remove all objects on stack.}
\hline
\optableent
	{stack}
	{{\bf \htmlref{scleartomark}{systemdict:scleartomark}}}
	{--}
	{Remove objects from stack down through topmost mark.}
\hline
\optableent
	{(a) (b)}
	{{\bf \htmlref{cat}{systemdict:cat}}}
	{(a b)}
	{Catenate two stacks.}
\hline
\optableent
	{stacks count}
	{{\bf \htmlref{ncat}{systemdict:ncat}}}
	{stack}
	{Catenate stacks.}
\hline
\optableent
	{srcstack dststack}
	{{\bf \htmlref{copy}{systemdict:copy}}}
	{dststack}
	{Copy stack contents.}
\hline \hline
\multicolumn{2}{|l|}{Number (integer, real) and math operators} \\
\hline \hline
\optableent
	{a b}
	{{\bf \htmlref{add}{systemdict:add}}}
	{r}
	{Add a and b.}
\hline
\optableent
	{a}
	{{\bf \htmlref{inc}{systemdict:inc}}}
	{r}
	{Add 1 to a.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{sub}{systemdict:sub}}}
	{r}
	{Subtract b from a.}
\hline
\optableent
	{a}
	{{\bf \htmlref{dec}{systemdict:dec}}}
	{r}
	{Subtract 1 from a.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{mul}{systemdict:mul}}}
	{r}
	{Multiply a and b.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{div}{systemdict:div}}}
	{r}
	{Divide a by b.}
\hline
\optableent
	{a b}
	{{\bf \htmlref{idiv}{systemdict:idiv}}}
	{r}
	{Divide a by b (integers).}
\hline
\optableent
	{a b}
	{{\bf \htmlref{mod}{systemdict:mod}}}
	{r}
	{Mod a by b (integers).}
\hline
\optableent
	{a b}
	{{\bf \htmlref{exp}{systemdict:exp}}}
	{r}
	{Raise a to the power of b.}
\hline
\optableent
	{a}
	{{\bf \htmlref{sqrt}{systemdict:sqrt}}}
	{r}
	{Square root.}
\hline
\optableent
	{a}
	{{\bf \htmlref{ln}{systemdict:ln}}}
	{r}
	{Natural log.}
\hline
\optableent
	{a}
	{{\bf \htmlref{log}{systemdict:log}}}
	{r}
	{Base 10 log.}
\hline
\optableent
	{a}
	{{\bf \htmlref{abs}{systemdict:abs}}}
	{r}
	{Get the absolute value of a.}
\hline
\optableent
	{a}
	{{\bf \htmlref{neg}{systemdict:neg}}}
	{r}
	{Get the negative of a.}
\hline
\optableent
	{a}
	{{\bf \htmlref{ceiling}{systemdict:ceiling}}}
	{r}
	{Integer ceiling of a real.}
\hline
\optableent
	{a}
	{{\bf \htmlref{floor}{systemdict:floor}}}
	{r}
	{Integer floor of a real.}
\hline
\optableent
	{a}
	{{\bf \htmlref{round}{systemdict:round}}}
	{r}
	{Real rounded to integer.}
\hline
\optableent
	{a}
	{{\bf \htmlref{trunc}{systemdict:trunc}}}
	{r}
	{Integer from real with truncated fractional.}
\hline
\optableent
	{a}
	{{\bf \htmlref{sin}{systemdict:sin}}}
	{r}
	{Sine in radians.}
\hline
\optableent
	{a}
	{{\bf \htmlref{cos}{systemdict:cos}}}
	{r}
	{Cosine in radians.}
\hline
\optableent
	{y x}
	{{\bf \htmlref{atan}{systemdict:atan}}}
	{r}
	{Arctangent in radians of $y/x$.}
\hline
\optableent
	{seed}
	{{\bf \htmlref{srand}{systemdict:srand}}}
	{--}
	{Seed pseudo-random number generator.}
\hline
\optableent
	{--}
	{{\bf \htmlref{rand}{systemdict:rand}}}
	{integer}
	{Get a pseudo-random number.}
\hline \hline
\multicolumn{2}{|l|}{String operators} \\
\hline \hline
\optableent
	{length}
	{{\bf \htmlref{string}{systemdict:string}}}
	{string}
	{Create a string.}
\hline
\optableent
	{string}
	{{\bf \htmlref{length}{systemdict:length}}}
	{count}
	{Get string length.}
\hline
\optableent
	{string index}
	{{\bf \htmlref{get}{systemdict:get}}}
	{integer}
	{Get string element.}
\hline
\optableent
	{string index integer}
	{{\bf \htmlref{put}{systemdict:put}}}
	{--}
	{Set string element.}
\hline
\optableent
	{string index length}
	{{\bf \htmlref{getinterval}{systemdict:getinterval}}}
	{substring}
	{Get a string interval.}
\hline
\optableent
	{string index substring}
	{{\bf \htmlref{putinterval}{systemdict:putinterval}}}
	{--}
	{Copy substring into string.}
\hline
\optableent
	{`a' `b'}
	{{\bf \htmlref{cat}{systemdict:cat}}}
	{`ab'}
	{Catenate two strings.}
\hline
\optableent
	{strings count}
	{{\bf \htmlref{ncat}{systemdict:ncat}}}
	{string}
	{Catenate strings.}
\hline
\optableent
	{srcstring dststring}
	{{\bf \htmlref{copy}{systemdict:copy}}}
	{dstsubstring}
	{Copy string.}
\hline
\optableent
	{obj depth}
	{{\bf \htmlref{sprints}{systemdict:sprints}}}
	{string}
	{Create syntactical string from object.}
\hline
\optableent
	{obj flags}
	{{\bf \htmlref{outputs}{systemdict:outputs}}}
	{string}
	{Create formatted string from object.}
\hline
\optableent
	{string pattern}
	{{\bf \htmlref{search}{systemdict:search}}}
	{post pattern pre true}
	{Successfully search for pattern.}
\optableent
	{string pattern}
	{{\bf \htmlref{search}{systemdict:search}}}
	{string false}
	{Unsuccessfully earch for pattern.}
\hline \hline
\multicolumn{2}{|l|}{Name operators} \\
\hline \hline
\optableent
	{name}
	{{\bf \htmlref{length}{systemdict:length}}}
	{count}
	{Get name length.}
\hline \hline
\multicolumn{2}{|l|}{Array operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{argv}{systemdict:argv}}}
	{args}
	{Get program arguments.}
\hline
\optableent
	{--}
	{{\bf \htmlref{[}{systemdict:sym_lb}}}
	{mark}
	{Begin an array declaration.}
\hline
\optableent
	{mark objects}
	{{\bf \htmlref{]}{systemdict:sym_rb}}}
	{array}
	{Construct an array.}
\hline
\optableent
	{length}
	{{\bf \htmlref{array}{systemdict:array}}}
	{array}
	{Create an array.}
\hline
\optableent
	{array}
	{{\bf \htmlref{length}{systemdict:length}}}
	{count}
	{Get array length.}
\hline
\optableent
	{array index}
	{{\bf \htmlref{get}{systemdict:get}}}
	{obj}
	{Get array element.}
\hline
\optableent
	{array index obj}
	{{\bf \htmlref{put}{systemdict:put}}}
	{--}
	{Set array element.}
\hline
\optableent
	{array index length}
	{{\bf \htmlref{getinterval}{systemdict:getinterval}}}
	{subarray}
	{Get an array interval.}
\hline
\optableent
	{array index subarray}
	{{\bf \htmlref{putinterval}{systemdict:putinterval}}}
	{--}
	{Copy subarray into array.}
\hline
\optableent
	{[a] [b]}
	{{\bf \htmlref{cat}{systemdict:cat}}}
	{[a b]}
	{Catenate two arrays.}
\hline
\optableent
	{arrays count}
	{{\bf \htmlref{ncat}{systemdict:ncat}}}
	{array}
	{Catenate arrays.}
\hline
\optableent
	{srcarray dstarray}
	{{\bf \htmlref{copy}{systemdict:copy}}}
	{dstsubarray}
	{Copy array.}
\hline \hline
\multicolumn{2}{|l|}{Dictionary and dictionary stack operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{gcdict}{systemdict:gcdict}}}
	{dict}
	{Get gcdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{userdict}{systemdict:userdict}}}
	{dict}
	{Get userdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{globaldict}{systemdict:globaldict}}}
	{dict}
	{Get globaldict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{systemdict}{systemdict:systemdict}}}
	{dict}
	{Get systemdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{onyxdict}{systemdict:onyxdict}}}
	{dict}
	{Get onyxdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{sprintsdict}{systemdict:sprintsdict}}}
	{dict}
	{Get sprintsdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{outputsdict}{systemdict:outputsdict}}}
	{dict}
	{Get outputsdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{envdict}{systemdict:envdict}}}
	{dict}
	{Get envdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{threadsdict}{systemdict:threadsdict}}}
	{dict}
	{Get threadsdict.}
\hline
\optableent
	{key val}
	{{\bf \htmlref{setenv}{systemdict:setenv}}}
	{--}
	{Set environment variable.}
\hline
\optableent
	{key}
	{{\bf \htmlref{unsetenv}{systemdict:unsetenv}}}
	{--}
	{Unset environment variable.}
\hline
\optableent
	{--}
	{{\bf \htmlref{{\lt}}{systemdict:sym_lt}}}
	{mark}
	{Begin a dictionary declaration.}
\hline
\optableent
	{mark kvpairs}
	{{\bf \htmlref{{\gt}}{systemdict:sym_gt}}}
	{dict}
	{Construct a dictionary.}
\hline
\optableent
	{--}
	{{\bf \htmlref{dict}{systemdict:dict}}}
	{dict}
	{Create a dictionary.}
\hline
\optableent
	{dict}
	{{\bf \htmlref{begin}{systemdict:begin}}}
	{--}
	{Pust dict onto dstack.}
\hline
\optableent
	{--}
	{{\bf \htmlref{end}{systemdict:end}}}
	{--}
	{Pop a dictionary off dstack.}
\hline
\optableent
	{key val}
	{{\bf \htmlref{def}{systemdict:def}}}
	{--}
	{Define key/value pair.}
\hline
\optableent
	{dict key}
	{{\bf \htmlref{undef}{systemdict:undef}}}
	{--}
	{Undefine key in dict.}
\hline
\optableent
	{key}
	{{\bf \htmlref{load}{systemdict:load}}}
	{val}
	{Look up a key's value.}
\hline
\optableent
	{dict key}
	{{\bf \htmlref{known}{systemdict:known}}}
	{boolean}
	{Check for key in dict.}
\hline
\optableent
	{key}
	{{\bf \htmlref{where}{systemdict:where}}}
	{false}
	{Unsuccessfully get topmost dstack dictionary that defines key.}
\hline
\optableent
	{key}
	{{\bf \htmlref{where}{systemdict:where}}}
	{dict true}
	{Successfully get topmost dstack dictionary that defines key.}
\hline
\optableent
	{dict}
	{{\bf \htmlref{length}{systemdict:length}}}
	{count}
	{Get number of dictionary key/value pairs.}
\hline
\optableent
	{dict key}
	{{\bf \htmlref{get}{systemdict:get}}}
	{value}
	{Get dict value associate with key.}
\hline
\optableent
	{dict key value}
	{{\bf \htmlref{put}{systemdict:put}}}
	{--}
	{Set dict key/value pair.}
\hline
\optableent
	{srcdict dstdict}
	{{\bf \htmlref{copy}{systemdict:copy}}}
	{dstdict}
	{Copy dictionary contents.}
\hline
\optableent
	{--}
	{{\bf \htmlref{currentdict}{systemdict:currentdict}}}
	{dict}
	{Get topmost dstack dictionary.}
\hline
\optableent
	{--}
	{{\bf \htmlref{dstack}{systemdict:dstack}}}
	{stack}
	{Get dstack snapshot.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{threaddstack}{systemdict:threaddstack}}}
	{stack}
	{Get a reference to thread's dstack.}
\hline
\optableent
	{--}
	{{\bf \htmlref{countdstack}{systemdict:countdstack}}}
	{count}
	{Get number of stacks on dstack.}
\hline \hline
\multicolumn{2}{|l|}{File and filesystem operators} \\
\hline \hline
\optableent
	{filename flags}
	{{\bf \htmlref{open}{systemdict:open}}}
	{file}
	{Open a file.}
\optableent
	{filename flags mode}
	{{\bf \htmlref{open}{systemdict:open}}}
	{file}
	{Open a file, creation mode specified.}
\hline
\optableent
	{--}
	{{\bf \htmlref{pipe}{systemdict:pipe}}}
	{rfile wfile}
	{Create a pipe.}
\hline
\optableent
	{file}
	{{\bf \htmlref{close}{systemdict:close}}}
	{--}
	{Close file.}
\hline
\optableent
	{file}
	{{\bf \htmlref{read}{systemdict:read}}}
	{integer boolean}
	{Read from file.}
\optableent
	{file string}
	{{\bf \htmlref{read}{systemdict:read}}}
	{substring boolean}
	{Read from file.}
\optableent
	{file}
	{{\bf \htmlref{readline}{systemdict:readline}}}
	{string boolean}
	{Read a line from file.}
\hline
\optableent
	{{\lt}file dict \dots{\gt} timeout}
	{{\bf \htmlref{poll}{systemdict:poll}}}
	{{\lb}file \dots{\rb}}
	{Wait for file(s) to change status.}
\hline
\optableent
	{file}
	{{\bf \htmlref{bytesavailable}{systemdict:bytesavailable}}}
	{count}
	{Get number of buffered readable bytes.}
\hline
\optableent
	{file}
	{{\bf \htmlref{iobuf}{systemdict:iobuf}}}
	{count}
	{Get size of I/O buffer.}
\hline
\optableent
	{file count}
	{{\bf \htmlref{setiobuf}{systemdict:setiobuf}}}
	{--}
	{Set size of I/O buffer.}
\hline
\optableent
	{file}
	{{\bf \htmlref{nonblocking}{systemdict:nonblocking}}}
	{boolean}
	{Get non-blocking mode.}
\hline
\optableent
	{file boolean}
	{{\bf \htmlref{setnonblocking}{systemdict:setnonblocking}}}
	{--}
	{Set non-blocking mode.}
\hline
\optableent
	{file integer/string}
	{{\bf \htmlref{write}{systemdict:write}}}
	{false}
	{Write to file.}
\optableent
	{file integer/string}
	{{\bf \htmlref{write}{systemdict:write}}}
	{integer/substring true}
	{Write to file.}
\hline
\optableent
	{string}
	{{\bf \htmlref{print}{systemdict:print}}}
	{--}
	{Print string to stdout.}
\hline
\optableent
	{obj depth}
	{{\bf \htmlref{sprint}{systemdict:sprint}}}
	{--}
	{Syntactically print object to stdout.}
\hline
\optableent
	{obj flags}
	{{\bf \htmlref{output}{systemdict:output}}}
	{--}
	{Formatted print to stdout.}
\hline
\optableent
	{--}
	{{\bf \htmlref{pstack}{systemdict:pstack}}}
	{--}
	{Syntactically print ostack elements.}
\hline
\optableent
	{file}
	{{\bf \htmlref{flushfile}{systemdict:flushfile}}}
	{--}
	{Flush file buffer.}
\hline
\optableent
	{--}
	{{\bf \htmlref{flush}{systemdict:flush}}}
	{--}
	{Flush stdout buffer.}
\hline
\optableent
	{file length}
	{{\bf \htmlref{truncate}{systemdict:truncate}}}
	{--}
	{Truncate file.}
\hline
\optableent
	{file offset}
	{{\bf \htmlref{seek}{systemdict:seek}}}
	{--}
	{Move file position pointer.}
\hline
\optableent
	{file}
	{{\bf \htmlref{tell}{systemdict:tell}}}
	{offset}
	{Get file position pointer offset.}
\hline
\optableent
	{path}
	{{\bf \htmlref{mkdir}{systemdict:mkdir}}}
	{--}
	{Create a directory.}
\optableent
	{path mode}
	{{\bf \htmlref{mkdir}{systemdict:mkdir}}}
	{--}
	{Create a directory, mode specified.}
\hline
\optableent
	{path}
	{{\bf \htmlref{mkfifo}{systemdict:mkfifo}}}
	{--}
	{Create a named pipe.}
\optableent
	{path mode}
	{{\bf \htmlref{mkfifo}{systemdict:mkfifo}}}
	{--}
	{Create a named pipe, mode specified.}
\hline
\optableent
	{old new}
	{{\bf \htmlref{rename}{systemdict:rename}}}
	{--}
	{Rename a file or directory.}
\hline
\optableent
	{file/filename mode}
	{{\bf \htmlref{chmod}{systemdict:chmod}}}
	{--}
	{Change file permissions.}
\hline
\optableent
	{file/filename uid gid}
	{{\bf \htmlref{chown}{systemdict:chown}}}
	{--}
	{Change file owner and group.}
\hline
\optableent
	{filename linkname}
	{{\bf \htmlref{link}{systemdict:link}}}
	{--}
	{Create a hard link.}
\hline
\optableent
	{filename linkname}
	{{\bf \htmlref{symlink}{systemdict:symlink}}}
	{--}
	{Create a symbolic link.}
\hline
\optableent
	{filename}
	{{\bf \htmlref{unlink}{systemdict:unlink}}}
	{--}
	{Unlink a file.}
\hline
\optableent
	{path}
	{{\bf \htmlref{rmdir}{systemdict:rmdir}}}
	{--}
	{Remove an empty directory.}
\hline
\optableent
	{file/filename flag}
	{{\bf \htmlref{test}{systemdict:test}}}
	{boolean}
	{Test a file.}
\hline
\optableent
	{file/filename}
	{{\bf \htmlref{status}{systemdict:status}}}
	{dict}
	{Get file information.}
\hline
\optableent
	{linkname}
	{{\bf \htmlref{readlink}{systemdict:readlink}}}
	{string}
	{Get symbolic link data.}
\hline
\optableent
	{path proc}
	{{\bf \htmlref{dirforeach}{systemdict:dirforeach}}}
	{--}
	{Iterate on directory entries.}
\hline
\optableent
	{--}
	{{\bf \htmlref{pwd}{systemdict:pwd}}}
	{path}
	{Get present working directory.}
\hline
\optableent
	{path}
	{{\bf \htmlref{cd}{systemdict:cd}}}
	{--}
	{Change present working directory.}
\hline
\optableent
	{path}
	{{\bf \htmlref{chroot}{systemdict:chroot}}}
	{--}
	{Change root directory.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stdin}{systemdict:stdin}}}
	{file}
	{Get thread's stdin.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stdout}{systemdict:stdout}}}
	{file}
	{Get thread's stdout.}
\hline
\optableent
	{--}
	{{\bf \htmlref{stderr}{systemdict:stderr}}}
	{file}
	{Get thread's stderr.}
\hline
\optableent
	{--}
	{{\bf \htmlref{gstdin}{systemdict:gstdin}}}
	{file}
	{Get global stdin.}
\hline
\optableent
	{--}
	{{\bf \htmlref{gstdout}{systemdict:gstdout}}}
	{file}
	{Get global stdout.}
\hline
\optableent
	{--}
	{{\bf \htmlref{gstderr}{systemdict:gstderr}}}
	{file}
	{Get global stderr.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setstdin}{systemdict:setstdin}}}
	{--}
	{Set thread's stdin.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setstdout}{systemdict:setstdout}}}
	{--}
	{Set thread's stdout.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setstderr}{systemdict:setstderr}}}
	{--}
	{Set thread's stderr.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setgstdin}{systemdict:setgstdin}}}
	{--}
	{Set global stdin.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setgstdout}{systemdict:setgstdout}}}
	{--}
	{Set global stdout.}
\hline
\optableent
	{file}
	{{\bf \htmlref{setgstderr}{systemdict:setgstderr}}}
	{--}
	{Set global stderr.}
\hline \hline
\multicolumn{2}{|l|}{Socket and networking operators} \\
\hline \hline
\optableent
	{family type proto}
	{{\bf \htmlref{socket}{systemdict:socket}}}
	{sock}
	{Create a socket.}
\optableent
	{family type}
	{{\bf \htmlref{socket}{systemdict:socket}}}
	{sock}
	{Create a socket.}
\hline
\optableent
	{sock addr port}
	{{\bf \htmlref{bindsocket}{systemdict:bindsocket}}}
	{--}
	{Bind socket to address/port.}
\optableent
	{sock addr}
	{{\bf \htmlref{bindsocket}{systemdict:bindsocket}}}
	{--}
	{Bind socket to address.}
\optableent
	{sock path}
	{{\bf \htmlref{bindsocket}{systemdict:bindsocket}}}
	{--}
	{Bind socket to port.}
\hline
\optableent
	{sock backlog}
	{{\bf \htmlref{listen}{systemdict:listen}}}
	{--}
	{Listen for socket connections.}
\optableent
	{sock}
	{{\bf \htmlref{listen}{systemdict:listen}}}
	{--}
	{Listen for socket connections.}
\hline
\optableent
	{sock}
	{{\bf \htmlref{accept}{systemdict:accept}}}
	{sock}
	{Accept a socket connection.}
\hline
\optableent
	{sock addr port}
	{{\bf \htmlref{connect}{systemdict:connect}}}
	{--}
	{Connect a socket.}
\optableent
	{sock path}
	{{\bf \htmlref{connect}{systemdict:connect}}}
	{--}
	{Connect a socket.}
\hline
\optableent
	{service}
	{{\bf \htmlref{serviceport}{systemdict:serviceport}}}
	{port}
	{Get port number for service name.}
\hline
\optableent
	{sock}
	{{\bf \htmlref{sockname}{systemdict:sockname}}}
	{dict}
	{Get socket information.}
\hline
\optableent
	{sock level optname}
	{{\bf \htmlref{sockopt}{systemdict:sockopt}}}
	{optval}
	{Get socket option.}
\optableent
	{sock optname}
	{{\bf \htmlref{sockopt}{systemdict:sockopt}}}
	{optval}
	{Get socket option.}
\hline
\optableent
	{sock level optname optval}
	{{\bf \htmlref{setsockopt}{systemdict:setsockopt}}}
	{--}
	{Set socket option.}
\optableent
	{sock optname optval}
	{{\bf \htmlref{setsockopt}{systemdict:setsockopt}}}
	{--}
	{Set socket option.}
\hline
\optableent
	{sock}
	{{\bf \htmlref{peername}{systemdict:peername}}}
	{dict}
	{Get peer socket information.}
\hline
\optableent
	{sock mesg flags}
	{{\bf \htmlref{send}{systemdict:send}}}
	{nsend}
	{Send a message.}
\optableent
	{sock mesg}
	{{\bf \htmlref{send}{systemdict:send}}}
	{count}
	{Send a message.}
\hline
\optableent
	{sock string flags}
	{{\bf \htmlref{recv}{systemdict:recv}}}
	{substring}
	{Receive a message.}
\optableent
	{sock string}
	{{\bf \htmlref{recv}{systemdict:recv}}}
	{substring}
	{Receive a message.}
\hline
\optableent
	{family type proto}
	{{\bf \htmlref{socketpair}{systemdict:socketpair}}}
	{sock sock}
	{Create a socket pair.}
\optableent
	{family type}
	{{\bf \htmlref{socketpair}{systemdict:socketpair}}}
	{sock sock}
	{Create a socket pair.}
\hline \hline
\multicolumn{2}{|l|}{Logical and bitwise operators} \\
\hline \hline
\optableent
	{a b}
	{{\bf \htmlref{lt}{systemdict:lt}}}
	{boolean}
	{a less than b? (integer/real, string)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{le}{systemdict:le}}}
	{boolean}
	{a less than or equal to b? (integer/real, string)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{eq}{systemdict:eq}}}
	{boolean}
	{a equal to b? (any type)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{ne}{systemdict:ne}}}
	{boolean}
	{a not equal to b? (any type)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{ge}{systemdict:ge}}}
	{boolean}
	{a greater than or equal to b? (integer/real, string)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{gt}{systemdict:gt}}}
	{boolean}
	{a greater than b? (integer/real, string)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{and}{systemdict:and}}}
	{r}
	{Logical/bitwise and. (boolean/integer) }
\hline
\optableent
	{a b}
	{{\bf \htmlref{or}{systemdict:or}}}
	{r}
	{Logical/bitwise or. (boolean/integer)}
\hline
\optableent
	{a b}
	{{\bf \htmlref{xor}{systemdict:xor}}}
	{r}
	{Logical/bitwise exclusive or. (boolean/integer)}
\hline
\optableent
	{a}
	{{\bf \htmlref{not}{systemdict:not}}}
	{r}
	{Logical/bitwise not. (boolean/integer)}
\hline
\optableent
	{a shift}
	{{\bf \htmlref{shift}{systemdict:shift}}}
	{integer}
	{Bitwise shift.}
\hline
\optableent
	{--}
	{{\bf \htmlref{false}{systemdict:false}}}
	{false}
	{Return true.}
\hline
\optableent
	{--}
	{{\bf \htmlref{true}{systemdict:true}}}
	{true}
	{Return false.}
\hline \hline
\multicolumn{2}{|l|}{Type, conversion, and attribute operators} \\
\hline \hline
\optableent
	{obj}
	{{\bf \htmlref{type}{systemdict:type}}}
	{name}
	{Get object type.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{echeck}{systemdict:echeck}}}
	{boolean}
	{Evaluatable?}
\hline
\optableent
	{obj}
	{{\bf \htmlref{xcheck}{systemdict:xcheck}}}
	{boolean}
	{Executable?}
\hline
\optableent
	{obj}
	{{\bf \htmlref{cve}{systemdict:cve}}}
	{obj}
	{Set evaluatable attribute.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{cvx}{systemdict:cvx}}}
	{obj}
	{Set executable attribute.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{cvlit}{systemdict:cvlit}}}
	{obj}
	{Set literal attribute.}
\hline
\optableent
	{string}
	{{\bf \htmlref{cvn}{systemdict:cvn}}}
	{name}
	{Convert string to name.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{cvs}{systemdict:cvs}}}
	{string}
	{Convert object to string.}
\hline
\optableent
	{integer radix}
	{{\bf \htmlref{cvrs}{systemdict:cvrs}}}
	{string}
	{Convert integer to radix string.}
\hline
\optableent
	{real precision}
	{{\bf \htmlref{cvds}{systemdict:cvds}}}
	{string}
	{Convert real to decimal string.}
\hline
\optableent
	{real precision}
	{{\bf \htmlref{cves}{systemdict:cves}}}
	{string}
	{Convert real to exponential string.}
\hline
\optableent
	{hook}
	{{\bf \htmlref{hooktag}{systemdict:hooktag}}}
	{tag}
	{Get hook tag.}
\hline \hline
\multicolumn{2}{|l|}{Threading and synchronization operators} \\
\hline \hline
\optableent
	{stack entry}
	{{\bf \htmlref{thread}{systemdict:thread}}}
	{thread}
	{Create and run a thread.}
\hline
\optableent
	{--}
	{{\bf \htmlref{self}{systemdict:self}}}
	{thread}
	{Get a thread object for the running thread.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{join}{systemdict:join}}}
	{--}
	{Wait for thread to exit.}
\hline
\optableent
	{thread}
	{{\bf \htmlref{detach}{systemdict:detach}}}
	{--}
	{Detach thread.}
\hline
\optableent
	{--}
	{{\bf \htmlref{yield}{systemdict:yield}}}
	{--}
	{Voluntarily yield the processor.}
\hline
\optableent
	{--}
	{{\bf \htmlref{mutex}{systemdict:mutex}}}
	{mutex}
	{Create a mutex.}
\hline
\optableent
	{mutex proc}
	{{\bf \htmlref{monitor}{systemdict:mutex}}}
	{--}
	{Evaluate an object under the protection of a mutex.}
\hline
\optableent
	{mutex}
	{{\bf \htmlref{lock}{systemdict:lock}}}
	{--}
	{Acquire mutex.}
\hline
\optableent
	{mutex}
	{{\bf \htmlref{trylock}{systemdict:trylock}}}
	{boolean}
	{Try to acquire mutex.}
\hline
\optableent
	{mutex}
	{{\bf \htmlref{unlock}{systemdict:unlock}}}
	{--}
	{Release mutex.}
\hline
\optableent
	{--}
	{{\bf \htmlref{condition}{systemdict:condition}}}
	{condition}
	{Create a condition variable.}
\hline
\optableent
	{condition mutex}
	{{\bf \htmlref{wait}{systemdict:wait}}}
	{--}
	{Wait on condition.}
\hline
\optableent
	{condition mutex timeout}
	{{\bf \htmlref{timedwait}{systemdict:timedwait}}}
	{boolean}
	{Wait on condition with timeout.}
\hline
\optableent
	{condition}
	{{\bf \htmlref{signal}{systemdict:signal}}}
	{--}
	{Signal a condition waiter.}
\hline
\optableent
	{condition}
	{{\bf \htmlref{broadcast}{systemdict:broadcast}}}
	{--}
	{Signal all condition waiters.}
\hline
\optableent
	{--}
	{{\bf \htmlref{currentlocking}{systemdict:currentlocking}}}
	{boolean}
	{Get implicit locking mode.}
\hline
\optableent
	{boolean}
	{{\bf \htmlref{setlocking}{systemdict:setlocking}}}
	{--}
	{Set implicit locking mode.}
\hline
\optableent
	{obj}
	{{\bf \htmlref{lcheck}{systemdict:lcheck}}}
	{boolean}
	{Implicitly locked?}
\hline \hline
\multicolumn{2}{|l|}{Regular expression operators} \\
\hline \hline
\optableent
	{string flags}
	{{\bf \htmlref{regex}{systemdict:regex}}}
	{regex}
	{Create a regex object.}
\optableent
	{string}
	{{\bf \htmlref{regex}{systemdict:regex}}}
	{regex}
	{Create a regex object.}
\hline
\optableent
	{input pattern flags}
	{{\bf \htmlref{match}{systemdict:match}}}
	{matches}
	{Find pattern matches in input string.}
\optableent
	{input pattern}
	{{\bf \htmlref{match}{systemdict:match}}}
	{matches}
	{Find pattern matches in input string.}
\optableent
	{input regex}
	{{\bf \htmlref{match}{systemdict:match}}}
	{matches}
	{Find regex matches in input string.}
\hline
\optableent
	{input matches}
	{{\bf \htmlref{offsets}{systemdict:offsets}}}
	{offsets}
	{Get match offsets from beginning of input.}
\hline
\optableent
	{pattern template flags}
	{{\bf \htmlref{regsub}{systemdict:regsub}}}
	{regsub}
	{Create a regsub object.}
\optableent
	{pattern template}
	{{\bf \htmlref{regsub}{systemdict:regsub}}}
	{regsub}
	{Create a regsub object.}
\hline
\optableent
	{input pattern template flags}
	{{\bf \htmlref{subst}{systemdict:subst}}}
	{output count}
	{Substitute template for pattern matches.}
\optableent
	{input pattern template}
	{{\bf \htmlref{subst}{systemdict:subst}}}
	{output count}
	{Substitute template for pattern matches.}
\optableent
	{input regsub}
	{{\bf \htmlref{subst}{systemdict:subst}}}
	{output count}
	{Substitute.}
\hline \hline
\multicolumn{2}{|l|}{Miscellaneous operators} \\
\hline \hline
\optableent
	{--}
	{{\bf \htmlref{product}{systemdict:product}}}
	{string}
	{Get the product string.}
\hline
\optableent
	{--}
	{{\bf \htmlref{version}{systemdict:version}}}
	{string}
	{Get the version string.}
\hline
\optableent
	{proc}
	{{\bf \htmlref{bind}{systemdict:bind}}}
	{proc}
	{Bind names to operators.}
\hline
\optableent
	{--}
	{{\bf \htmlref{null}{systemdict:null}}}
	{null}
	{Create a null object.}
\end{longtable}

%% \label{systemdict:OPNAME}
%% \index{OPNAME@\onyxop{}{OPNAME}{}}
%% \item[{\onyxop{OPARGS}{OPNAME}{OPOUTS}}: ]
%% 	\begin{description}\item[]
%% 	\item[Input(s): ]
%% 		\begin{description}\item[]
%% 		\item[: ]
%% 		\end{description}
%% 	\item[Output(s): ]
%% 		\begin{description}\item[]
%% 		\item[: ]
%% 		\end{description}
%% 	\item[Errors(s): ]
%% 		\begin{description}\item[]
%% 		\item[\htmlref{stackunderflow}{stackunderflow}.]
%% 		\item[\htmlref{typecheck}{typecheck}.]
%% 		\end{description}
%% 	\item[Description: ]
%% 	\item[Example(s): ]\begin{verbatim}

%% 		\end{verbatim}
%% 	\end{description}

\begin{description}
\label{systemdict:sym_lp}
\index{(@\onyxop{}{(}{}}
\item[{\onyxop{--}{(}{fino}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a fino object onto ostack to denote the bottom of a stack
		that has not yet been constructed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (
onyx:1> pstack
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_rp}
\index{)@\onyxop{}{)}{}}
\item[{\onyxop{fino objects}{)}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object, usually created by the \onyxop{}{)}{}
			operator.
		\item[objects: ]
			0 or more objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedfino}{unmatchedfino}.]
		\end{description}
	\item[Description: ]
		Create a stack object and move all objects from ostack down to
		the first fino object to the new stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ()
onyx:1> 1 sprint
()
onyx:0> (1 2
onyx:3> pstack
2
1
-fino-
onyx:3> )
onyx:1> 1 sprint
(1 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lt}
\index{<@\onyxop{}{{\lt}}{}}
\item[{\onyxop{--}{{\lt}}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Begin a dictionary declaration.  See the
		\htmlref{\onyxop{}{>}{}}{systemdict:sym_gt} operator
		documentation for more details on dictionary construction.
	\item[Example(s): ]\begin{verbatim}

onyx:0> < 1 sprint
-mark-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_gt}
\index{>@\onyxop{}{{\gt}}{}}
\item[{\onyxop{mark kvpairs}{{\gt}}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[kvpairs: ]
			Zero or more pairs of non-mark objects, where the first
			is a key and the second is an associated value.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary that contains \oparg{kvpairs}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Construct a dictionary that contains \oparg{kvpairs}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <
onyx:1> $foo `foo'
onyx:3> $bar `bar'
onyx:5> $biz `biz'
onyx:7> $pop ~pop
onyx:9> >
onyx:1> pstack
<$pop --pop-- $biz `biz' $bar `bar' $foo `foo'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lb}
\index{[@\onyxop{}{{\lb}}{}}
\item[{\onyxop{--}{{\lb}}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Begin an array declaration.  See the
		\htmlref{\onyxop{}{]}{}}{systemdict:sym_rb} operator
		documentation for more details on array construction.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [ 1 sprint
-mark-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_rb}
\index{]@\onyxop{}{{\rb}}{}}
\item[{\onyxop{mark objects}{{\rb}}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[objects: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array that contains \oparg{objects}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Construct an array that contains all \oparg{objects} on ostack
		down to the first \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mark 1 2 3 ] 1 sprint
[1 2 3]
		\end{verbatim}
	\end{description}
\label{systemdict:abs}
\index{abs@\onyxop{}{abs}{}}
\item[{\onyxop{a}{abs}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Absolute value of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the absolute value of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 abs 1 sprint
5
onyx:0> -5 abs 1 sprint
5
onyx:0> 3.14 abs 1 sprint
3.140000e+00
onyx:0> -3.14 abs 1 sprint
3.140000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:accept}
\index{accept@\onyxop{}{accept}{}}
\item[{\onyxop{sock}{accept}{sock}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A listening socket.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket that is connected to a client.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Accept a connection and create a socket that is connected to a
		client.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' 7777 bindsocket
onyx:1> dup listen
onyx:1> dup accept
onyx:2> dup peername 1 sprint
<$family $AF_INET $address 2130706433 $port 33742>
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:add}
\index{add@\onyxop{}{add}{}}
\item[{\onyxop{a b}{add}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The sum of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the sum of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 2 add 1 sprint
4
onyx:0> -1 3 add 1 sprint
2
onyx:0> 2.0 3.1 add 1 sprint
5.100000e+00
onyx:0> -1.5 +3e1 add 1 sprint
2.850000e+01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:adn}
\index{adn@\onyxop{}{adn}{}}
\item[{\onyxop{obj \commas}{adn}{\commas obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\commas: ]
			Zero or more objects.
		\item[obj: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Rotate stack down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 adn pstack
1
3
2
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:and}
\index{and@\onyxop{}{and}{}}
\item[{\onyxop{a b}{and}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			and, otherwise their logical and.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise and of two integers, or the logical and of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false true and 1 sprint
false
onyx:0> true true and 1 sprint
true
onyx:0> 5 3 and 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:argv}
\index{argv@\onyxop{}{argv}{}}
\item[{\onyxop{--}{argv}{args}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of this program, and any additional
			array elements are the arguments that were passed during
			invocation.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the argument vector that was used to invoke this program.
	\item[Example(s): ]\begin{verbatim}

onyx:0> argv 1 sprint
[`/usr/local/bin/onyx']
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:array}
\index{array@\onyxop{}{array}{}}
\item[{\onyxop{length}{array}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[length: ]
			Non-negative number of array elements.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of \oparg{length} elements.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create an array of \oparg{length} elements.  The elements are
		initialized to null objects.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 array 1 sprint
[null null null]
onyx:0> 0 array 1 sprint
[]
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:atan}
\index{atan@\onyxop{}{atan}{}}
\item[{\onyxop{y x}{atan}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[y: ]
			An integer or real.
		\item[x: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Arctangent of $y/x$ in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the arctangent of $y/x$ in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 1 atan 1 sprint
7.853982e-01
onyx:0> 0 1 atan 1 sprint
0.000000e+00
onyx:0> -1.0 0 atan 1 sprint
-1.570796e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:aup}
\index{aup@\onyxop{}{aup}{}}
\item[{\onyxop{\commas obj}{aup}{obj \commas}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\commas: ]
			Zero or more objects.
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Rotate stack up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 aup pstack
2
1
3
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:bdup}
\index{bdup@\onyxop{}{bdup}{}}
\item[{\onyxop{obj \commas}{bdup}{obj \commas dup}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\item[dup: ]
			A duplicate of \oparg{obj}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the bottom object on ostack and put it on
		top of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3
onyx:3> bdup pstack
1
3
2
1
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:begin}
\index{begin@\onyxop{}{begin}{}}
\item[{\onyxop{dict}{begin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{dict} onto dstack, thereby adding its keys to the
		namespace.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <$foo `foo'> begin
onyx:0> foo 1 sprint
`foo'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:bind}
\index{bind@\onyxop{}{bind}{}}
\item[{\onyxop{proc}{bind}{proc}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			A procedure (array).  \oparg{proc} will be bound even if
			it is literal, but contained literal arrays will not be
			recursively bound.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[proc: ]
			The same procedure as was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Recursively bind unbound procedures.  Executable names within a
		procedure are replaced with their values if defined in dstack,
		in any of the following cases:
		\begin{itemize}
		\item{The value is a literal object.}
		\item{The value is an executable or evaluatable operator.}
		\item{The value is an executable or evaluatable hook.}
		\item{The value is an executable or evaluatable array.}
		\end{itemize}

		Binding has a large positive impact on performance, since name
		lookups are thereafter avoided.  However, binding is not done by
		default because there are situations where it is useful to leave
		procedures unbound:
		\begin{itemize}
		\item{Debugging is easier, since the names associated with
		objects are still available.}
		\item{Behavior is more dynamic.  It is possible to replace a
		definition on dstack and have it immediately take effect on
		unbound procedures.  Note however that care must be taken
		when relying on this, since binding is recursive, and a lack of
		complete understanding of what procedures reference each other
		can result in undesired bound procedures.  For this reason, it
		is generally best to make dynamic behavior explicit by using
		evaluatable names.}
		\item{There are situations where a program needs to do some
		setup before binding a procedure, and providing manual control
		over when binding happens allows more sophisticated use of
		binding.}
		\end{itemize}
	\item[Example(s): ]\begin{verbatim}

onyx:0> {pop sprint {pop sprint}}
onyx:1> dup 2 sprint
{pop sprint {pop sprint}}
onyx:1> bind
onyx:1> dup 2 sprint
{--pop-- _{sprints --print-- `\n' --print-- --flush--}_ {--pop-- -array-}}
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:bindsocket}
\index{bindsocket@\onyxop{}{bindsocket}{}}
\item[{\onyxop{sock addr port}{bindsocket}{--}}: ]
\item[{\onyxop{sock addr}{bindsocket}{--}}: ]
\item[{\onyxop{sock path}{bindsocket}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[addr: ]
			An IPv4 address or DNS hostname.
		\item[port: ]
			An IPv4 port number.  If not specified, the OS chooses a
			port number.
		\item[path: ]
			A filesystem path for a Unix-domain socket.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Bind an address/port to an IPv4 socket, or a filesystem path to
		a Unix-domain socket.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' 7777 bindsocket
onyx:1> dup sockname 1 sprint
<$family $AF_INET $address 2130706433 $port 7777>
onyx:1> close
onyx:0> $AF_LOCAL $SOCK_STREAM socket
onyx:1> dup `/tmp/socket' bindsocket
onyx:1> dup sockname 1 sprint
<$family $AF_LOCAL $path `/tmp/socket'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:bpop}
\index{bpop@\onyxop{}{bpop}{}}
\item[{\onyxop{obj \commas}{bpop}{\commas}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\commas: ]
			Zero or more objects.
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\commas: ]
			Zero or more objects.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Remove the bottom object from ostack and discard it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2
onyx:2> bpop pstack
2
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:broadcast}
\index{broadcast@\onyxop{}{broadcast}{}}
\item[{\onyxop{condition}{broadcast}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Signal all threads that are waiting on \oparg{condition}.  If
		there are no waiters, this operator has no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch broadcast unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:bytesavailable}
\index{bytesavailable@\onyxop{}{bytesavailable}{}}
\item[{\onyxop{file}{bytesavailable}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of buffered readable bytes.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the number of buffered readable bytes that can be read
		without the possibility of blocking.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup `Goodbye\n' write
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1> dup bytesavailable 1 sprint
8
onyx:1>
	\end{verbatim}
	\end{description}
\label{systemdict:cat}
\index{cat@\onyxop{}{cat}{}}
\item[{\onyxop{[a] [b]}{cat}{[a b]}}: ]
\item[{\onyxop{(a) (b)}{cat}{(a b)}}: ]
\item[{\onyxop{`a' `b'}{cat}{`ab'}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An array, stack, or string.
		\item[b: ]
			An array, stack, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[ab: ]
			The catenation of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Catenate two arrays, strings, or stacks.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b'] cat
onyx:1> 1 sprint
[`a' `b']
onyx:0> (`a') (`b') cat
onyx:1> 1 sprint
(`a' `b')
onyx:0> `a' `b' cat
onyx:1> 1 sprint
`ab'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cd}
\index{cd@\onyxop{}{cd}{}}
\item[{\onyxop{path}{cd}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Change the present working directory to \oparg{path}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd 1 sprint
`/usr/local'
onyx:0> `bin' cd
onyx:0> pwd 1 sprint
`/usr/local/bin'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ceiling}
\index{ceiling@\onyxop{}{ceiling}{}}
\item[{\onyxop{a}{ceiling}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer ceiling of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the integer ceiling of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 ceiling 1 sprint
-1
onyx:0> -1.49 ceiling 1 sprint
-1
onyx:0> 0 ceiling 1 sprint
0
onyx:0> 1.49 ceiling 1 sprint
2
onyx:0> 1.51 ceiling 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:chmod}
\index{chmod@\onyxop{}{chmod}{}}
\item[{\onyxop{file/filename mode}{chmod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[mode: ]
			An integer that represents a Unix file mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8@755 mkdir 
onyx:0> `/tmp/tdir' status $mode get 1 sprint
16877
onyx:0> `/tmp/tdir' `r' open 
onyx:1> dup 8@555 chmod
onyx:1> `/tmp/tdir' status $mode get 1 sprint
16749
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:chown}
\index{chown@\onyxop{}{chown}{}}
\item[{\onyxop{file/filename uid gid}{chown}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[uid: ]
			An integer that represents a user ID.
		\item[gid: ]
			An integer that represents a group ID.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Change the owner and group of a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8@755 mkdir
onyx:0> `/tmp/tdir' status 
onyx:1> dup $uid get 1 sprint
1001
onyx:1> $gid get 1 sprint
0
onyx:0> `/tmp/tdir' 1001 1001 chown
onyx:0> `/tmp/tdir' status
onyx:1> dup $uid get 1 sprint
1001
onyx:1> $gid get 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:chroot}
\index{chroot@\onyxop{}{chroot}{}}
\item[{\onyxop{path}{chroot}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Change the root directory to \oparg{path}.  This operator
		requires super-user priviledges.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd 1 sprint
`/home/jasone/cw/devroot'
onyx:0> `/home/jasone' chroot
onyx:0> pwd 1 sprint
`/cw/devroot'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:clear}
\index{clear@\onyxop{}{clear}{}}
\item[{\onyxop{objects}{clear}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			All objects on ostack.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Pop all objects off of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 pstack
3
2
1
onyx:3> clear pstack
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cleartomark}
\index{cleartomark@\onyxop{}{cleartomark}{}}
\item[{\onyxop{mark \dots}{cleartomark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			Zero or more objects.
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from ostack down to and including the topmost
		mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 mark 1 0 pstack
0
1
-mark-
3
onyx:4> cleartomark pstack
3
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:close}
\index{close@\onyxop{}{close}{}}
\item[{\onyxop{file}{close}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Close a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> close
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:condition}
\index{condition@\onyxop{}{condition}{}}
\item[{\onyxop{--}{condition}{condition}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a condition object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition 1 sprint
-condition-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:connect}
\index{connect@\onyxop{}{connect}{}}
\item[{\onyxop{sock addr port}{connect}{--}}: ]
\item[{\onyxop{sock path}{connect}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[addr: ]
			An IPv4 address or DNS hostname.
		\item[port: ]
			An IPv4 port number.  If not specified, the OS chooses a
			port number.
		\item[path: ]
			A filesystem path for a Unix-domain socket.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Connect \oparg{sock}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' 7777 connect
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:copy}
\index{copy@\onyxop{}{copy}{}}
\item[{\onyxop{srcarray dstarray}{copy}{dstsubarray}}: ]
\item[{\onyxop{srcdict dstdict}{copy}{dstdict}}: ]
\item[{\onyxop{srcstack dststack}{copy}{dststack}}: ]
\item[{\onyxop{srcstring dststring}{copy}{dstsubstring}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[srcarray: ]
			An array object.
		\item[srcdict: ]
			A dict object.
		\item[srcstack: ]
			A stack object.
		\item[srcstring: ]
			A string object.
		\item[dstarray: ]
			An array object, at least as long as \oparg{srcarray}.
		\item[dstdict: ]
			A dict object.
		\item[dststack: ]
			A stack object.
		\item[dststring: ]
			A string object, at least as long as \oparg{srcstring}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dstsubarray: ]
			A subarray of \oparg{dstarray}, with the same contents
			as \oparg{srcarray}.
		\item[dstdict: ]
			The same object as the input \oparg{dstdict}, but with
			the contents of \oparg{srcdict} inserted.
		\item[dststack: ]
			The same object as the input \oparg{dststack}, but with
			the contents of \oparg{srcstack} pushed.
		\item[dstsubstring: ]
			A substring of \oparg{dststring}, with the same contents
			as \oparg{srcstring}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Copy from one object to another.  Array and string copying are
		destructive; dictionary and stack copying are not.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b' `c'] copy 1 sprint
[`a']
onyx:0> <$foo `foo'> <$bar `bar'> copy 1 sprint
<$bar `bar' $foo `foo'>
onyx:1> (1 2) (3 4) copy 1 sprint
(3 4 1 2)
onyx:1> `a' `bc' copy 1 sprint
`a'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:cos}
\index{cos@\onyxop{}{cos}{}}
\item[{\onyxop{a}{cos}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Cosine of \oparg{a} in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the cosine of \oparg{a} in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 cos 1 sprint
1.000000e+00
onyx:0> 3.14 cos 1 sprint
-9.999987e-01
onyx:0> 3.1415927 cos 1 sprint
-1.000000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:count}
\index{count@\onyxop{}{count}{}}
\item[{\onyxop{--}{count}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects on ostack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 1 0 count pstack
3
0
1
2
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:countdstack}
\index{countdstack@\onyxop{}{countdstack}{}}
\item[{\onyxop{--}{countdstack}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of dictionaries on dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of dictionaries on dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> countdstack 1 sprint
4
onyx:0> dict begin
onyx:0> countdstack 1 sprint
5
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:countestack}
\index{countestack@\onyxop{}{countestack}{}}
\item[{\onyxop{--}{countestack}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects currently on the execution stack
			(recursion depth).
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the current number of objects on the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> countestack 1 sprint
3
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:counttomark}
\index{counttomark@\onyxop{}{counttomark}{}}
\item[{\onyxop{mark \dots}{counttomark}{mark \dots count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			Zero or more objects.
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			\oparg{count} objects.
		\item[mark: ]
			The same mark that was passed in.
		\item[count: ]
			The depth of \oparg{mark} on ostack.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 mark 2 1 0 counttomark 1 sprint
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:currentdict}
\index{currentdict@\onyxop{}{currentdict}{}}
\item[{\onyxop{--}{currentdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			Topmost stack on dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the topmost dictionary on dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <$foo `foo'> begin 
onyx:0> currentdict 1 sprint
<$foo `foo'>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:currentlocking}
\index{currentlocking@\onyxop{}{currentlocking}{}}
\item[{\onyxop{--}{currentlocking}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, new objects are created with implicit locking
			disabled.  Otherwise, new objects are created with
			implicit locking enabled.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the current implicit locking mode.  See
		Section~\ref{sec:onyx_implicit_synchronization} for implicit
		synchronization details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currentlocking 1 sprint
false
onyx:0> true setlocking
onyx:0> currentlocking 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvds}
\index{cvds@\onyxop{}{cvds}{}}
\item[{\onyxop{real precision}{cvds}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real.
		\item[precision: ]
			Number of digits after the decimal point to show.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{real} in decimal form
			with \oparg{precision} digits of decimal precision.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{real} to a string representation in decimal
		notation, with \oparg{precision} digits of decimal precision.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42.3 0 cvds 1 sprint
`42'
onyx:0> 42.3 1 cvds 1 sprint
`42.3'
onyx:0> -42.3 4 cvds 1 sprint
`-42.3000'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cve}
\index{cve@\onyxop{}{cve}{}}
\item[{\onyxop{obj}{cve}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The same object that was passed in, but with the
			evaluatable attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the evaluatable attribute for \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] cve 1 sprint
_{1 2 3}_
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cves}
\index{cves@\onyxop{}{cves}{}}
\item[{\onyxop{real precision}{cves}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real.
		\item[precision: ]
			Number of digits after the decimal point to show.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{real} in exponential
			form with \oparg{precision} digits of decimal precision.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{real} to a string representation in exponential
		notation, with \oparg{precision} digits of decimal precision.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42.3 0 cves 1 sprint
`4e+01'
onyx:0> 42.3 1 cves 1 sprint
`4.2e+01'
onyx:0> 42.3 2 cves 1 sprint
`4.23e+01'
onyx:0> -42.3 5 cves 1 sprint
`-4.23000e+01'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvlit}
\index{cvlit@\onyxop{}{cvlit}{}}
\item[{\onyxop{obj}{cvlit}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The same object that was passed in, but with the literal
			attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the literal attribute for \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} cvlit 1 sprint
[1 2 3]
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvn}
\index{cvn@\onyxop{}{cvn}{}}
\item[{\onyxop{string}{cvn}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			A literal name that corresponds to \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{string} to a literal name.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `foo' cvn 1 sprint
$foo
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvrs}
\index{cvrs@\onyxop{}{cvrs}{}}
\item[{\onyxop{integer radix}{cvrs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer.
		\item[radix: ]
			A numerical base, from 2 to 36, inclusive.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{integer} in base
			\oparg{radix}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{integer} to a string representation in base
		\oparg{radix}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42 2 cvrs 1 sprint
`101010'
onyx:0> 42 16 cvrs 1 sprint
`2a'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvs}
\index{cvs@\onyxop{}{cvs}{}}
\item[{\onyxop{obj}{cvs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{obj}.  The string
			depends on the type of \oparg{obj}:
			\begin{description}
			\item[boolean: ] {\tt `true'} or  {\tt `false'}.
			\item[name: ] The string representation of the name.
			\item[integer: ] The integer in base 10.
			\item[operator: ] The string representation of the
			operator name or {\tt `-operator-'}.
			\item[real: ] The real in exponential notation.
			\item[string: ] A printable representation of
			\oparg{obj}.  The result can be evaluated to produce
			the original string.
			\item[Other types: ] {\tt `--nostringval--'}.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{obj} to a string representation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true cvs 1 sprint
`true'
onyx:0> $foo cvs 1 sprint
`foo'
onyx:0> 42 cvs 1 sprint
`42'
onyx:0> ~pop cvs 1 sprint
`pop'
onyx:0> 42.0 cvs 1 sprint
`4.200000e+01'
onyx:0> `foo\nbar\\biz\`baz' cvs 1 sprint
`\`foo\\nbar\\\\biz\\\`baz\''
onyx:0> mutex cvs 1 sprint
`--nostringval--'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvx}
\index{cvx@\onyxop{}{cvx}{}}
\item[{\onyxop{obj}{cvx}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The same object that was passed in, but with the
			executable attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the executable attribute for \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] cvx 1 sprint
{1 2 3}
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:dec}
\index{dec@\onyxop{}{dec}{}}
\item[{\onyxop{a}{dec}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			$a - 1$.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Subtract one from \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 dec 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:def}
\index{def@\onyxop{}{def}{}}
\item[{\onyxop{key val}{def}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			An object.
		\item[val: ]
			A value associated with \oparg{key}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Define \oparg{key} with associated value \oparg{val} in the
		topmost dictionary on dstack.  If \oparg{key} is already defined
		in that dictionary, the old definition is replaced.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $foo `foo' def
onyx:0> foo 1 sprint
`foo'
onyx:0> $foo `FOO' def
onyx:0> foo 1 sprint
`FOO'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:detach}
\index{detach@\onyxop{}{detach}{}}
\item[{\onyxop{thread}{detach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Detach \oparg{thread} so that its resources will be
		automatically reclaimed after it exits.  A thread may only be
		detached or joined once; any attempt to do so more than once
		results in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint self detach} thread
3
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:dict}
\index{dict@\onyxop{}{dict}{}}
\item[{\onyxop{--}{dict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			An empty dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create an empty dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> dict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:die}
\index{die@\onyxop{}{die}{}}
\item[{\onyxop{status}{die}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[status: ]
			A integer from 0 to 255 that is used as the program exit
			code.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Exit the program with exit code \oparg{status}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 die
		\end{verbatim}
	\end{description}
\label{systemdict:dirforeach}
\index{dirforeach@\onyxop{}{dirforeach}{}}
\item[{\onyxop{path proc}{dirforeach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\item[proc: ]
			An object to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		For each entry in the directory represented by \oparg{path}
		except for ``.'' and ``..'', push a string that represents the
		entry onto ostack and execute \oparg{proc}.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd {1 sprint} dirforeach
`CVS'
`.cvsignore'
`Cookfile'
`Cookfile.inc'
`latex'
`Cookfile.inc.in'
onyx:0> pwd {`Cookfile.inc' search
     {pop `Yes: ' print 1 sprint pop exit}
     {`Not: ' print 1 sprint} ifelse
} dirforeach
Not: `CVS'
Not: `.cvsignore'
Not: `Cookfile'
Yes: `Cookfile.inc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:div}
\index{div@\onyxop{}{div}{}}
\item[{\onyxop{a b}{div}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			A non-zero integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The quotient of \oparg{a} divided by \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
		Return the quotient of \oparg{a} divided by \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 div 1 sprint
2.000000e+00
onyx:0> 5 2.0 div 1 sprint
2.500000e+00
onyx:0> 5.0 0 div
Error $undefinedresult
ostack: (5.000000e+00 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --div--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:dn}
\index{dn@\onyxop{}{dn}{}}
\item[{\onyxop{a b c}{dn}{b c a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\item[c: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			An object.
		\item[c: ]
			An object.
		\item[a: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Rotate the top three objects on ostack down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' `d' dn pstack
`b'
`d'
`c'
`a'
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A snapshot of dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a snapshot of dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> dstack 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:dup}
\index{dup@\onyxop{}{dup}{}}
\item[{\onyxop{obj}{dup}{obj dup}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The same object that was passed in.
		\item[dup: ]
			A duplicate of \oparg{obj}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the top object on ostack.  For composite
		objects, the new object is a reference to the same composite
		object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 dup pstack
1
1
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:echeck}
\index{echeck@\onyxop{}{echeck}{}}
\item[{\onyxop{obj}{echeck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{obj} has the evaluatable attribute,
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Check \oparg{obj} for evaluatable attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} cve
onyx:1> dup 1 sprint
_{1 2 3}_
onyx:1> echeck 1 sprint
true
onyx:0> {1 2 3} echeck 1 sprint
false
onyx:0> [1 2 3] echeck 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:egid}
\index{egid@\onyxop{}{egid}{}}
\item[{\onyxop{--}{egid}{gid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[gid: ]
			Process's effective group ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's effective group ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> egid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:end}
\index{end@\onyxop{}{end}{}}
\item[{\onyxop{--}{end}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Pop the topmost dictionary off dstack, thereby removing its
		contents from the namespace.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <$foo `foo'> begin
onyx:0> foo 1 sprint
`foo'
onyx:0> end
onyx:0> foo 1 sprint
Error $undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      foo
1:      -file-
2:      --start--
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:envdict}
\index{envdict@\onyxop{}{envdict}{}}
\item[{\onyxop{--}{envdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get envdict.  See Section~\ref{sec:envdict} for details on
		envdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> envdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:eq}
\index{eq@\onyxop{}{eq}{}}
\item[{\onyxop{a b}{eq}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for equality.  Equality has the following
		meaning, depending on the types of \oparg{a} and \oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are equal iff they refer to
		the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are equal iff they
		refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are equal iff they
		are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are equal iff they
		are the same value.
		\item[integer, real: ] \oparg{a} and \oparg{b} are equal iff
		they are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex eq 1 sprint
false
onyx:0> mutex dup eq 1 sprint
true
onyx:0> $foo `foo' eq 1 sprint
true
onyx:0> true true eq 1 sprint
true
onyx:0> true false eq 1 sprint
false
onyx:0> 1 1 eq 1 sprint
true
onyx:0> 1 2 eq 1 sprint
false
onyx:0> 1.0 1 eq 1 sprint
true
onyx:0> 1.0 1.1 eq 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the execution stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:euid}
\index{euid@\onyxop{}{euid}{}}
\item[{\onyxop{--}{euid}{uid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[uid: ]
			Process's effective user ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's effective user ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> euid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:eval}
\index{eval@\onyxop{}{eval}{}}
\item[{\onyxop{obj}{eval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate object.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ``hi' 1 sprint' cvx eval
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exch}
\index{exch@\onyxop{}{exch}{}}
\item[{\onyxop{a b}{exch}{b a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			The same object that was passed in.
		\item[a: ]
			The same object that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 pstack
2
1
onyx:2> exch pstack
1
2
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:exec}
\index{exec@\onyxop{}{exec}{}}
\item[{\onyxop{args}{exec}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of the program to invoke, and any additional
			array elements are passed as command line arguments to
			the invoked program.
		\end{description}
	\item[Output(s): ] None (this operator does not return).
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Overlay a new program and execute it.  The current contents of
		envdict are used to construct the new program's environment.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Old program'
onyx:1> [`/usr/local/bin/onyx'] exec
Canonware Onyx, version 1.0.0.
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exit}
\index{exit@\onyxop{}{exit}{}}
\item[{\onyxop{--}{exit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Exit the innermost enclosing looping context immediately.
		This operator can be called within the looping context of
		\htmlref{\onyxop{}{for}{}}{systemdict:for},
		\htmlref{\onyxop{}{repeat}{}}{systemdict:repeat},
		\htmlref{\onyxop{}{while}{}}{systemdict:while},
		\htmlref{\onyxop{}{until}{}}{systemdict:until},
		\htmlref{\onyxop{}{loop}{}}{systemdict:loop},
		\htmlref{\onyxop{}{foreach}{}}{systemdict:foreach}, and
		\htmlref{\onyxop{}{dirforeach}{}}{systemdict:dirforeach}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {`hi' 1 sprint exit `bye' 1 sprint} loop
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exp}
\index{exp@\onyxop{}{exp}{}}
\item[{\onyxop{a b}{exp}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} to the \oparg{b} power.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return \oparg{a} to the \oparg{b} power.  If a negative exponent
		is specified, the result will always be a real, even if both
		arguments are integers.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 0 exp 1 sprint
1
onyx:0> 5 1 exp 1 sprint
5
onyx:0> 5 2 exp 1 sprint
25
onyx:0> -5 3 exp 1 sprint
-125
onyx:0> 5 -3 exp 1 sprint
8.000000e-03
onyx:0> 2.1 3.5 exp 1 sprint
1.342046e+01
onyx:0> 100 .01 exp 1 sprint
1.000000e+02
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:false}
\index{false@\onyxop{}{false}{}}
\item[{\onyxop{--}{false}{false}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[false: ]
			The boolean value false.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return false.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:floor}
\index{floor@\onyxop{}{floor}{}}
\item[{\onyxop{a}{floor}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer floor of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the integer floor of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 floor 1 sprint
-2
onyx:0> -1.49 floor 1 sprint
-2
onyx:0> 0 floor 1 sprint
0
onyx:0> 1.49 floor 1 sprint
1
onyx:0> 1.51 floor 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:flush}
\index{flush@\onyxop{}{flush}{}}
\item[{\onyxop{--}{flush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\end{description}
	\item[Description: ]
		Flush any buffered data associated with stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print
onyx:0> flush
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:flushfile}
\index{flushfile@\onyxop{}{flushfile}{}}
\item[{\onyxop{file}{flushfile}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Flush any buffered data associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print
onyx:0> stdout flushfile
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:for}
\index{for@\onyxop{}{for}{}}
\item[{\onyxop{init inc limit proc}{for}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[init: ]
			Initial value of control variable.
		\item[inc: ]
			Amount to increment control variable by at the end of
			each iteration.
		\item[limit: ]
			Inclusive upper bound for control variable if less than
			or equal to \oparg{init}, otherwise inclusive lower
			bound for control variable.
		\item[proc: ]
			An object.
		\end{description}
	\item[Output(s): ]  At the beginning of each iteration, the current
		value of the control variable is pushed onto ostack.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Iteratively evaluate \oparg{proc}, pushing a control variable
		onto ostack at the beginning of each iteration, until the
		control variable has exceeded \oparg{limit}.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 3 {1 sprint} for
0
1
2
3
onyx:0> 0 -1 -3 {1 sprint} for
0
-1
-2
-3
onyx:0> 0 2 7 {1 sprint} for
0
2
4
6
onyx:0> 0 1 1000 {dup 1 sprint 3 eq {exit} if} for
0
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:foreach}
\index{foreach@\onyxop{}{foreach}{}}
\item[{\onyxop{array proc}{foreach}{--}}: ]
\item[{\onyxop{dict proc}{foreach}{--}}: ]
\item[{\onyxop{stack proc}{foreach}{--}}: ]
\item[{\onyxop{string proc}{foreach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[stack: ]
			A stack object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		For each entry in the first input argument (\oparg{array},
		\oparg{dict}, \oparg{stack}, or \oparg{string}), push the entry
		onto ostack and execute \oparg{proc}.  This operator supports
		the \htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2] {1 sprint} foreach
1
2
onyx:0> <$foo `foo' $bar `bar'> {pstack clear} foreach
`bar'
$bar
`foo'
$foo
onyx:0> (1 2) {pstack clear} foreach
2
1
onyx:0> `ab' {pstack clear} foreach
97
98
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:forkexec}
\index{forkexec@\onyxop{}{forkexec}{}}
\item[{\onyxop{args}{forkexec}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of the program to invoke, and any additional
			array elements are passed as command line arguments to
			the invoked program.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier for the new process, or 0 if the
			child process.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Fork and exec a new process.  The current contents of envdict
		are used to construct the new program's environment.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`/bin/date'] forkexec dup 1 sprint waitpid 1 sprint
6516
Sat Jul 13 20:47:54 PDT 2002
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gcdict}
\index{gcdict@\onyxop{}{gcdict}{}}
\item[{\onyxop{--}{gcdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get gcdict.  See Section~\ref{sec:gcdict} for details on
		gcdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ge}
\index{ge@\onyxop{}{ge}{}}
\item[{\onyxop{a b}{ge}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 ge 1 sprint
false
onyx:0> 1 1 ge 1 sprint
true
onyx:0> 2 1 ge 1 sprint
true
onyx:0> 1 1.1 ge 1 sprint
false
onyx:0> 1.1 1.1 ge 1 sprint
true
onyx:0> 1.1 1 ge 1 sprint
true
onyx:0> `a' `b' ge 1 sprint
false
onyx:0> `a' `a' ge 1 sprint
true
onyx:0> `b' `a' ge 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:get}
\index{get@\onyxop{}{get}{}}
\item[{\onyxop{array index}{get}{obj}}: ]
\item[{\onyxop{dict key}{get}{value}}: ]
\item[{\onyxop{string index}{get}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[string: ]
			A string object.
		\item[index: ] Offset of \oparg{array} element or \oparg{string}
		element.
		\item[key: ]
			A key in \oparg{dict}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The object in \oparg{array} at offset \oparg{index}.
		\item[value: ]
			The value in \oparg{dict} corresponding to \oparg{key}.
		\item[integer: ]
			The ascii value of the character in \oparg{string} at
			offset \oparg{index}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Get an element of \oparg{array}, a value in \oparg{dict}, or an
		element of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a' `b' `c'] 1 get 1 sprint
`b'
onyx:0> <$foo `foo' $bar `bar'> $bar get 1 sprint
`bar'
onyx:0> `abc' 1 get 1 sprint
98
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:getinterval}
\index{getinterval@\onyxop{}{getinterval}{}}
\item[{\onyxop{array index length}{getinterval}{subarray}}: ]
\item[{\onyxop{string index length}{getinterval}{substring}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[string: ]
			A string object.
		\item[index: ]
			The offset into \oparg{array} or \oparg{string} to get
			the interval from.
		\item[length: ]
			The length of the interval in \oparg{array} or
			\oparg{string} to get.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[subarray: ]
			A subarray of \oparg{array} at offset \oparg{index} and
			of length \oparg{length}.
		\item[substring: ]
			A substring of \oparg{string} at offset \oparg{index}
			and of length \oparg{length}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get an interval of \oparg{array} or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [0 1 2 3] 1 2 getinterval 1 sprint
[1 2]
onyx:0> `abcd' 1 2 getinterval 1 sprint
`bc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gid}
\index{gid@\onyxop{}{gid}{}}
\item[{\onyxop{--}{gid}{gid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[gid: ]
			Process's group ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's group ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:globaldict}
\index{globaldict@\onyxop{}{globaldict}{}}
\item[{\onyxop{--}{globaldict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get globaldict.  See Section~\ref{sec:globaldict} for details on
		globaldict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> globaldict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gstderr}
\index{gstderr@\onyxop{}{gstderr}{}}
\item[{\onyxop{--}{gstderr}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the global stderr.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the global stderr that is inherited by new threads.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gstderr pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:gstdin}
\index{gstdin@\onyxop{}{gstdin}{}}
\item[{\onyxop{--}{gstdin}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the global stdin.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the global stdin that is inherited by new threads.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gstdin pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:gstdout}
\index{gstdout@\onyxop{}{gstdout}{}}
\item[{\onyxop{--}{gstdout}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the global stdout.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the global stdout that is inherited by new threads.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gstdout pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:gt}
\index{gt@\onyxop{}{gt}{}}
\item[{\onyxop{a b}{gt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 1 gt 1 sprint
false
onyx:0> 2 1 gt 1 sprint
true
onyx:0> 1.1 1.1 gt 1 sprint
false
onyx:0> 1.1 1 gt 1 sprint
true
onyx:0> `a' `a' gt 1 sprint
false
onyx:0> `b' `a' gt 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:hooktag}
\index{hooktag@\onyxop{}{hooktag}{}}
\item[{\onyxop{hook}{hooktag}{tag}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[tag: ]
			The tag associated with \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the tag associated with \oparg{hook}.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:ibdup}
\index{ibdup@\onyxop{}{ibdup}{}}
\item[{\onyxop{\dots obj \commas index}{ibdup}{\dots obj \commas dup}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			\oparg{index} objects.
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\item[index: ]
			Offset from bottom of ostack, counting from 0.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			\oparg{index} objects.
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\item[dup: ]
			Duplicate of \oparg{obj}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on ostack that is at
		offset \oparg{index} from the bottom of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:4> 2 ibdup pstack
2
3
2
1
0
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:ibpop}
\index{ibpop@\onyxop{}{ibpop}{}}
\item[{\onyxop{\dots obj \commas index}{ibpop}{\dots \commas}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			\oparg{index} objects.
		\item[obj: ]
			An object.
		\item[\commas: ]
			Zero or more objects.
		\item[index: ]
			Offset from bottom of ostack, counting from 0.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			\oparg{index} objects.
		\item[\commas: ]
			Zero or more objects.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the object from ostack that is at offset
		\oparg{index} from the bottom of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 2 3
onyx:4> 2 ibpop pstack
3
1
0
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:idiv}
\index{idiv@\onyxop{}{idiv}{}}
\item[{\onyxop{a b}{idiv}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The integer quotient of \oparg{a} divided by \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
		Return the integer quotient of \oparg{a} divided by \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 idiv 1 sprint
2
onyx:0> 5 2 idiv 1 sprint
2
onyx:0> 5 0 idiv
Error $undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --idiv--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:idup}
\index{idup@\onyxop{}{idup}{}}
\item[{\onyxop{obj \dots index}{idup}{obj \dots dup}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[index: ]
			Offset from top of ostack, counting from 0, not counting
			\oparg{index}), of the object to duplicate on ostack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The same object that was passed in.
		\item[dup: ]
			A duplicate of \oparg{obj}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on ostack at \oparg{index}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 2 idup pstack
2
0
1
2
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:if}
\index{if@\onyxop{}{if}{}}
\item[{\onyxop{boolean obj}{if}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{obj} if \oparg{boolean} is true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes' 1 sprint} if
`yes'
onyx:0> false {`yes' 1 sprint} if
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ifelse}
\index{ifelse@\onyxop{}{ifelse}{}}
\item[{\onyxop{boolean a b}{ifelse}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{a} if \oparg{boolean} is true, evaluate
		\oparg{b} otherwise.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes'}{`no'} ifelse 1 sprint
`yes'
onyx:0> false {`yes'}{`no'} ifelse 1 sprint
`no'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:inc}
\index{inc@\onyxop{}{inc}{}}
\item[{\onyxop{a}{inc}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			$a + 1$.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Add one to \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 inc 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:iobuf}
\index{iobuf@\onyxop{}{iobuf}{}}
\item[{\onyxop{file}{iobuf}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The size in bytes of the I/O buffer associated with
			\oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the size of the I/O buffer associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout iobuf 1 sprint
512
onyx:0> stderr iobuf 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ipop}
\index{ipop@\onyxop{}{ipop}{}}
\item[{\onyxop{obj \dots index}{ipop}{\dots}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\item[index: ]
			Offset from top of ostack, counting from 0, not counting
			\oparg{index}), of the object to remove from ostack.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the \oparg{obj} at \oparg{index} from ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 1 0 
onyx:3> 1 ipop pstack
0
2
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the index stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the index stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> istack 1 sprint
(0 0 0)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:join}
\index{join@\onyxop{}{join}{}}
\item[{\onyxop{thread}{join}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for \oparg{thread} to exit.  A thread may only be detached
		or joined once; any attempt to do so more than once results in
		undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint} thread join `Done\n' print flush
3
Done
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:known}
\index{known@\onyxop{}{known}{}}
\item[{\onyxop{dict key}{known}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\item[key: ]
			A key to look for in \oparg{dict}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{key} is defined in \oparg{dict}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Check whether \oparg{key} is defined in \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:1> <$foo `foo'> $foo known 1 sprint
true
onyx:1> <$foo `foo'> $bar known 1 sprint
false
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:lcheck}
\index{lcheck@\onyxop{}{lcheck}{}}
\item[{\onyxop{obj}{lcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An array, dict, file, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{obj} is implicitly locked, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Check if \oparg{obj} is implicitly locked.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false setlocking
onyx:0> [1 2 3] lcheck 1 sprint
false
onyx:0> true setlocking
onyx:0> [1 2 3] lcheck 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:le}
\index{le@\onyxop{}{le}{}}
\item[{\onyxop{a b}{le}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 le 1 sprint
true
onyx:0> 1 1 le 1 sprint
true
onyx:0> 2 1 le 1 sprint
false
onyx:0> 1 1.1 le 1 sprint
true
onyx:0> 1.1 1.1 le 1 sprint
true
onyx:0> 1.1 1 le 1 sprint
false
onyx:0> `a' `b' le 1 sprint
true
onyx:0> `a' `a' le 1 sprint
true
onyx:0> `b' `a' le 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:length}
\index{length@\onyxop{}{length}{}}
\item[{\onyxop{array}{length}{count}}: ]
\item[{\onyxop{dict}{length}{count}}: ]
\item[{\onyxop{name}{length}{count}}: ]
\item[{\onyxop{string}{length}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[name: ]
			A name object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of elements in \oparg{array}, number of entries
			in \oparg{dict}, number of characters in \oparg{name},
			or number of characters in \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the umber of elements in \oparg{array}, number of entries in
		\oparg{dict}, number of characters in \oparg{name}, or number of
		characters in \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] length 1 sprint
3
onyx:0> <$foo `foo' $bar `bar'> length 1 sprint
2
onyx:0> $foo length 1 sprint
3
onyx:0> `foo' length 1 sprint
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:link}
\index{link@\onyxop{}{link}{}}
\item[{\onyxop{filename linkname}{link}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[linkname: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a hard link from \oparg{linkname} to \oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' `/tmp/bar' link
onyx:0> `/tmp/bar' `r' open
onyx:1> readline
onyx:2> pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:listen}
\index{listen@\onyxop{}{listen}{}}
\item[{\onyxop{sock backlog}{listen}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[backlog: ]
			Maximum backlog of connections to listen for.  If not
			specified, the maximum backlog is used.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Listen for connections on a socket.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' 7777 bindsocket
onyx:1> dup listen
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:ln}
\index{ln@\onyxop{}{ln}{}}
\item[{\onyxop{a}{ln}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Natural logarithm of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the natural logarithm of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 ln 1 sprint
1.609438e+00
onyx:0> 8.5 ln 1 sprint
2.140066e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:load}
\index{load@\onyxop{}{load}{}}
\item[{\onyxop{key}{load}{val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A key to look up in dstack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[val: ]
			The value associated with the topmost definition of
			\oparg{key} in dstack.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Get the topmost definition of \oparg{key} in dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:1> <$foo `foo'> begin
onyx:1> <$foo `FOO'> begin
onyx:1> $foo load 1 sprint
`FOO'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:lock}
\index{lock@\onyxop{}{lock}{}}
\item[{\onyxop{mutex}{lock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Acquire \oparg{mutex}, waiting if necessary.  Attempting to
		acquire \oparg{mutex} recursively will result in undefined
		behavior (likely deadlock or crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup lock unlock
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:log}
\index{log@\onyxop{}{log}{}}
\item[{\onyxop{a}{log}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Base 10 logarithm of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the base 10 logarithm of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 log 1 sprint
6.989700e-01
onyx:0> 8.5 log 1 sprint
9.294189e-01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:loop}
\index{loop@\onyxop{}{loop}{}}
\item[{\onyxop{proc}{loop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Repeatedly evaluate \oparg{proc} indefinitely.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 {1 add dup 1 sprint dup 3 eq {pop exit} if} loop
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:lt}
\index{lt@\onyxop{}{lt}{}}
\item[{\onyxop{a b}{lt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 lt 1 sprint
true
onyx:0> 1 1 lt 1 sprint
false
onyx:0> 1 1.1 lt 1 sprint
true
onyx:0> 1.1 1.1 lt 1 sprint
false
onyx:0> 1.1 1 lt 1 sprint
false
onyx:0> `a' `b' lt 1 sprint
true
onyx:0> `a' `a' lt 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mark}
\index{mark@\onyxop{}{mark}{}}
\item[{\onyxop{--}{mark}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a mark onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mark pstack
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:match}
\index{match@\onyxop{}{match}{}}
\item[{\onyxop{input pattern flags}{match}{matches}}: ]
\item[{\onyxop{input pattern}{match}{matches}}: ]
\item[{\onyxop{input regex}{match}{matches}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[input: ]
			An input string to find matches in.
		\item[pattern: ]
			A string that specifies a regular expression.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[flags: ]
			A dictionary of optional flags:
			\begin{description}%\item[]
			\item[\$i: ] Case insensitive.  Defaults to false.
			\item[\$l: ] Maximum number of matches (0 is treated as
				infinity).  Defaults to 1.
			\item[\$m: ] Treat input as a multi-line string.
				Defaults to false.
			\item[\$s: ] Treat input as a single line, so that
				the dot metacharacter matches any character,
				including a newline.
			\end{description}
		\item[regex: ]
			A regex object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[matches: ]
			An array of substring matches.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{regexerror}{regexerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create an array of substrings from \oparg{input} that match a
		regular expression.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:mkdir}
\index{mkdir@\onyxop{}{mkdir}{}}
\item[{\onyxop{path}{mkdir}{--}}: ]
\item[{\onyxop{path mode}{mkdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string object that represents a directory path.
		\item[mode: ]
			An integer that represents a Unix file mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8@755 mkdir
onyx:0> `/tmp/tdir' {1 sprint} dirforeach
`.'
`..'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mkfifo}
\index{mkfifo@\onyxop{}{mkfifo}{}}
\item[{\onyxop{path}{mkfifo}{--}}: ]
\item[{\onyxop{path mode}{mkfifo}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string object that represents a directory path.
		\item[mode: ]
			An integer that represents a Unix file mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a named pipe.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/fifo' mkfifo
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mod}
\index{mod@\onyxop{}{mod}{}}
\item[{\onyxop{a b}{mod}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The modulus of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
			Return the modulus of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 mod 1 sprint
0
onyx:0> 5 2 mod 1 sprint
1
onyx:0> 5 0 mod
Error $undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --mod--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:modload}
\index{modload@\onyxop{}{modload}{}}
\item[{\onyxop{path symbol}{modload}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a module filename.
		\item[symbol: ]
			A string that represents the symbol name of a
			module initialization function to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Dynamically load a module, create a hook object that
		encapsulates the handle returned by dlopen(3) (hook data
		pointer) and the module initialization function (hook evaluation
		function), and evaluate the hook.

		All objects that refer to code and/or data that are part of the
		module must directly and/or indirectly maintain a reference to
		the hook that is evaluated by this operator, since failing to do
		so would allow the garbage collector to unload the module, which
		could result in dangling pointers to unmapped memory regions.

		Loadable modules present a problem for the garbage collector
		during the sweep phase.  All objects that refer to memory that
		is dynamically mapped as part of the module must be destroyed
		before the module is unloaded.  Destruction ordering constraints
		show up in other situations as well, but in the case of loadable
		modules, there is no reasonable solution except to explicitly
		order the destruction of objects.  Therefore, by default, the
		hook that is evaluated by modload is destroyed during the second
		sweep pass.  It is possible for a module to override what sweep
		pass the hook is destroyed on, in cases where there are
		additional ordering constraints for the objects created by a
		module.  This isn't important from the Onyx language
		perspective, but is important to understand when implementing
		modules.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/usr/local/share/onyx/nxmod/mdprompt.nxm' `modprompt_init'
onyx:2> modload
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:monitor}
\index{monitor@\onyxop{}{monitor}{}}
\item[{\onyxop{mutex proc}{monitor}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex.
		\item[proc: ]
			Any object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Execute \oparg{proc} while holding \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex {`hello\n' print} monitor flush
hello
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mrequire}
\index{mrequire@\onyxop{}{mrequire}{}}
\item[{\onyxop{file symbol}{mrequire}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A string that represents a module filename.
		\item[symbol: ]
			A string that represents the symbol name of a
			module initialization function to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Search for and load a module.  The module is searched for by
		catenating a prefix, a ``/'', and \oparg{file} to form a file
		path.  Prefixes are tried in the following order:
		\begin{enumerate}
			\item{The ordered elements of the
			\htmlref{mpath\_pre}{onyxdict:mpath_pre} array, which is
			defined in \htmlref{onyxdict}{sec:onyxdict}.}
			\item{If defined, the ordered elements of the
			ONYX\_MPATH environment variable, which is a
			colon-separated list.}
			\item{The ordered elements of the
			\htmlref{mpath\_post}{onyxdict:mpath_post} array, which
			is defined in \htmlref{onyxdict}{sec:onyxdict}.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> `modgtk.nxm' `modgtk_init' mrequire
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:mul}
\index{mul@\onyxop{}{mul}{}}
\item[{\onyxop{a b}{mul}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The product of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the product of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 17 mul 1 sprint
51
onyx:0> -5 -6 mul 1 sprint
30
onyx:0> 3.5 4.0 mul 1 sprint
1.400000e+01
onyx:0> -1.5 3 mul 1 sprint
-4.500000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mutex}
\index{mutex@\onyxop{}{mutex}{}}
\item[{\onyxop{--}{mutex}{mutex}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a mutex.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex 1 sprint
-mutex-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:nbpop}
\index{nbpop@\onyxop{}{nbpop}{}}
\item[{\onyxop{objects \dots count}{nbpop}{\dots}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			Zero or more objects.
		\item[count: ]
			Number of \oparg{objects} to pop.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the bottom \oparg{count} \oparg{objects} from ostack and
		discard them.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 2 nbpop pstack
`c'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:ncat}
\index{ncat@\onyxop{}{ncat}{}}
\item[{\onyxop{arrays count}{ncat}{array}}: ]
\item[{\onyxop{stacks count}{ncat}{stack}}: ]
\item[{\onyxop{strings count}{ncat}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[arrays: ]
			\oparg{count} arrays.
		\item[stacks: ]
			\oparg{count} stacks.
		\item[strings: ]
			\oparg{count} strings.
		\item[count: ]
			Number of \oparg{arrays}, \oparg{stacks}, or
			\oparg{strings} to catenate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The catenation of \oparg{arrays}, \oparg{stacks}, or
			\oparg{strings}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Catenate \oparg{count} \oparg{arrays}, \oparg{stacks}, or
		\oparg{strings}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b'] [`c'] 3 ncat 1 sprint
[`a' `b' `c']
onyx:0> (`a') (`b') (`c') 3 ncat 1 sprint
(`a' `b' `c')
onyx:0> `a' `b' `c' 3 ncat 1 sprint
`abc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ndn}
\index{ndn@\onyxop{}{ndn}{}}
\item[{\onyxop{a \dots b count}{ndn}{\dots b a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[\dots: ]
			$count - 2$ objects.
		\item[b: ]
			An object.
		\item[count: ]
			Number of objects to rotate downward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			$count - 2$ objects.
		\item[b: ]
			An object.
		\item[a: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate \oparg{count} objects on ostack down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' `d' `e' 4 ndn pstack
`b'
`e'
`d'
`c'
`a'
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:ndup}
\index{ndup@\onyxop{}{ndup}{}}
\item[{\onyxop{objects count}{ndup}{objects objects}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			Zero or more objects.
		\item[count: ]
			The number of \oparg{objects} do duplicate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[objects: ]
			The same objects that were passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create duplicates of the top \oparg{count} objects on ostack.
		For composite objects, the new object is a reference to the same
		composite object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 2 ndup pstack
`c'
`b'
`c'
`b'
`a'
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:ne}
\index{ne@\onyxop{}{ne}{}}
\item[{\onyxop{a b}{ne}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is not equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for inequality.  Inequality has the
		following meaning, depending on the types of \oparg{a} and
		\oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are not equal unless they
		refer to the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are not equal unless
		they refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are not equal iff
		they are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are not equal unless
		they are the same value.
		\item[integer, real: ] \oparg{a} and \oparg{b} are not equal
		unless they are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex ne 1 sprint
true
onyx:0> mutex dup ne 1 sprint
false
onyx:0> $foo `foo' ne 1 sprint
false
onyx:0> $foo $bar ne 1 sprint
true
onyx:0> true false ne 1 sprint
true
onyx:0> true true ne 1 sprint
false
onyx:0> 1 1 ne 1 sprint
false
onyx:0> 1 2 ne 1 sprint
true
onyx:0> 1.0 1 ne 1 sprint
false
onyx:0> 1.0 1.1 ne 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:neg}
\index{neg@\onyxop{}{neg}{}}
\item[{\onyxop{a}{neg}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The negative of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the negative of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 neg 1 sprint
0
onyx:0> 5 neg 1 sprint
-5
onyx:0> -5 neg 1 sprint
5
onyx:0> 3.14 neg 1 sprint
-3.140000e+00
onyx:0> -3.14 neg 1 sprint
3.140000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:nip}
\index{nip@\onyxop{}{nip}{}}
\item[{\onyxop{a b}{nip}{b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Remove the second to top object from ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c'
onyx:3> nip pstack
`c'
`a'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:nonblocking}
\index{nonblocking@\onyxop{}{nonblocking}{}}
\item[{\onyxop{file}{nonblocking}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			Nonb-blocking mode for \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get non-blocking mode for \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup nonblocking 1 sprint
false
onyx:1> dup true setnonblocking
onyx:1> dup nonblocking 1 sprint
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:not}
\index{not@\onyxop{}{not}{}}
\item[{\onyxop{a}{not}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} is an integer, the bitwise negation of
			\oparg{a}, otherwise the logical negation of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise negation of an integer, or the logical
		negation of a boolean.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true not 1 sprint
false
onyx:0> false not 1 sprint
true
onyx:0> 1 not 1 sprint
-2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:npop}
\index{npop@\onyxop{}{npop}{}}
\item[{\onyxop{objects count}{npop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			Zero or more objects.
		\item[count: ]
			Number of \oparg{objects} to pop.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the top \oparg{count} \oparg{objects} from ostack and
		discard them.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 2 npop pstack
`a'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:nsleep}
\index{nsleep@\onyxop{}{nsleep}{}}
\item[{\onyxop{nanoseconds}{nsleep}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[nanoseconds: ]
			Minimum number of nanoseconds to sleep.  Must be greater
			than 0.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Sleep for at least \oparg{nanoseconds} nanonseconds.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1000 nsleep
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:null}
\index{null@\onyxop{}{null}{}}
\item[{\onyxop{--}{null}{null}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a null object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> null pstack
null
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:nup}
\index{nup@\onyxop{}{nup}{}}
\item[{\onyxop{a \dots b count}{nup}{b a \dots}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[\dots: ]
			$count - 2$ objects.
		\item[b: ]
			An object.
		\item[count: ]
			Number of objects to rotate upward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			An object.
		\item[a: ]
			An object.
		\item[\dots: ]
			$count - 2$ objects.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate \oparg{count} objects on ostack up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' `d' `e' 4 nup pstack
`d'
`c'
`b'
`e'
`a'
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:offsets}
\index{offsets@\onyxop{}{offsets}{}}
\item[{\onyxop{input matches}{offsets}{offsets}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[input: ]
			A string.
		\item[matches: ]
			An array of substrings in \oparg{input}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[offsets: ]
			An array of integer offsets from the beginning of
			\oparg{input} corresponding to the substrings in
			\oparg{matches}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create an array of integer offsets from the beginning of
		\oparg{input} corresponding to the substrings in
		\oparg{matches}.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:onyxdict}
\index{onyxdict@\onyxop{}{onyxdict}{}}
\item[{\onyxop{--}{onyxdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get onyxdict.  See Section~\ref{sec:onyxdict} for details on
		onyxdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict 1 sprint
<$rpath_pre -array- $rpath_post -array- $mpath_pre -array- $mpath_post -array->
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:open}
\index{open@\onyxop{}{open}{}}
\item[{\onyxop{filename flags}{open}{file}}: ]
\item[{\onyxop{filename flags mode}{open}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[flags: ]
			A string that represents a file mode:
			\begin{description}%\item[]
			\item[`r': ]
				Read only.
			\item[`r+': ]
				Read/write, starting at offset 0.
			\item[`w': ]
				Write only.  Create file if necessary.  Truncate
				file if non-zero length.
			\item[`w+': ]
				Read/write, starting at offset 0.  Create
				file if necessary.
			\item[`a': ]
				Write only, starting at end of file.
			\item[`a+': ]
				Read/write, starting at end of file.
			\end{description}
		\item[mode: ]
			Mode to use when creating a new file (defaults to 0777).
			Note that the process's umask also affects creation
			mode.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Open a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:or}
\index{or@\onyxop{}{or}{}}
\item[{\onyxop{a b}{or}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			or, otherwise their logical or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise or of two integers, or the logical or of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false false or 1 sprint
false
onyx:0> true false or 1 sprint
true
onyx:0> 5 3 or 1 sprint
7
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of ostack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 ostack pstack
(1 2 3)
3
2
1
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:output}
\index{output@\onyxop{}{output}{}}
\item[{\onyxop{obj depth}{output}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{obj}.  See
		Section~\ref{sec:outputsdict} for format specifier details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4] <$w 20 $p `_' $j $c $r 1> output `\n' print flush
___[1 -array- 4]____
onyx:0> [1 [2 3] 4] <$w 20 $p `_' $j $c $r 2> output `\n' print flush
____[1 [2 3] 4]_____
onyx:0> 4242 <$s $+> output `\n' print flush
+4242
onyx:0> `0x' print 4242 <$b 16> output `\n' print flush
0x1092
onyx:0> `0x' 4242 <$b 16> outputs cat <$w 10 $p `.'>
onyx:2>  output `\n' print flush
....0x1092
onyx:0> `0x' print 4242 <$w 8 $p `0' $b 16> output `\n' print flush
0x00001092
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:outputs}
\index{outputs@\onyxop{}{outputs}{}}
\item[{\onyxop{obj flags}{outputs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object to print syntactically.
		\item[depth: ]
			Formatting flags.  See Section~\ref{sec:outputsdict} for
			details on the supported flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A formatted string representation of \oparg{obj}.
			See Section~\ref{sec:outputsdict} for format specifier
			details.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4] <$w 20 $p `_' $j $c $r 1> outputs print `\n' print flush
___[1 -array- 4]____
onyx:0> [1 [2 3] 4] <$w 20 $p `_' $j $c $r 2> outputs print `\n' print flush
____[1 [2 3] 4]_____
onyx:0> 4242 <$s $+> outputs print `\n' print flush
+4242
onyx:0> `0x' print 4242 <$b 16> outputs print `\n' print flush
0x1092
onyx:0> `0x' 4242 <$b 16> outputs cat <$w 10 $p `.'> outputs 
onyx:1> print `\n' print flush
....0x1092
onyx:0> `0x' print 4242 <$w 8 $p `0' $b 16> outputs print `\n' print flush
0x00001092
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:outputsdict}
\index{outputsdict@\onyxop{}{outputsdict}{}}
\item[{\onyxop{--}{outputsdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get outputsdict.  See Section~\ref{sec:outputsdict} for details
		on outputsdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:over}
\index{over@\onyxop{}{over}{}}
\item[{\onyxop{a b}{over}{a b a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the second object on ostack and push it
		onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 2 over pstack
1
2
1
0
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:peername}
\index{peername@\onyxop{}{peername}{}}
\item[{\onyxop{sock}{peername}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary of information about the peer end of
			\oparg{sock}.  Depending on the socket family, the
			following entries may exist:
			\begin{description}%\item[]
			\item[family: ] Socket family.
			\item[address: ] IPv4 address.
			\item[port: ] IPv4 port.
			\item[path: ] Unix-domain socket path.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get information about the peer end of \oparg{sock}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' 7777 bindsocket
onyx:1> dup listen
onyx:1> dup accept
onyx:2> dup peername 1 sprint
<$family $AF_INET $address 2130706433 $port 33746>
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:pid}
\index{pid@\onyxop{}{pid}{}}
\item[{\onyxop{--}{pid}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process ID of the running process.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pid 1 sprint
80624
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pipe}
\index{pipe@\onyxop{}{pipe}{}}
\item[{\onyxop{--}{pipe}{rfile wfile}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[rfile: ]
			A readable file object.  Data read from \oparg{rfile}
			were previously written to \oparg{wfile}.
		\item[wfile: ]
			A writeable file object.  Data written to \oparg{wfile}
			can subsequently be read from \oparg{rfile}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a pipe.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pipe
onyx:2> $wfile exch def
onyx:1> $rfile exch def
onyx:0> wfile `foo\n' write
onyx:0> wfile flushfile
onyx:0> rfile readline pop 1 sprint
`foo'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pop}
\index{pop@\onyxop{}{pop}{}}
\item[{\onyxop{obj}{pop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Remove the top object from ostack and discard it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2
onyx:2> pstack
2
1
onyx:2> pop
onyx:1> pstack
1
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:poll}
\index{poll@\onyxop{}{poll}{}}
\item[{\onyxop{{\lt}file flags \dots{\gt} timeout}{poll}{{\lb}file
      \dots{\rb}}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[{\lt}\dots{\gt}: ]
			A dictionary of \oparg{file}/\oparg{flags} key/value
			pairs.
			\begin{description}%\item[]
			\item[file: ]
				A file object.
			\item[flags: ]
				A dictionary that contains keys corresponding to
				file status attributes to poll.  The following
				keys are heeded:
				\begin{description}%\item[]
				\item[\$POLLIN: ]
					Normal or priority data are available
					for reading.
				\item[\$POLLRDNORM: ]
					Normal data are available for reading.
				\item[\$POLLRDBAND: ]
					Priority data are available for reading.
				\item[\$POLLPRI: ]
					High-priority data are available for
					reading.
				\item[\$POLLOUT: ]
					Normal data can be written.
				\item[\$POLLWRNORM: ]
					Normal data can be written.
				\item[\$POLLWRBAND: ]
					Priority data can be written.
				\end{description}
				The values associated with the keys are
				disregarded, but are set appropriately before
				\onyxop{}{poll}{} returns (true/false).
			\end{description}
		\item[timeout: ]
			Timeout, in milliseconds (maximum $2^{31} - 1$).  -1 is
			treated specially to mean infinite timeout.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[{\lb}\dots{\rb}: ]
			An array containing a reference to each \oparg{file} in
			\oparg{{\lt}\dots{\gt}} for which a non-zero number of
			status attributes is set to true.  A zero-length array
			indicates that the poll timed out.
			\begin{description}%\item[]
			\item[file: ]
				A reference to a file object passed in that has
				one or more attributes set to true.
			\end{description}
		\end{description}
		Although \oparg{{\lt}\dots{\gt}} is not returned, its contents
		are modified.
		\begin{description}\item[]
		\item[flags: ]
			The dictionary passed in.  For recognized key that is
			defined, the associated value is set to true or false,
			depending on the status of \oparg{file}.  In addition,
			the following keys may defined (if not already defined)
			with a value of true in the case of errors:
			\begin{description}%\item[]
			\item[\$POLLERR: ]
				An error has occurred.
			\item[\$POLLHUP: ]
				Hangup has occurred.
			\item[\$POLLNVAL: ]
				\oparg{file} is not an open file.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for any of the \oparg{flags} associated with a \oparg{file}
		in \oparg{{\lt}\dots{\gt}} to be true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <stdout <$POLLOUT null> stderr <$POLLWRNORM null>> dup 0 poll
onyx:2> 2 sprint 2 sprint
[-file- -file-]
<-file- <$POLLWRNORM true> -file- <$POLLOUT true>>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ppid}
\index{ppid@\onyxop{}{ppid}{}}
\item[{\onyxop{--}{ppid}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process ID of the running process's parent.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ppid 1 sprint
352
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:print}
\index{print@\onyxop{}{print}{}}
\item[{\onyxop{string}{print}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Print \oparg{string} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print flush
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:product}
\index{product@\onyxop{}{product}{}}
\item[{\onyxop{--}{product}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the product name, normally
			`Canonware Onyx'.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the product string.  The string returned is a reference to
		the original product string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> product pstack
`Canonware Onyx'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:pstack}
\index{pstack@\onyxop{}{pstack}{}}
\item[{\onyxop{--}{pstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\end{description}
	\item[Description: ]
		Syntactically print the elements of ostack, one per line.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' 1 mark $foo [1 2 3] (4 5 6)
onyx:6> pstack
(4 5 6)
[1 2 3]
$foo
-mark-
1
`a'
onyx:6>
		\end{verbatim}
	\end{description}
\label{systemdict:put}
\index{put@\onyxop{}{put}{}}
\item[{\onyxop{array index obj}{put}{--}}: ]
\item[{\onyxop{dict key value}{put}{--}}: ]
\item[{\onyxop{string index integer}{put}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[string: ]
			A string object.
		\item[index: ]
			Offset in \oparg{array} or \oparg{string} to put
			\oparg{obj} or \oparg{integer}, respectively.
		\item[key: ]
			An object to use as a key in \oparg{dict}.
		\item[obj: ]
			An object to insert into \oparg{array} at offset
			\oparg{index}.
		\item[value: ]
			An object to associate with \oparg{key} in \oparg{dict}.
		\item[integer: ]
			The ascii value of a character to insert into
			\oparg{string} at offset \oparg{index}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Insert into \oparg{array}, \oparg{dict}, or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 array dup 1 `a' put 1 sprint
[null `a' null]
onyx:0> dict dup $foo `foo' put 1 sprint
<$foo `foo'>
onyx:0> 3 string dup 1 97 put 1 sprint
`\x00a\x00'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:putinterval}
\index{putinterval@\onyxop{}{putinterval}{}}
\item[{\onyxop{array index subarray}{putinterval}{--}}: ]
\item[{\onyxop{string index substring}{putinterval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[string: ]
			A string object.
		\item[index: ]
			Offset into \oparg{array} or \oparg{string} to put
			\oparg{subarray} or \oparg{substring}, respectively.
		\item[subarray: ]
			An array object to put into \oparg{array} at offset
			\oparg{index}.  When inserted \oparg{subarray} must not
			extend past the end of \oparg{array}.
		\item[substring: ]
			A string object to put into \oparg{string} at offset
			\oparg{index}.  When inserted \oparg{substring} must not
			extend past the end of \oparg{string}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Replace a portion of \oparg{array} or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 array dup 1 [`a' `b'] putinterval 1 sprint
[null `a' `b' null]
onyx:0> 4 string dup 1 `ab' putinterval 1 sprint
`\x00ab\x00'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pwd}
\index{pwd@\onyxop{}{pwd}{}}
\item[{\onyxop{--}{pwd}{path}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents the present working directory.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\end{description}
	\item[Description: ]
		Push a string onto ostack that represents the present working
		directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd
onyx:1> pstack
`/usr/local/bin'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:quit}
\index{quit@\onyxop{}{quit}{}}
\item[{\onyxop{--}{quit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.  Under
		normal circumstances, there is always at least one such context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> estack 1 sprint
(--start-- -file- --start-- -file- --estack--)
onyx:0> quit
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rand}
\index{rand@\onyxop{}{rand}{}}
\item[{\onyxop{--}{rand}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			A pseudo-random non-negative integer, with 63 bits of
			psuedo-randomness.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return a pseudo-random integer.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 srand
onyx:0> rand 1 sprint
9018578418316157091
onyx:0> rand 1 sprint
8979240987855095636
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:read}
\index{read@\onyxop{}{read}{}}
\item[{\onyxop{file}{read}{integer boolean}}: ]
\item[{\onyxop{file string}{read}{substring boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer that represents the ascii value of a
			character that was read from \oparg{file}.
		\item[substring: ]
			A substring of \oparg{string} that contains data
			read from \oparg{file}.
		\item[boolean: ]
			If true, end of file reached during read.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Read from \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hello\n'
		\end{verbatim}
	\end{description}
\label{systemdict:readline}
\index{readline@\onyxop{}{readline}{}}
\item[{\onyxop{file}{readline}{string boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains a line of text from \oparg{file}.
		\item[boolean: ]
			If true, end of file reached during read.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Read a line of text from \oparg{file}.  Lines are separated
		by ``{\bs}n'' or ``{\bs}r{\bs}n'', which is removed.  The
		last line in a file may not have a newline at the end.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup `Goodbye\n' write
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1> dup readline 1 sprint 1 sprint
false
`Goodbye'
onyx:1> dup readline 1 sprint 1 sprint
true
`'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:readlink}
\index{readlink@\onyxop{}{readlink}{}}
\item[{\onyxop{linkname}{readlink}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[linkname: ]
			A string that represents the path of a symbolic link.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that represents the link data associated with
			\oparg{linkname}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get the data for the symbolic link at \oparg{linkname}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `bar' `foo' symlink
onyx:0> `foo' readlink 1 sprint
`bar'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:realtime}
\index{realtime@\onyxop{}{realtime}{}}
\item[{\onyxop{--}{realtime}{nsecs}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[nsecs: ]
			Number of nanoseconds since the epoch (midnight on 1
			January 1970).
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of nanoseconds since the epoch.
	\item[Example(s): ]\begin{verbatim}

onyx:0> realtime 1 sprint
993539837806479000
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:recv}
\index{recv@\onyxop{}{recv}{}}
\item[{\onyxop{sock string flags}{recv}{substring}}: ]
\item[{\onyxop{sock string}{recv}{substring}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[string: ]
			A string to use as a buffer for the message being
			received.
		\item[flags: ]
			An array of flag names.  The following flags are
			supported:
			\begin{description}%\item[]
			\item[\$MSG\_OOB]
			\item[\$MSG\_PEEK]
			\item[\$MSG\_WAITALL]
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[substring: ]
			A substring of \oparg{string} that contains message
			data.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_DGRAM socket
onyx:1> dup `localhost' 7777 bindsocket
onyx:1> dup true setnonblocking
onyx:1> dup 10 string recv
onyx:2> 1 sprint
`hello'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:regex}
\index{regex@\onyxop{}{regex}{}}
\item[{\onyxop{string flags}{regex}{regex}}: ]
\item[{\onyxop{string}{regex}{regex}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that specifies a regular expression.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[flags: ]
			A dictionary of optional flags:
			\begin{description}%\item[]
			\item[\$i: ] Case insensitive.  Defaults to false.
			\item[\$l: ] Maximum number of matches (0 is treated as
				infinity).  Defaults to 1.
			\item[\$m: ] Treat input as a multi-line string.
				Defaults to false.
			\item[\$s: ] Treat input as a single line, so that
				the dot metacharacter matches any character,
				including a newline.
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[regex: ]
			A regex object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{regexerror}{regexerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a regex object, according to \oparg{string} and
		\oparg{flags}.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:regsub}
\index{regsub@\onyxop{}{regsub}{}}
\item[{\onyxop{pattern template flags}{regsub}{regsub}}: ]
\item[{\onyxop{pattern template}{regsub}{regsub}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pattern: ]
			A string that specifies a regular expression.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[template: ]
			A string that specifies a substitution template.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[flags: ]
			A dictionary of optional flags:
			\begin{description}%\item[]
			\item[\$i: ] Case insensitive.  Defaults to false.
			\item[\$l: ] Maximum number of matches (0 is treated as
				infinity).  Defaults to 1.
			\item[\$m: ] Treat input as a multi-line string.
				Defaults to false.
			\item[\$s: ] Treat input as a single line, so that
				the dot metacharacter matches any character,
				including a newline.
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[regsub: ]
			A regsub object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a regsub object, according to \oparg{pattern},
		\oparg{template}, and \oparg{flags}.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:rename}
\index{rename@\onyxop{}{rename}{}}
\item[{\onyxop{old new}{rename}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[old: ]
			A string object that represents a file path.
		\item[new: ]
			A string object that represents a file path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Rename a file or directory from \oparg{old} to \oparg{new}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8@755 mkdir 
onyx:0> `/tmp/tdir' `/tmp/ndir' rename
onyx:0> `/tmp/ndir' {1 sprint} dirforeach
`.'
`..'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:repeat}
\index{repeat@\onyxop{}{repeat}{}}
\item[{\onyxop{count proc}{repeat}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of times to evaluate \oparg{proc} (non-negative).
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{proc} \oparg{count} times.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 {`hi' 1 sprint} repeat
`hi'
`hi'
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:require}
\index{require@\onyxop{}{require}{}}
\item[{\onyxop{file}{require}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A string that represents a module filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Search for and evaluate an Onyx source file.  The file is
		searched for by catenating a prefix, a ``/'', and \oparg{file}
		to form a file path.  Prefixes are tried in the following order:
		\begin{enumerate}
			\item{The ordered elements of the
			\htmlref{rpath\_pre}{onyxdict:rpath_pre} array, which is
			defined in \htmlref{onyxdict}{sec:onyxdict}.}
			\item{If defined, the ordered elements of the
			ONYX\_RPATH environment variable, which is a
			colon-separated list.}
			\item{The ordered elements of the
			\htmlref{rpath\_post}{onyxdict:rpath_post} array, which
			is defined in \htmlref{onyxdict}{sec:onyxdict}.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> `modgtk/modgtk_defs.nx' require
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:rmdir}
\index{rmdir@\onyxop{}{rmdir}{}}
\item[{\onyxop{path}{rmdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string object that represents a directory path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Remove an empty directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8@755 mkdir
onyx:0> `/tmp/tdir' rmdir
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:roll}
\index{roll@\onyxop{}{roll}{}}
\item[{\onyxop{region count amount}{roll}{rolled}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[region: ]
			0 or more objects to be rolled.
		\item[count: ]
			Number of objects in \oparg{region}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[rolled: ]
			Rolled version of \oparg{region}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on ostack (not counting
		\oparg{count} and \oparg{amount}) by \oparg{amount} positions.
		A positive \oparg{amount} indicates an upward roll, whereas a
		negative \oparg{amount} indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 
onyx:4> pstack
0
1
2
3
onyx:4> 3 1 roll
onyx:4> pstack
1
2
0
3
onyx:4> 3 -2 roll
onyx:4> pstack
2
0
1
3
onyx:4> 4 0 roll
onyx:4> pstack
2
0
1
3
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:round}
\index{round@\onyxop{}{round}{}}
\item[{\onyxop{a}{round}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer round of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Round \oparg{a} to the nearest integer and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 round 1 sprint
-2
onyx:0> -1.49 round 1 sprint
-1
onyx:0> 0 round 1 sprint
0
onyx:0> 1.49 round 1 sprint
1
onyx:0> 1.51 round 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rot}
\index{rot@\onyxop{}{rot}{}}
\item[{\onyxop{\dots amount}{rot}{\dots}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			One or more objects.
		\item[amount: ]
			Number of positions to rotate the stack upward.  A
			negative value causes downward rotation.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[\dots: ]
			One or more objects.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate the stack contents up \oparg{amount} positions.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 4 5 2 rot pstack clear
3
2
1
5
4
onyx:0> 1 2 3 4 5 -2 rot pstack clear
2
1
5
4
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sadn}
\index{sadn@\onyxop{}{sadn}{}}
\item[{\onyxop{stack}{sadn}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate the contents of \oparg{stack} down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup sadn 1 sprint
(2 3 4 1)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:saup}
\index{saup@\onyxop{}{saup}{}}
\item[{\onyxop{stack}{saup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate the contents of \oparg{stack} up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup saup 1 sprint
(4 1 2 3)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sbdup}
\index{sbdup@\onyxop{}{sbdup}{}}
\item[{\onyxop{stack}{sbdup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Duplicate the bottom object on \oparg{stack} and push it onto
		\oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (2 1 0) dup sbdup pstack
(2 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sbpop}
\index{sbpop@\onyxop{}{sbpop}{}}
\item[{\onyxop{stack}{sbpop}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop \oparg{obj} off the bottom of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3) dup sbpop pstack
1
(2 3)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sbpush}
\index{sbpush@\onyxop{}{sbpush}{}}
\item[{\onyxop{stack obj}{sbpush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{obj} onto the bottom of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (0) dup 1 sbpush
onyx:1> pstack
(1 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sclear}
\index{sclear@\onyxop{}{sclear}{}}
\item[{\onyxop{stack}{sclear}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove all objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup sclear pstack
()
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scleartomark}
\index{scleartomark@\onyxop{}{scleartomark}{}}
\item[{\onyxop{stack}{scleartomark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from \oparg{stack} down to and including the
		topmost mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) dup scleartomark pstack
(3)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scount}
\index{scount@\onyxop{}{scount}{}}
\item[{\onyxop{stack}{scount}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the number of objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) scount 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:scounttomark}
\index{scounttomark@\onyxop{}{scounttomark}{}}
\item[{\onyxop{stack}{scounttomark}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The depth of the topmost mark on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) scounttomark 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sdn}
\index{sdn@\onyxop{}{sdn}{}}
\item[{\onyxop{stack}{sdn}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate the top three objects on \oparg{stack} down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup sdn pstack
(3 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sdup}
\index{sdup@\onyxop{}{sdup}{}}
\item[{\onyxop{stack}{sdup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Duplicate the top object on \oparg{stack} and push it onto
		\oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1) dup sdup 1 sprint
(1 1)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:search}
\index{search@\onyxop{}{search}{}}
\item[{\onyxop{string pattern}{search}{post pattern pre true}}: ]
\item[{\onyxop{string pattern}{search}{string false}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[pattern: ]
			A string that represents a substring to search for in
			\oparg{string}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[post: ]
			The substring of \oparg{string} that follows the match.
		\item[pattern: ]
			The substring of \oparg{string} that matches the input
			\oparg{pattern}.
		\item[pre: ]
			The substring of \oparg{string} that precedes the match.
		\item[true: ]
			Success.
		\item[string: ]
			The same object as the input \oparg{string}.
		\item[false: ]
			Failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Search for the first instance of \oparg{pattern} in
		\oparg{string}, and if found, return substrings that partition
		\oparg{string} into \oparg{pre}, \oparg{pattern}, and
		\oparg{post}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `abcabc' `ab' search pstack clear
true
`'
`ab'
`cabc'
onyx:0> `abcabc' `ca' search pstack clear
true
`ab'
`ca'
`bc'
onyx:0> `abcabc' `cb' search pstack clear
false
`abcabc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:seek}
\index{seek@\onyxop{}{seek}{}}
\item[{\onyxop{file offset}{seek}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[offset: ]
			Offset in bytes from the beginning of \oparg{file}
			to move the file position pointer to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Move the file position pointer for \oparg{file} to
		\oparg{offset}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup 0 seek
onyx:1> readline pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:self}
\index{self@\onyxop{}{self}{}}
\item[{\onyxop{--}{self}{thread}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object that corresponds to the running thread.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a thread object for the running thread.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self 1 sprint
-thread-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:send}
\index{send@\onyxop{}{send}{}}
\item[{\onyxop{sock mesg flags}{send}{nsend}}: ]
\item[{\onyxop{sock mesg}{send}{nsend}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[mesg: ]
			A message string.
		\item[flags: ]
			An array of flag names.  The following flags are
			supported:
			\begin{description}%\item[]
			\item[\$MSG\_OOB]
			\item[\$MSG\_PEEK]
			\item[\$MSG\_WAITALL]
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[nsend: ]
			Number of bytes of \oparg{mesg} actually sent.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Send a message.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_DGRAM socket
onyx:1> dup `localhost' 7777 connect
onyx:1> dup `hello' send
onyx:2> 1 sprint
5
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:serviceport}
\index{serviceport@\onyxop{}{serviceport}{}}
\item[{\onyxop{service}{serviceport}{port}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[service: ]
			A string that represents a network service name.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[port: ]
			The port number corresponding to \oparg{service}, or 0
			if the service is unknown.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

onyx:0> `ftp' serviceport 1 sprint
21
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setegid}
\index{setegid@\onyxop{}{setegid}{}}
\item[{\onyxop{gid}{setegid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[gid: ]
			A group ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's effective group ID to \oparg{gid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setegid 1 sprint
false
onyx:0> 0 setegid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setenv}
\index{setenv@\onyxop{}{setenv}{}}
\item[{\onyxop{key val}{setenv}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A name object.
		\item[val: ]
			A value to associate with \oparg{key}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set an environment variable named \oparg{key} and associate
		\oparg{val} with it.  If \oparg{val} is not a string, it is
		converted to a string using the
		\htmlref{\onyxop{}{cvs}{}}{systemdict:cvs} operator before the
		environment variable is set.  A corresponding entry is also
		created in the envdict dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $foo `foo' setenv
onyx:0> envdict $foo known 1 sprint
true
onyx:0> envdict $foo get 1 sprint
`foo'
onyx:0> $foo unsetenv
onyx:0> envdict $foo known 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:seteuid}
\index{seteuid@\onyxop{}{seteuid}{}}
\item[{\onyxop{uid}{seteuid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[uid: ]
			A user ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's effective user ID to \oparg{uid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 seteuid 1 sprint
false
onyx:0> 0 seteuid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setgid}
\index{setgid@\onyxop{}{setgid}{}}
\item[{\onyxop{gid}{setgid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[gid: ]
			A group ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's group ID to \oparg{gid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setgid 1 sprint
false
onyx:0> 0 setgid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setgstderr}
\index{setgstderr@\onyxop{}{setgstderr}{}}
\item[{\onyxop{file}{setgstderr}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the global stderr to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the global stderr to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/stderr' `w' open dup 0 setiobuf setgstderr
onyx:0> () {stderr `Some text\n' write} thread join
onyx:0> `/tmp/stderr' `r' open readline pop 1 sprint
`Some text'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setgstdin}
\index{setgstdin@\onyxop{}{setgstdin}{}}
\item[{\onyxop{file}{setgstdin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the global stdin to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the global stdin to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]
		Under normal interactive operation, stdin is pushed onto estack
		during interpreter initialization and evaluated until EOF is
		reached.  Therefore, changing stdin has no effect on the file
		descriptor already on estack.  The following example recursively
		evaluates stdin after redefining it.
\begin{verbatim}

lawine:~> cat /tmp/stdin
1 2 3 pstack
lawine:~> onyx 
Canonware Onyx, version 3.1.0.
onyx:0> `/tmp/stdin' `r' open cvx setgstdin
onyx:0> () {stdin eval} thread join
3
2
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setgstdout}
\index{setgstdout@\onyxop{}{setgstdout}{}}
\item[{\onyxop{file}{setgstdout}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the global stdout to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the global stdout to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]
		In the following example, the prompt continues to be printed,
		even though stdout has been redefined, because the prompt module
		was initialized to print to file descriptor 1.  This
		demonstrates the only known exception in the stock Onyx
		interpreter where redefining stdout will not redirect output.
\begin{verbatim}

onyx:0> `/tmp/stdout' `w' open dup 0 setiobuf setgstdout
onyx:0> () {`Some text\n' print} thread join
onyx:0> `/tmp/stdout' `r' open readline pop 1 sprint
`Some text'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setiobuf}
\index{setiobuf@\onyxop{}{setiobuf}{}}
\item[{\onyxop{file count}{setiobuf}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[count: ]
			The size in bytes to set the I/O buffer associated with
			\oparg{file} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the size of the I/O buffer associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout iobuf 1 sprint
512
onyx:0> stdout 0 setiobuf
onyx:0> stdout iobuf 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setlocking}
\index{setlocking@\onyxop{}{setlocking}{}}
\item[{\onyxop{boolean}{setlocking}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean to set the implicit locking mode to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the current implicit locking mode.  See
		Section~\ref{sec:onyx_implicit_synchronization} for implicit
		synchronization details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currentlocking 1 sprint
false
onyx:0> true setlocking
onyx:0> currentlocking 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setnonblocking}
\index{setnonblocking@\onyxop{}{setnonblocking}{}}
\item[{\onyxop{file boolean}{setnonblocking}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[boolean: ]
			Non-blocking mode to set \oparg{file} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set non-blocking mode for \oparg{file} to \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup nonblocking 1 sprint
false
onyx:1> dup true setnonblocking
onyx:1> dup nonblocking 1 sprint
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:setsockopt}
\index{setsockopt@\onyxop{}{setsockopt}{}}
\item[{\onyxop{sock level optname optval}{setsockopt}{--}}: ]
\item[{\onyxop{sock optname optval}{setsockopt}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[level: ]
			Level at which to set the socket option.  If not
			specified, \$SOL\_SOCKET is used.
		\item[optname: ]
			Name of option to set the value of.  The following
			option names are supported:
			\begin{description}%\item[]
			\item[\$SO\_DEBUG]
			\item[\$SO\_REUSEADDR]
			\item[\$SO\_REUSEPORT]
			\item[\$SO\_KEEPALIVE]
			\item[\$SO\_DONTROUTE]
			\item[\$SO\_BROADCAST]
			\item[\$SO\_OOBINLINE]
			\item[\$SO\_SNDBUF]
			\item[\$SO\_RCVBUF]
			\item[\$SO\_SNDLOWAT]
			\item[\$SO\_RCVLOWAT]
			\item[\$SO\_TYPE]
			\item[\$SO\_ERROR: ]
				\oparg{optval} is an integer.
			\item[\$SO\_LINGER: ]
				\oparg{optval} is a dictionary, and the
				following entries are defined:
				\begin{description}%\item[]
				\item[\$on: ]
					Boolean.
				\item[\$time: ]
					Linger time in seconds.
				\end{description}
			\item[\$SO\_SNDTIMEO]
			\item[\$SO\_RCVTIMEO: ]
				\oparg{optval} is an integer, in nanoseconds.
			\end{description}
		\item[optval: ]
			Value to associate with \oparg{optname}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Set a socket option.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup $SO_OOBINLINE sockopt 1 sprint
0
onyx:1> dup $SO_OOBINLINE 1 setsockopt 
onyx:1> dup $SO_OOBINLINE sockopt 1 sprint
1
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:setstderr}
\index{setstderr@\onyxop{}{setstderr}{}}
\item[{\onyxop{file}{setstderr}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the calling thread's stderr to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the thread's stderr to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/stderr' `w' open dup 0 setiobuf setstderr
onyx:0> stderr `Some text\n' write
onyx:0> `/tmp/stderr' `r' open readline pop 1 sprint
`Some text'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setstdin}
\index{setstdin@\onyxop{}{setstdin}{}}
\item[{\onyxop{file}{setstdin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the calling thread's stdin to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the thread's stdin to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]
		Under normal interactive operation, stdin is pushed onto estack
		during interpreter initialization and evaluated until EOF is
		reached.  Therefore, changing stdin has no effect on the file
		descriptor already on estack.  The following example recursively
		evaluates stdin after redefining it.
\begin{verbatim}

lawine:~> cat /tmp/stdin
1 2 3 pstack
lawine:~> onyx 
Canonware Onyx, version 3.1.0.
onyx:0> `/tmp/stdin' `r' open cvx setstdin
onyx:0> stdin eval
3
2
1
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:setstdout}
\index{setstdout@\onyxop{}{setstdout}{}}
\item[{\onyxop{file}{setstdout}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file to set the calling thread's stdout to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the thread's stdout to \oparg{file}.  See
		Section~\ref{sec:onyx_standard_io} for standard I/O details.
	\item[Example(s): ]
		In the following example, the prompt continues to be printed,
		even though stdout has been redefined, because the prompt module
		was initialized to print to file descriptor 1.  This
		demonstrates the only known exception in the stock Onyx
		interpreter where redefining stdout will not redirect output.
\begin{verbatim}

onyx:0> `/tmp/stdout' `w' open dup 0 setiobuf setstdout
onyx:0> `Some text\n' print
onyx:0> gstdout setstdout
onyx:0> `/tmp/stdout' `r' open readline pop 1 sprint
`Some text'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setuid}
\index{setuid@\onyxop{}{setuid}{}}
\item[{\onyxop{uid}{setuid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[uid: ]
			A user ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's user ID to \oparg{uid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setuid 1 sprint
false
onyx:0> 0 setuid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sexch}
\index{sexch@\onyxop{}{sexch}{}}
\item[{\onyxop{stack}{sexch}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3) dup sexch pstack
(1 3 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:shift}
\index{shift@\onyxop{}{shift}{}}
\item[{\onyxop{--}{shift}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[shift: ]
			An integer that represents a bitwise shift amount.
			Negative means right shift, and positive means left
			shift.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} shifted by \oparg{shift} bits.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Shift an integer bitwise.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 1 shift 1 sprint
8
onyx:0> 4 -1 shift 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sibdup}
\index{sibdup@\onyxop{}{sibdup}{}}
\item[{\onyxop{stack index}{sibdup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Offset from bottom of \oparg{stack}, counting from 0, of
			the object to duplicate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on \oparg{stack} that is at
		offset \oparg{index} from the bottom of \oparg{stack} and push
		it onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup 2 sibdup pstack
(3 2 1 0 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sibpop}
\index{sibpop@\onyxop{}{sibpop}{}}
\item[{\onyxop{stack index}{sibpop}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Offset from bottom of \oparg{stack}, counting from 0, of
			the object to remove from \oparg{stack}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object removed from \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the \oparg{obj} from \oparg{stack} that is at offset
		\oparg{index} from the bottom of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (0 1 2 3) dup 2 sibpop pstack
2
(0 1 3)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sidup}
\index{sidup@\onyxop{}{sidup}{}}
\item[{\onyxop{stack index}{sidup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Depth (count starts at 0) of the object to duplicate in
			\oparg{stack}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on \oparg{stack} at depth
		\oparg{index} and push it onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup 2 sidup
onyx:1> 1 sprint
(3 2 1 0 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:signal}
\index{signal@\onyxop{}{signal}{}}
\item[{\onyxop{condition}{signal}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Signal a thread that is waiting on \oparg{condition}.  If there
		are no waiters, this operator has no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sin}
\index{sin@\onyxop{}{sin}{}}
\item[{\onyxop{a}{sin}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Sine of \oparg{a} in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the sine of \oparg{a} in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 sin 1 sprint
0.000000e+00
onyx:0> 1.570796 sin 1 sprint
1.000000e+00
onyx:0> 0.7853982 sin 1 sprint
7.071068e-01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sipop}
\index{sipop@\onyxop{}{sipop}{}}
\item[{\onyxop{stack index}{sipop}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Offset from top of \oparg{stack}, counting from 0, of
			the object to remove from \oparg{stack}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object removed from \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the \oparg{obj} at \oparg{index} from \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup 2 sipop pstack
2
(3 1 0)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:snbpop}
\index{snbpop@\onyxop{}{snbpop}{}}
\item[{\onyxop{stack count}{snbpop}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects to pop off the bottom of
			\oparg{stack}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of objects popped off the bottom of
			\oparg{stack}, with the same object ordering as when on
			\oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop \oparg{count} objects off the bottom of \oparg{stack} and
		put them into an array.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup 2 snbpop pstack
[1 2]
(3 4)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sndn}
\index{sndn@\onyxop{}{sndn}{}}
\item[{\onyxop{stack count}{sndn}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects on \oparg{stack} to rotate down one
			position.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate \oparg{count} objects on \oparg{stack} down one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (5 4 3 2 1 0) dup 4 sndn pstack
(5 4 2 1 0 3)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sndup}
\index{sndup@\onyxop{}{sndup}{}}
\item[{\onyxop{stack count}{sndup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects on \oparg{stack} to duplicate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create duplicates of the top \oparg{count} objects on
		\oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup 2 sndup pstack
(3 2 1 0 1 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:snip}
\index{snip@\onyxop{}{snip}{}}
\item[{\onyxop{stack}{snip}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The object that was the second to top object on
			\oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the second to top object from \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (2 1 0) dup snip pstack
1
(2 0)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:snpop}
\index{snpop@\onyxop{}{snpop}{}}
\item[{\onyxop{stack count}{snpop}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects to pop off of \oparg{stack}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of objects popped off of \oparg{stack}, with
			the same object ordering as when on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop \oparg{count} objects off of \oparg{stack} and put them into
		an array.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup 2 snpop pstack
[3 4]
(1 2)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:snup}
\index{snup@\onyxop{}{snup}{}}
\item[{\onyxop{stack count}{snup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects on \oparg{stack} to rotate up one
			position.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate \oparg{count} objects on \oparg{stack} up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (5 4 3 2 1 0) dup 4 snup pstack
(5 4 0 3 2 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:socket}
\index{socket@\onyxop{}{socket}{}}
\item[{\onyxop{family type proto}{socket}{sock}}: ]
\item[{\onyxop{family type}{socket}{sock}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[family: ]
			The name of a socket address family, either \$AF\_INET
			or \$AF\_LOCAL.
		\item[type: ]
			The name of a socket type, either \$SOCK\_STREAM or
			\$SOCK\_DGRAM.
		\item[proto: ]
			The name of a socket protocol.  This argument is not
			useful, given the current limited choice of address
			families.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a socket.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> $AF_LOCAL $SOCK_DGRAM socket
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:socketpair}
\index{socketpair@\onyxop{}{socketpair}{}}
\item[{\onyxop{family type proto}{socketpair}{sock sock}}: ]
\item[{\onyxop{family type}{socketpair}{sock sock}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[family: ]
			The name of a socket address family, either \$AF\_INET
			or \$AF\_LOCAL.
		\item[type: ]
			The name of a socket type, either \$SOCK\_STREAM or
			\$SOCK\_DGRAM.
		\item[proto: ]
			The name of a socket protocol.  This argument is not
			useful, given the current limited choice of address
			families.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A connected socket.  There are no functional differences
			between the two sockets that are returned.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a pair of sockets that are connected to each other.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_LOCAL $SOCK_STREAM socketpair
onyx:2> pstack
-file-
-file-
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sockname}
\index{sockname@\onyxop{}{sockname}{}}
\item[{\onyxop{sock}{sockname}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary of information about \oparg{sock}.
			Depending on the socket family, the following entries
			may exist:
			\begin{description}%\item[]
			\item[family: ] Socket family.
			\item[address: ] IPv4 address.
			\item[port: ] IPv4 port.
			\item[path: ] Unix-domain socket path.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{neterror}{neterror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get information about \oparg{sock}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup `localhost' bindsocket
onyx:1> dup sockname 1 sprint
<$family $AF_INET $address 2130706433 $port 33745>
onyx:1> close
onyx:0> $AF_LOCAL $SOCK_STREAM socket
onyx:1> dup `/tmp/socket' bindsocket
onyx:1> dup sockname 1 sprint
<$family $AF_LOCAL $path `/tmp/socket'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sockopt}
\index{sockopt@\onyxop{}{sockopt}{}}
\item[{\onyxop{sock level optname}{sockopt}{optval}}: ]
\item[{\onyxop{sock optname}{sockopt}{optval}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[sock: ]
			A socket.
		\item[level: ]
			Level at which to get the socket option.  If not
			specified, \$SOL\_SOCKET is used.
		\item[optname: ]
			Name of option to get the value of.  The following
			option names are supported:
			\begin{description}%\item[]
			\item[\$SO\_DEBUG]
			\item[\$SO\_REUSEADDR]
			\item[\$SO\_REUSEPORT]
			\item[\$SO\_KEEPALIVE]
			\item[\$SO\_DONTROUTE]
			\item[\$SO\_BROADCAST]
			\item[\$SO\_OOBINLINE]
			\item[\$SO\_SNDBUF]
			\item[\$SO\_RCVBUF]
			\item[\$SO\_SNDLOWAT]
			\item[\$SO\_RCVLOWAT]
			\item[\$SO\_TYPE]
			\item[\$SO\_ERROR: ]
				\oparg{optval} is an integer.
			\item[\$SO\_LINGER: ]
				\oparg{optval} is a dictionary, and the
				following entries are defined:
				\begin{description}%\item
				\item[\$on: ]
					Boolean.
				\item[\$time: ]
					Linger time in seconds.
				\end{description}
			\item[\$SO\_SNDTIMEO]
			\item[\$SO\_RCVTIMEO: ]
				\oparg{optval} is an integer, in nanoseconds.
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[optval: ]
			Value associated with \oparg{optname}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{argcheck}{argcheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get a socket option.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $AF_INET $SOCK_STREAM socket
onyx:1> dup $SO_SNDBUF sockopt 1 sprint
16384
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sover}
\index{sover@\onyxop{}{sover}{}}
\item[{\onyxop{stack}{sover}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the second object on \oparg{stack} and
		push it onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (2 1 0) dup sover pstack
(2 1 0 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:spop}
\index{spop@\onyxop{}{spop}{}}
\item[{\onyxop{stack}{spop}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The object that was popped off of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop an object off of \oparg{stack} and push it onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) dup spop
onyx:2> pstack
2
(1)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sprint}
\index{sprint@\onyxop{}{sprint}{}}
\item[{\onyxop{obj depth}{sprint}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{obj}.  See
		Section~\ref{sec:sprintsdict} for printing details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4]
onyx:1> dup 0 sprint
-array-
onyx:1> dup 1 sprint
[1 -array- 4]
onyx:1> dup 2 sprint
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sprints}
\index{sprints@\onyxop{}{sprints}{}}
\item[{\onyxop{obj depth}{sprints}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A syntactical string representation of \oparg{obj}.
			See Section~\ref{sec:sprintsdict} for printing details.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4]
onyx:1> dup 0 sprints print `\n' print flush
-array-
onyx:1> dup 1 sprints print `\n' print flush
[1 -array- 4]
onyx:1> dup 2 sprints print `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sprintsdict}
\index{sprintsdict@\onyxop{}{sprintsdict}{}}
\item[{\onyxop{--}{sprintsdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get sprintsdict.  See Section~\ref{sec:sprintsdict} for details
		on sprintsdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:spush}
\index{spush@\onyxop{}{spush}{}}
\item[{\onyxop{stack obj}{spush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{obj} onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (0) dup 1 spush
onyx:1> pstack
(0 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sqrt}
\index{sqrt@\onyxop{}{sqrt}{}}
\item[{\onyxop{a}{sqrt}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A non-negative integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Square root of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the square root of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 sqrt 1 sprint
2.000000e+00
onyx:0> 2.0 sqrt 1 sprint
1.414214e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:srand}
\index{srand@\onyxop{}{srand}{}}
\item[{\onyxop{seed}{srand}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seed: ]
			A non-negative integer.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Seed the pseudo-random number generator with \oparg{seed}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 srand
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sroll}
\index{sroll@\onyxop{}{sroll}{}}
\item[{\onyxop{stack count amount}{sroll}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects to roll in \oparg{stack}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on \oparg{stack} by
		\oparg{amount} positions.  A positive \oparg{amount}
		indicates an upward roll, whereas a negative \oparg{amount}
		indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0)
onyx:1> dup 3 1 sroll pstack
(3 0 2 1)
onyx:1> dup 3 -2 sroll pstack
(3 1 0 2)
onyx:1> dup 4 0 sroll pstack
(3 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:srot}
\index{srot@\onyxop{}{srot}{}}
\item[{\onyxop{stack amount}{srot}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			One or more objects.
		\item[amount: ]
			Number of positions to rotate \oparg{stack} upward.  A
			negative value causes downward rotation.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate \oparg{stack} up \oparg{count} positions.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4 5) dup 2 srot 1 sprint
(4 5 1 2 3)
onyx:0> (1 2 3 4 5) dup -2 srot 1 sprint
(3 4 5 1 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stack}
\index{stack@\onyxop{}{stack}{}}
\item[{\onyxop{--}{stack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An empty stack object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a new stack object and push it onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stack
onyx:1> pstack
()
		\end{verbatim}
	\end{description}
\label{systemdict:start}
\index{start@\onyxop{}{start}{}}
\item[{\onyxop{obj}{start}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{obj}.  This operator provides a context that
		silently terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit},
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}, and
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operators.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> quit
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:status}
\index{status@\onyxop{}{status}{}}
\item[{\onyxop{file/filename}{status}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary that contains the following entries:
			\begin{description}%\item[]
			\item[dev: ]
				Inode's device.
			\item[ino: ]
				Inode's number.
			\item[mode: ]
				Inode permissions.
			\item[nlink: ]
				Number of hard links.
			\item[uid: ]
				User ID of the file owner.
			\item[gid: ]
				Group ID of the file owner.
			\item[rdev: ]
				Device type.
			\item[size: ]
				File size in bytes.
			\item[atime: ]
				Time of last access, in nanoseconds since the
				epoch.
			\item[mtime: ]
				Time of last modification, in nanoseconds since
				the epoch.
			\item[ctime: ]
				Time of last file status change, in nanoseconds
				since the epoch.
			\item[blksize: ]
				Optimal block size for I/O.
			\item[blocks: ]
				Number of blocks allocated.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get status information about a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp' status 1 sprint
<$dev 134405 $ino 2 $mode 17407 $nlink 5 $uid 0 $gid 0 $rdev 952 $size 3584
$atime 994883041000000000 $mtime 994883041000000000 $ctime 994883041000000000
$blksize 0 $blocks 8>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stderr}
\index{stderr@\onyxop{}{stderr}{}}
\item[{\onyxop{--}{stderr}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the calling thread's
			stderr.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the thread's stderr.  See Section~\ref{sec:onyx_standard_io}
		for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stderr pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stdin}
\index{stdin@\onyxop{}{stdin}{}}
\item[{\onyxop{--}{stdin}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the calling thread's
			stdin.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the thread's stdin.  See Section~\ref{sec:onyx_standard_io}
		for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stdout}
\index{stdout@\onyxop{}{stdout}{}}
\item[{\onyxop{--}{stdout}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to the calling thread's
			stdout.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the thread's stdout.  See Section~\ref{sec:onyx_standard_io}
		for standard I/O details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{stopped}{}}{systemdict:stopped} or
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stopped}
\index{stopped@\onyxop{}{stopped}{}}
\item[{\onyxop{obj}{stopped}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if stop operator was executed, false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidexit}{invalidexit}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{obj}.  This operator provides a context that
		terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop}.  It will also
		terminate execution stack unwinding due to the 
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator, but will
		throw an \htmlref{invalidexit}{invalidexit} error, then do the
		equivalent of calling
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0> {} stopped 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:string}
\index{string@\onyxop{}{string}{}}
\item[{\onyxop{length}{string}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[length: ]
			Non-negative number of bytes.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string of \oparg{length} bytes.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a string of \oparg{length} bytes.  The bytes are
		initialized to 0.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 string 1 sprint
`\x00\x00\x00'
onyx:0>
onyx:0> 0 string 1 sprint
`'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stuck}
\index{stuck@\onyxop{}{stuck}{}}
\item[{\onyxop{stack}{stuck}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Tuck duplicate of top object on \oparg{stack} under second
		object on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (2 1 0) dup stuck pstack
(2 0 1 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sub}
\index{sub@\onyxop{}{sub}{}}
\item[{\onyxop{a b}{sub}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The value of \oparg{b} subtracted from \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Subtract \oparg{b} from \oparg{a} and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 3 sub 1 sprint
2
onyx:0> -3 4 sub 1 sprint
-7
onyx:0> 5.1 1.1 sub 1 sprint
4.000000e+00
onyx:0> 5 1.0 sub 1 sprint
4.000000e+00
onyx:0> -3.0 4.1 sub 1 sprint
-7.100000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:subst}
\index{subst@\onyxop{}{subst}{}}
\item[{\onyxop{input pattern template flags}{subst}{output count}}: ]
\item[{\onyxop{input pattern template}{subst}{output count}}: ]
\item[{\onyxop{input regsub}{subst}{output count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[input: ]
			An input string.
		\item[pattern: ]
			A string that specifies a regular expression.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[template: ]
			A string that specifies a substitution template.  See
			Section~\ref{sec:onyx_regular_expressions} for syntax.
		\item[flags: ]
			A dictionary of optional flags:
			\begin{description}%\item[]
			\item[\$i: ] Case insensitive.  Defaults to false.
			\item[\$l: ] Maximum number of matches (0 is treated as
				infinity).  Defaults to 1.
			\item[\$m: ] Treat input as a multi-line string.
				Defaults to false.
			\item[\$s: ] Treat input as a single line, so that
				the dot metacharacter matches any character,
				including a newline.
			\end{description}
		\item[regsub: ]
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[output: ]
			A string that is created by substituting substrings
			within \oparg{input} that match a regular expression
			with \oparg{template}.
		\item[count: ]
			Number of substitutions made.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a string by substituting \oparg{template} for each
		substring within \oparg{input} that matches a regular
		expression.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:sunder}
\index{sunder@\onyxop{}{sunder}{}}
\item[{\onyxop{stack}{sunder}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the second object on \oparg{stack} and put
		it under the top object on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (2 1 0) dup sunder pstack
(2 1 1 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sup}
\index{sup@\onyxop{}{sup}{}}
\item[{\onyxop{stack}{sup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Rotate the top three objects on \oparg{stack} up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup sup pstack
(3 0 2 1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:symlink}
\index{symlink@\onyxop{}{symlink}{}}
\item[{\onyxop{filename linkname}{symlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[linkname: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a symbolic link from \oparg{linkname} to
		\oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' `/tmp/bar' symlink
onyx:0> `/tmp/bar' `r' open
onyx:1> readline
onyx:2> pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:system}
\index{system@\onyxop{}{system}{}}
\item[{\onyxop{args}{system}{status}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of the program to invoke, and any additional
			array elements are passed as command line arguments to
			the invoked program.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[status: ]
			Exit code of terminated process.  A negative value
			indicates that the process was terminated by a signal
			(use the \htmlref{\onyxop{}{neg}{}}{systemdict:neg}
			operator to get the signal number), and a non-negative
			value is the exit code of a program that terminated
			normally.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Execute a program as a child process and wait for it to
		terminate.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`/usr/bin/which' `onyx'] system
/usr/local/bin/onyx
onyx:1> 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:systemdict}
\index{systemdict@\onyxop{}{systemdict}{}}
\item[{\onyxop{--}{systemdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get systemdict.  See Section~\ref{sec:systemdict} for details on
		systemdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> systemdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:tell}
\index{tell@\onyxop{}{tell}{}}
\item[{\onyxop{file}{tell}{offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fil: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[offset: ]
			Offset of the file position pointer for \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the file position pointer offset for \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup tell 1 sprint
0
onyx:1> dup `Hello\n' write
onyx:1> dup tell 1 sprint
6
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:test}
\index{test@\onyxop{}{test}{}}
\item[{\onyxop{file/filename flag}{test}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[flag: ]
			A single-character string that represents the test to do
			on \oparg{file} or \oparg{filename}:
			\begin{description}%\item[]
			\item[`b': ]
				Block special device?
			\item[`c': ]
				Character special device?
			\item[`d': ]
				Directory?
			\item[`e': ]
				Exists?
			\item[`f': ]
				Regular file?
			\item[`g': ]
				Setgid?
			\item[`k': ]
				Sticky?
			\item[`p': ]
				Named pipe?
			\item[`r': ]
				Readable?
			\item[`s': ]
				Size greater than 0?
			\item[`t': ]
				tty?
			\item[`u': ]
				Setuid?
			\item[`w': ]
				Write bit set?
			\item[`x': ]
				Executable bit set?
			\item[`L': ]
				Symbolic link?
			\item[`O': ]
				Owner matches effective uid?
			\item[`G': ]
				Group matches effective gid?
			\item[`S': ]
				Socket?
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true, the test evaluated to true; false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Test a file for an attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/blah' `e' test 1 sprint
false
onyx:0> `/tmp' `e' test 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:thread}
\index{thread@\onyxop{}{thread}{}}
\item[{\onyxop{stack entry}{thread}{thread}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack that contains the contents for the new thread's
			ostack.
		\item[entry: ]
			An initial object to execute in the new thread.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object that corresponds to the new thread.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create and run a new thread.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint} thread join `Done\n' print flush
3
Done
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:threaddstack}
\index{threaddstack@\onyxop{}{threaddstack}{}}
\item[{\onyxop{thread}{threaddstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The dictionary stack belonging to \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get a reference to the dictionary stack belonging to
		\oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self threaddstack 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:threadestack}
\index{threadestack@\onyxop{}{threadestack}{}}
\item[{\onyxop{thread}{threadestack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The execution stack belonging to \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get a reference to the execution stack belonging to
		\oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self threadestack 1 sprint
(-file- -array- --eval-- --ifelse-- -array- --for-- -array-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:threadistack}
\index{threadistack@\onyxop{}{threadistack}{}}
\item[{\onyxop{thread}{threadistack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The index stack belonging to \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get a reference to the index stack belonging to \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self threadistack 1 sprint
(0 0 0 0 7 0 3)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:threadostack}
\index{threadostack@\onyxop{}{threadostack}{}}
\item[{\onyxop{thread}{threadostack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			The operand stack belonging to \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get a reference to the operand stack belonging to
		\oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self threadostack 1 sprint
(-stack- -stack- -stack- -stack-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:threadsdict}
\index{threadsdict@\onyxop{}{threadsdict}{}}
\item[{\onyxop{--}{threadsdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.  Each key is a thread reference.  By
			default, each value is null, but this need not be so,
			and the value can be redefined for debugging purposes.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a dictionary containing references to all threads.
	\item[Example(s): ]\begin{verbatim}

onyx:0> threadsdict 1 sprint
<-thread- null>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:throw}
\index{throw@\onyxop{}{throw}{}}
\item[{\onyxop{name}{throw}{obj}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ] The name of an error.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[obj: ]
			The object that was being executed when the error was
			thrown.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Throw an error, using the following steps:
		\begin{enumerate}
		\item{Set newerror in the currenterror dictionary to true.}
		\item{Set errorname in the currenterror dictionary to
		\oparg{name}.}
		\item{Set ostack, dstack, estack, and istack in the currenterror
		dictionary to be current stack snapshots.}
		\item{Push the object that was being executed before throw was
		called onto ostack.}
		\item{If there is an error handler in the errordict dictionary
		that corresponds to \oparg{name}, evaluate it.  Otherwise,
		evaluate errordict's
		\htmlref{\onyxop{}{handleerror}{}}{errordict:handleerror} and
		\htmlref{\onyxop{}{stop}{}}{errordict:stop} operators.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> $unregistered throw
Error $unregistered
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:1> pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:timedwait}
\index{timedwait@\onyxop{}{timedwait}{}}
\item[{\onyxop{condition mutex timeout}{timedwait}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[mutex: ]
			A mutex object that this thread currently owns.
		\item[timeout: ]
			Minimum number of nanoseconds to wait for
			\oparg{condition}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise timeout.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait on \oparg{condition} for at least \oparg{timeout}
		nanoseconds.  \oparg{mutex} is atomically released when the
		current thread blocks, then acquired again before the current
		thread runs again.  Using a mutex that the current thread does
		not own will result in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> 1000000000 timedwait 1 sprint unlock join
false
onyx:0> mutex condition 1 idup dup lock 1000000000 timedwait 1 sprint unlock
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:token}
\index{token@\onyxop{}{token}{}}
\item[{\onyxop{file/string}{token}{false}}: ]
\item[{\onyxop{file/string}{token}{file/substring obj true}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file that is used as onyx source code to scan a token
			from.
		\item[string: ]
			A string that is used as onyx source code to scan a
			token from.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			The same file object that was passed in.
		\item[substring: ]
			The remainder of \oparg{string} after scanning a token.
		\item[obj: ]
			An object that was constructed by scanning a token.
		\item[false/true: ]
			If true, a token was successfully scanned, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{syntaxerror}{syntaxerror}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Scan a token from a file or string, using onyx syntax rules.  If
		a token is followed by whitespace, one character of whitespace
		is consumed when the token is scanned.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2' token pstack clear
true
1
`2'
onyx:0> `foo' token pstack clear
true
foo
`'
onyx:0> `foo ' token pstack clear
true
foo
`'
onyx:0> `foo  ' token pstack clear
true
foo
` '
onyx:0> `foo$bar' token pstack clear
true
foo
`$bar'
onyx:0> `foo{}' token pstack clear
true
foo
`{}'
onyx:0> ` ' token pstack clear
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:trunc}
\index{trunc@\onyxop{}{trunc}{}}
\item[{\onyxop{a}{trunc}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer created from \oparg{a} by discarding the
			fractional portion.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Discard the fractional portion of \oparg{a} to create an
		integer, and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 trunc 1 sprint
-1
onyx:0> -1.49 trunc 1 sprint
-1
onyx:0> 0 trunc 1 sprint
0
onyx:0> 1.49 trunc 1 sprint
1
onyx:0> 1.51 trunc 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:truncate}
\index{truncate@\onyxop{}{truncate}{}}
\item[{\onyxop{file length}{truncate}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[length: ]
			New length for \oparg{file}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the length of \oparg{file} to \oparg{length}.  If this
		causes the file to grow, the appended bytes will have the
		value zero.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hello\n'
onyx:1> dup 3 truncate
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hel'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:true}
\index{true@\onyxop{}{true}{}}
\item[{\onyxop{--}{true}{true}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[true: ]
			The boolean value true.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:trylock}
\index{trylock@\onyxop{}{trylock}{}}
\item[{\onyxop{mutex}{trylock}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, \oparg{mutex} was successfully acquired.
			Otherwise the mutex acquisition failed.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Try to acquire \oparg{mutex}, but return a failure immediately
		if \oparg{mutex} cannot be acquired, rather than blocking.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup 
onyx:2> trylock 1 sprint
false
onyx:1> trylock 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:tuck}
\index{tuck@\onyxop{}{tuck}{}}
\item[{\onyxop{a b}{tuck}{b a b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[: ]
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the top object on ostack and put it under
		the second object on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 
oonyx:3> tuck pstack
`c'
`b'
`c'
`a'
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:type}
\index{type@\onyxop{}{type}{}}
\item[{\onyxop{obj}{type}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			An executable name that corresponds to the type of
			\oparg{obj}:
			\begin{description}
			\item[array: ] arraytype.
			\item[boolean: ] booleantype.
			\item[condition: ] conditiontype.
			\item[dict: ] dicttype.
			\item[file: ] filetype.
			\item[fino: ] finotype.
			\item[hook: ] hooktype.
			\item[integer: ] integertype.
			\item[mark: ] marktype.
			\item[mutex: ] mutextype.
			\item[name: ] nametype.
			\item[null: ] nulltype.
			\item[operator: ] operatortype.
			\item[pmark: ] pmarktype.
			\item[stack: ] stacktype.
			\item[string: ] stringtype.
			\item[thread: ] threadtype.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Get a name that represent the type of \oparg{obj}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true type 1 sprint
booleantype
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:uid}
\index{uid@\onyxop{}{uid}{}}
\item[{\onyxop{--}{uid}{uid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[uid: ]
			Process's user ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's user ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> uid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:umask}
\index{umask@\onyxop{}{umask}{}}
\item[{\onyxop{nmask}{umask}{omask}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[nmask: ]
			Value to set umask to.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[omask: ]
			Old umask.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's umask to \oparg{nmask} and return the old
		umask.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 8@777 umask <$b 8 $w 3 $p `0'> output `\n' print flush
022
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:undef}
\index{undef@\onyxop{}{undef}{}}
\item[{\onyxop{dict key}{undef}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\item[val: ]
			A key in \oparg{dict} to undefine.
		\end{description}
	\item[Output(s): ] None
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		If \oparg{key} is defined in \oparg{dict}, undefine it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $foo `foo' def
onyx:0> currentdict $foo undef
onyx:0> currentdict $foo undef
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:under}
\index{under@\onyxop{}{under}{}}
\item[{\onyxop{a b}{under}{a a b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the second object on ostack and put it
		under the top object on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 2 under pstack
2
1
1
0
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:unlink}
\index{unlink@\onyxop{}{unlink}{}}
\item[{\onyxop{filename}{unlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Unlink \oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' unlink
onyx:0> `/tmp/foo' `r' open
Error $invalidfileaccess
ostack: (`/tmp/foo' `r')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --open--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:unlock}
\index{unlock@\onyxop{}{unlock}{}}
\item[{\onyxop{mutex}{unlock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Unlock \oparg{mutex}.  Unlocking a mutex that the running thread
		does not own will result in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup lock unlock
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:unsetenv}
\index{unsetenv@\onyxop{}{unsetenv}{}}
\item[{\onyxop{key}{unsetenv}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A name object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Unset \oparg{key} in the environment and in the envdict
		dictionary, if \oparg{key} is defined.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $foo `foo' setenv
onyx:0> envdict $foo known 1 sprint
true
onyx:0> envdict $foo get 1 sprint
`foo'
onyx:0> $foo unsetenv
onyx:0> envdict $foo known 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:until}
\index{until@\onyxop{}{until}{}}
\item[{\onyxop{proc cond}{until}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			An object to be repeatedly evaluated.
		\item[cond: ]
			An object that, when evaluated, places a boolean on
			ostack.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Repeatedly evaluate \oparg{proc} and \oparg{cond}, terminating
		the first time that \oparg{cond} places false on ostack.  This
		operator supports the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 {inc dup 1 sprint}{dup 3 lt} until pop
1
2
3
onyx:0> 0 {inc dup 1 sprint exit}{dup 3 lt} until pop
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:up}
\index{up@\onyxop{}{up}{}}
\item[{\onyxop{a b c}{up}{c a b}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\item[c: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[c: ]
			An object.
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Rotate the top three objects on ostack up one position.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' `d' up pstack
`c'
`b'
`d'
`a'
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:userdict}
\index{userdict@\onyxop{}{userdict}{}}
\item[{\onyxop{--}{userdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get userdict.  See Section~\ref{sec:userdict} for details on
		userdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> userdict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:version}
\index{version@\onyxop{}{version}{}}
\item[{\onyxop{--}{version}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the version name.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the version string.  The string returned is a reference to
		the original version string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> version pstack
`1.0.0'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:wait}
\index{wait@\onyxop{}{wait}{}}
\item[{\onyxop{condition mutex}{wait}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[mutex: ]
			A mutex object that this thread currently owns.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait on \oparg{condition}.  \oparg{mutex} is atomically released
		when the current thread blocks, then acquired again before the
		current thread runs again.  Using a mutex that the current
		thread does not own will result in undefined behavior (likely
		crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:waitpid}
\index{waitpid@\onyxop{}{waitpid}{}}
\item[{\onyxop{pid}{waitpid}{status}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[status: ]
			Exit code of terminated process.  A negative value
			indicates that the process was terminated by a signal
			(use the \htmlref{\onyxop{}{neg}{}}{systemdict:neg}
			operator to get the signal number), and a non-negative
			value is the exit code of a program that terminated
			normally.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for the process with process ID \oparg{pid} to exit.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`/bin/date'] forkexec dup 1 sprint waitpid 1 sprint
6516
Sat Jul 13 20:47:54 PDT 2002
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:where}
\index{where@\onyxop{}{where}{}}
\item[{\onyxop{key}{where}{false}}: ]
\item[{\onyxop{key}{where}{dict true}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A key to search for in dstack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The topmost dictionary in dstack that contains a
			definition for \oparg{key}.
		\item[false/true: ]
			If false, no definition of \oparg{key} was found in
			dstack.  Otherwise \oparg{dict} is the topmost
			dictionary in dstack that contains a definition for
			\oparg{key}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Get the topmost dictionary in dstack that defines \oparg{key}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> $foo where pstack clear
false
onyx:0> $threaddict where pstack clear
true
<$threaddict -dict- $userdict -dict- $currenterror -dict- $errordict -dict-
$resume --stop-->
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:while}
\index{while@\onyxop{}{while}{}}
\item[{\onyxop{cond proc}{while}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[cond: ]
			An object that, when evaluated, places a boolean on
			ostack.
		\item[proc: ]
			An object to be repeatedly evaluated.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Repeatedly evaluate \oparg{cond} and \oparg{proc}, terminating
		the first time that \oparg{cond} places false on ostack.  This
		operator supports the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 {dup 3 lt}{inc dup 1 sprint} while pop
1
2
3
onyx:0> 0 {dup 3 lt}{inc dup 1 sprint exit} while pop
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:write}
\index{write@\onyxop{}{write}{}}
\item[{\onyxop{file integer/string}{write}{false}}: ]
\item[{\onyxop{file integer/string}{write}{integer/substring true}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[integer: ]
			An integer that represents an ascii character value.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[false: ]
			Successful complete write.
		\item[integer: ]
			The \oparg{integer} that was passed in.
		\item[substring: ]
			The substring of \oparg{string} that was not written.
		\item[true: ]
			Successful partial write.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Write \oparg{integer} or \oparg{string} to \oparg{file}.
		Partial writes can only happen for non-blocking files.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write pop
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:xcheck}
\index{xcheck@\onyxop{}{xcheck}{}}
\item[{\onyxop{obj}{xcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[obj: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{obj} has the executable or evaluatable
			attribute, false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Check \oparg{obj} for executable or evaluatable attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} xcheck 1 sprint
true
onyx:0> [1 2 3] xcheck 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:xor}
\index{xor@\onyxop{}{xor}{}}
\item[{\onyxop{a b}{xor}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			exclusive or, otherwise their logical exclusive or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise exclusive or of two integers, or the logical
		exclusive or of two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true false xor 1 sprint
true
onyx:0> true true xor 1 sprint
false
onyx:0> 5 3 xor 1 sprint
6
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:yield}
\index{yield@\onyxop{}{yield}{}}
\item[{\onyxop{--}{yield}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Vuluntarily yield the processor, so that another thread or
		process may be run.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 100000 {1 add yield} repeat 1 sprint
100000
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{threaddict}
\label{sec:threaddict}
\index{threaddict@\onyxop{}{threaddict}{}}

Each thread has its own threaddict, which is not shared with any other threads.
threaddict is meant to be used for thread-specific definitions that would
otherwise go in systemdict.

\begin{longtable}{\optableformat{4.10}}
\caption{threaddict summary}
\\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
\optableent
	{Input(s)}
	{Op/Proc/Var}
	{Output(s)}
	{Description}
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\optableent
	{--}
	{{\bf \htmlref{threaddict}{threaddict:threaddict}}}
	{dict}
	{Get threaddict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{userdict}{threaddict:userdict}}}
	{dict}
	{Get userdict.}
\hline
\optableent
	{--}
	{{\bf \htmlref{currenterror}{threaddict:currenterror}}}
	{dict}
	{Get currenterror.}
\hline
\optableent
	{--}
	{{\bf \htmlref{errordict}{threaddict:errordict}}}
	{dict}
	{Get errordict.}
\end{longtable}

\begin{description}
\label{threaddict:currenterror}
\index{currenterror@\onyxop{}{currenterror}{}}
\item[{\onyxop{--}{currenterror}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The currenterror dictionary.  See
			Section~\ref{sec:currenterror} for details on
			currenterror.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get currenterror.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currenterror 0 sprint
-dict-
onyx:0>
	\end{verbatim}
	\end{description}
\label{threaddict:errordict}
\index{errordict@\onyxop{}{errordict}{}}
\item[{\onyxop{--}{errordict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The errordict dictionary.  See
			Section~\ref{sec:errordict} for details on errordict.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get errordict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> errordict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{threaddict:threaddict}
\index{threaddict@\onyxop{}{threaddict}{}}
\item[{\onyxop{--}{threaddict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The threaddict dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get threaddict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> threaddict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{threaddict:userdict}
\index{userdict@\onyxop{}{userdict}{}}
\item[{\onyxop{--}{userdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The userdict dictionary.  See
			Section~\ref{sec:userdict} for details on userdict.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get userdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> userdict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{threadsdict}
\label{sec:threadsdict}
\index{threadsdict@\onyxop{}{threadsdict}{}}

There is one entry in threadsdict for each thread.  The key is the thread, and
the value is null by default.  The value can be safely changed, which can be
useful when debugging.  However, the key must not be changed, or garbage
collection will trigger a horrible death, since the root set will not be
complete.

\subsection{userdict}
\label{sec:userdict}
\index{userdict@\onyxop{}{userdict}{}}

Each thread has its own userdict, which is not shared with any other threads.
userdict is meant to be used for general storage of definitions that do not need
to be shared among threads.  userdict starts out empty when a thread is
created.

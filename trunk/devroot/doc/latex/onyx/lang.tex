%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx reference portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Reference}
\label{onyxlang}

Onyx is a stack-based, threaded, interpreted language.  Its closest relative is
Adobe PostScript, followed by Forth.  Experienced PostScript programmers should
find most aspects of Onyx familiar, but there are significant differences that
will prevent a knowledgeable PostScript programmer from programming in Onyx
without first skimming this chapter.  This chapter does not assume specific
knowledge of other programming languages, so stands as a definitive reference
for Onyx.

Onyx is different from most languages in that it is not compiled, but rather
consumed.  For example, there are mechanisms for creating the equivalent of
named procedures that can be called at a later time, but behind the scenes, the
code is actually being interpreted as it is scanned in such a way that an
executable object is created.  As such, Onyx is not suited for compilation,
native or byte code.  However, the language syntax is very simple and the
scanner/parser is extremely fast.  There is also a mechanism for binding
procedures, which makes interpreter performance approximately the same as would
be expected of a byte code interpreter.

Onyx is implemented as a C library that can be embedded in other programs.
Mechanisms are provided for extending the set of operators available.  This
manual only documents the base language; see application-specific documentation
for any language extensions.

Following is a list of basic language features that are discussed in more detail
later in this chapter:

\begin{itemize}
\item{Stack-based.  There are no named variables as in procedural languages.
Operations are done using various stacks, so Onyx operations are coded in
postfix order.}
\item{Threaded.  Onyx's threading uses the native POSIX threads implementation
of the operating system.}
\item{Interpreted.  Onyx code is never compiled, but is instead interpreted as
it is encountered.}
\item{Garbage-collected.  There is no need to manually track memory allocation,
since the interpreter has an integrated automatic mark and sweep garbage
collector.}
\end{itemize}

\section{Objects}
\label{sec:onyx_objects}

An Onyx object has three aspects: type, attribute, and value.

Objects fall into two categories according to type: simple and composite.  A
simple object takes up no memory of its own; it uses space within a stack,
array, or dictionary.  A composite object requires space of its own in addition
to the space taken up in stacks, arrays, or dictionaries to refer to the
composite object.  See Table~\ref{simple-composite} for object type
classifications.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Simple	& Composite	\\
\hline \hline
boolean	& array		\\
fino	& condition	\\
integer	& dict		\\
mark	& file		\\
name	& hook		\\
null	& mutex		\\
operator & stack	\\
pmark	& string	\\
real	& thread	\\
\hline
\end{tabular}
\end{center}
\caption{\label{simple-composite}
Simple and composite types}
\end{table}

There can be multiple references that refer to the same memory backing composite
objects.  In most cases, composite objects that refer to the same memory are
indistinguishable, but for arrays and strings, composite objects may only be
able to access a subset of the total memory backing them.  This behavior is
described in detail later.

All objects have a literal, executable, or evaluatable attribute associated with
them.  Composite objects each have their own attribute, even for composite
objects that share the same backing memory.  Objects are ``interpreted'' when
they are encountered directly by the interpreter.  Objects can also be
``evaluated''.  One of two actions is taken when an object is interpreted or
evaluated:

\begin{itemize}
\item{The object may be treated as code (executed).  When executed, an object is
pushed onto the execution stack and executed.}
\item{The object may be treated as data.  A data object is push onto the operand
stack.}
\end{itemize}

Table~\ref{interp-act} enumerates under what circumstances object interpretation
results in execution.  Table~\ref{eval-act} enumerates under what circumstances
object evaluation results in execution.  Note that executable arrays are the
only objects that behave differently when interpreted versus evaluated.

In practice, attributes are only useful for types that can be executed.
Attributes are not considered in equality test operations.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Type		& \multicolumn{3}{|c|}{Attribute}	\\
\cline{2-4}
		& literal & executable & evaluatable	\\
\hline \hline
array		& data	& data	& code	\\
\hline
boolean		& data	& data	& data	\\
\hline
condition	& data	& data	& data	\\
\hline
dict		& data	& data	& data	\\
\hline
file		& data	& code	& code	\\
\hline
fino		& data	& data	& data	\\
\hline
hook		& data	& code	& code	\\
\hline
integer		& data	& data	& data	\\
\hline
mark		& data	& data	& data	\\
\hline
mutex		& data	& data	& data	\\
\hline
name		& data	& code	& code	\\
\hline
null		& data	& code	& code	\\
\hline
operator	& data	& code	& code	\\
\hline
pmark		& data	& data	& data	\\
\hline
real		& data	& data	& data	\\
\hline
stack		& data	& data	& data	\\
\hline
string		& data	& code	& code	\\
\hline
thread		& data	& data	& data	\\
\hline
\end{tabular}
\end{center}
\caption{\label{interp-act}
Interpretation of objects by type and attribute}
\end{table}

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Type		& \multicolumn{3}{|c|}{Attribute}	\\
\cline{2-4}
		& literal & executable & evaluatable	\\
\hline \hline
array		& data	& code	& code	\\
\hline
boolean		& data	& data	& data	\\
\hline
condition	& data	& data	& data	\\
\hline
dict		& data	& data	& data	\\
\hline
file		& data	& code	& code	\\
\hline
fino		& data	& data	& data	\\
\hline
hook		& data	& code	& code	\\
\hline
integer		& data	& data	& data	\\
\hline
mark		& data	& data	& data	\\
\hline
mutex		& data	& data	& data	\\
\hline
name		& data	& code	& code	\\
\hline
null		& data	& code	& code	\\
\hline
operator	& data	& code	& code	\\
\hline
pmark		& data	& data	& data	\\
\hline
real		& data	& data	& data	\\
\hline
stack		& data	& data	& data	\\
\hline
string		& data	& code	& code	\\
\hline
thread		& data	& data	& data	\\
\hline
\end{tabular}
\end{center}
\caption{\label{eval-act}
Evaluation of objects by type and attribute}
\end{table}

\begin{description}

\item[array: ] An array is an ordered sequence of objects of any type.  The
sequence of objects contained in an array is indexed starting at 0.  References
to existing arrays may be constructed such that a contiguous subsequence is
visible.  The following code creates such an array:

\begin{verbatim}
[0 1 2 3 4]
1 3 getinterval
\end{verbatim}

After the code executes, the array left on the operand stack looks like:

\begin{verbatim}
[1 2 3]
\end{verbatim}

Executable arrays are in effect procedures.  When an array is executed, its
elements are sequentially interpreted.

\item[boolean: ] A boolean can have two values: true or false.

\item[condition: ] A condition is used for thread synchronization.  The standard
operations on a condition are to wait and to signal.

\item[dict: ] A dict (short for dictionary) is a collection of key/value pairs.
Other names for dictionaries include ``associative array'' and ``hash''.  A key
can be of any type, though in most cases, keys are of type name.  A value can
also be of any type.

\item[file: ] A file is a handle to an ordered sequence of bytes with a current
position.  Read and write permissions are set when a file object is created.

When an executable file is executed, it is used as a source of Onyx code.  Data
are sequentially read from the file and interpreted until the end of the file is
reached.

\item[fino: ] A fino (first in, never out) is used as a stack marker when
constructing stacks.

\item[hook: ] The hook type is not used by the core Onyx language.  It can be
used by applications that extend the interpreter as a container object.  Hooks
can be executed, but the results are application dependent.

Each hook has a tag associated with it that can used by C extension code as a
form of type checking.  By default, the tag is a null object.  In most cases, an
application that extends the interpreter using hook objects will set hook tags
to be name objects.

\item[integer: ] An integer is a signed integer in the range $-2^{63}$ to
$2^{63} - 1$.

\item[mark: ] A mark is used as a stack marker for various stack operations.

\item[mutex: ] A mutex is a mutual exclusion lock.  Mutexes cannot be acquired
recursively, and the application must take care to unlock mutexes before
allowing them to be garbage collected (whether during normal program execution
or at program termination).

\item[name: ] A name is a key that uniquely identifies a sequence of characters.
Two name objects that correspond to the same sequence of characters can be
compared for equality with the same approximate cost as comparing two integers
for equality.  Names are typically used as keys in dictionaries.

When an executable name is executed, the topmost value in the dictionary stack
associated with the name is evaluated.

\item[null: ] A null has no significance other than its existence.  When an
executable null is executed, it does nothing.  Executable nulls can be useful as
place holders that can later be replaced with useful code, or for replacing
obsolete code so that the code is no longer executed.

\item[operator: ] An operator is an operation that is built in to the
interpreter.  Operators can be executed.

\item[pmark: ] A pmark is used as a stack marker when creating procedures in
deferred execution mode (i.e. procedures that use the \{\} syntax).  The
application will only encounter pmarks in error conditions, and there is never a
reason for an application to explicitly create a pmark.

\item[real: ] A real is a double precision (64 bit) floating point number.

\item[stack: ] A stack provides LIFO (last in, first out) access to objects that
it contains, as well as some more advanced access methods.  An application can
create, then manipulate stacks in much the same way that the operand stack can
be manipulated.

\item[string: ] A string is an ordered sequence of 8 bit characters.  The bytes
contained in an string are indexed starting at 0.  References to existing
strings may be constructed such that a contiguous subsequence is visible.  The
following code creates such a string:

\begin{verbatim}
`abcde'
1 3 getinterval
\end{verbatim}

After the code executes, the string left on the operand stack looks like:

\begin{verbatim}
`bcd'
\end{verbatim}

When an executable string is executed, its contents are used as a source of Onyx
code.

\item[thread: ] A thread object serves as a handle for operations such as
detaching and joining.

\end{description}

\section{Syntax}
\label{sec:onyx_syntax}
Onyx's syntax is very simple in comparison to most languages.  The scanner and
parser are implemented as a human-understandable finite state machine (nested C
switch statements with a couple of auxiliary variables), which should give the
reader an idea of the simplicity of the language syntax.

CRNL (carriage return, newline) pairs are in all important cases converted to
newlines during scanning.

The characters \%, /, {\lb}, {\rb}, \{, \}, (, ), `, ', {\lt}, and {\gt} are
special.  In most cases, any of the special characters and whitespace (space,
tab, newline, formfeed, null) terminate any preceding token.  All other
characters including non-printing characters are considered regular characters.

A comment starts with a \% character outside of a string context and extends to
the next newline or formfeed.

Procedures are actually executable arrays, but Onyx provides special syntax for
declaring procedures.  Procedures are delimited by \{ and \}, and can be
nested.  Normally, the interpreter executes code as it is scanned, but inside of
procedure declarations, execution is deferred.  Instead of executing a procedure
body as it is encountered, the tokens of the procedure body are pushed onto the
operand stack until the closing \} is encountered, at which time an executable
array is constructed from the tokens in the procedure body and pushed onto the
operand stack.

A partial grammar specification, using BNF notation (where convenient) is as
follows:

\begin{description}
\item[{\lt}program{\gt} ::= ] {\lt}statement{\gt}

\item[{\lt}statement{\gt} ::= ] {\lt}procedure{\gt} {\lt}statement{\gt} {\pipe}
{\lt}object{\gt} {\lt}statement{\gt} {\pipe} $\epsilon$

\item[{\lt}procedure{\gt} ::= ] \{{\lt}statement{\gt}\}

\item[{\lt}object{\gt} ::= ] {\lt}integer{\gt} {\pipe} {\lt}real{\gt} {\pipe}
{\lt}name{\gt} {\pipe} {\lt}string{\gt}

\item[{\lt}integer{\gt} ::= ] {\lt}dec\_integer{\gt} {\pipe}
{\lt}radix\_integer{\gt}

\item[{\lt}real{\gt} ::= ] {\lt}dec\_real{\gt} {\pipe} {\lt}exp\_real{\gt}

\item[{\lt}name{\gt} : ] Any token that cannot be interpreted as a number or a
string is interpreted as an executable name.  There are three syntaxes for
names: executable, literal and immediately evaluated.  Executable names are
looked up in the dictionary stack and executed (unless execution is deferred).
Literal names are simply pushed onto the operand stack.  Immediately evaluated
names are replaced by their values as defined in the dictionary stack, even if
execution is deferred.  Examples include:
\begin{verbatim}
foo     % executable
4noth3r % executable
/bar    % literal
//biz   % immediately evaluated
\end{verbatim}

If the result of an immediately evaluated name is an executable array, the
evaluatable attribute is set for the array so that when the array is
interpreted, it is executed.  This allows immediate evaluation to be
indiscriminately used without concern for whether the result is an executable
array or, say, an executable operator.

\item[{\lt}string{\gt} ::= ] `'-delimited string.  Ticks may
be embedded in the string without escaping them, as long as the unescaped ticks
are balanced.  The following sequences have special meaning when escaped by a
{\bs} character:
	\begin{description}
	\item[` ] ` character.
	\item[' ] ' character.
	\item[{\bs} ] {\bs} character.
	\item[n ] Newline.
	\item[r ] Carriage return.
	\item[t ] Tab.
	\item[b ] Backspace.
	\item[f ] Formfeed.
	\item[x{\lb}0-9a-fA-F{\rb}{\lb}0-9a-fA-F{\rb} ] Hex encoding for a byte.
	\item[{\bs}n (newline) ] Ignore.
	\item[{\bs}r{\bs}n (carriage return, newline) ] Ignore.
	\end{description}

{\bs} has no special meaning unless followed by a character in the above list.

Examples include:
\begin{verbatim}
`'
`A string.'
`An embedded \n newline.'
`Another embedded 
newline.'
`An ignored \
newline.'
`Balanced ` and ' are allowed.'
`Manually escaped \` tick.'
`Manually escaped \` tick and `balanced unescaped ticks'.'
`An actual \\ backslash.'
`Another actual \ backslash.'
\end{verbatim}

\item[{\lt}dec\_integer{\gt} : ] Signed integer in the range $-2^{63}$ to
$2^{63} - 1$.  The sign is optional.  Examples include:
\begin{verbatim}
0
42
-365
+17
\end{verbatim}

\item[{\lt}radix\_integer{\gt} : ] Signed integer with explicit base between 2
and 36, inclusive, in the range $-2^{63}$ to $2^{63} - 1$.  Integer digits are
composed of decimal numbers and lower or upper case letters.  The sign is
optional.  Examples include:
\begin{verbatim}
2#101
16#ff
16#Ff
16#FF
-10#42
10#42
+10#42
9#18
35#7r3x
35#7R3x
\end{verbatim}

\item[{\lt}dec\_real{\gt} : ] Double precision floating point number in decimal
notation.  At least one decimal digit and a decimal point are required.
Examples include:
\begin{verbatim}
0.
.0
3.
.141
3.141
42.75
+3.50
-5.0
\end{verbatim}

\item[{\lt}exp\_real{\gt} : ] Floating point number in exponential notation.
The format is the same as for {\lt}dec\_real{\gt}, except that an exponent is
appended.  The exponent is composed of an ``e'' or ``E'', an optional sign, and
a base 10 integer that is limited by the precision of the floating point format
(approximately $-308$ to $307$).  Examples include:
\begin{verbatim}
6.022e23
60.22e22
6.022e+23
1.661e-24
1.661E-24
\end{verbatim}

\end{description}

Arrays do not have explicit syntactic support, but the [ and ] operators support
their construction.  Examples of array construction include:
\begin{verbatim}
[]
[0 `A string' `Another string.' true]
[5
42
false]
\end{verbatim}

Dictionaries do not have explicit syntactic support, but the {\lt} and
{\gt} operators support their construction.  Examples of dictionary
construction include:
\begin{verbatim}
<>
</answer 42 /question `Who knows' /translate {babelfish} >
\end{verbatim}

Stacks do not have explicit syntactic support, but the ( and ) operators support
their construction.  Examples of stack contstruction include:
\begin{verbatim}
()
(1 2 mark `a')
\end{verbatim}

\section{Stacks}

Stacks in Onyx are the core data structure that programs act on.  Stacks store
objects in a last in, first out (LIFO) order.  Onyx includes a number of
operators that manipulate stacks.

Each Onyx thread has four program-visible stacks associated with it:
\begin{description}
\item[Operand stack (ostack): ] Most direct object manipulations are done using
	the operand stack.  Operators use the operand stack for inputs and
	outputs, and code generally uses the operand stack for a place to store
	objects as they are being manipulated.
\item[Dictionary stack (dstack): ] The dictionary stack is used for looking up
	names.  Each thread starts with with four dictionaries on its dictionary
	stack, which are, from top to bottom:
	\begin{itemize}
		\item{userdict}
		\item{globaldict}
		\item{systemdict}
		\item{threaddict}
	\end{itemize}
	The dictionary stack is manipulated via the
	\htmlref{\onyxop{}{begin}{}}{systemdict:begin} and
	\htmlref{\onyxop{}{end}{}}{systemdict:end} operators.  The initial
	dictionaries on the dictionary stack cannot be removed.
\item[Execution stack (estack): ] The interpreter uses the execution stack to
	store objects that are being executed.  The application generally does
	not need to explicitly manipulate the execution stack, but its contents
	are accessible, mainly for debugging purposes.
\item[Index stack (istack): ] The interpreter uses the index stack to store
	execution offsets for arrays that are being executed.  There is a one to
	one correspondence of the elements of the execution stack to the
	elements of the index stack, even though the elements of the index stack
	that do not correspond to arrays have no meaning.  The index stack does
	not affect execution, and exists purely to allow useful execution stack
	traces when errors occur.
\end{description}

The application can also create additional stacks and manipulate them in much
the same way as the operand stack can be manipulated.

\section{Interpreter recursion}

During typical Onyx interpreter initialization, the
\htmlref{\onyxop{}{start}{}}{systemdict:start} operator is executed, which in
turn executes a file object corresponding to stdin.  However, depending on how
the interpreter is invoked, the initial execution stack state may differ.

The interpreter can be recursively invoked.  For example, if the following code
is executed, the \htmlref{\onyxop{}{eval}{}}{systemdict:eval} operator
recursively invokes the interpreter to interpret the string.
\begin{verbatim}
`2 2 add' cvx eval
\end{verbatim}

The depth of the execution stack directly corresponds to the recursion depth of
the interpreter.  Execution stack depth is limited in order to catch unbounded
recursion.

Onyx converts tail calls in order to prevent unbounded execution stack growth
due to tail recursion.  For example, the following code does not cause the
execution stack to grow:

\begin{verbatim}
/foo {foo} def
foo
\end{verbatim}

The following code will result in an execution stack overflow:

\begin{verbatim}
/foo {foo `filler'} def
foo
\end{verbatim}

\section{Error handling}

The error handling mechanisms in Onyx are simple but flexible.  When an error
occurs, \htmlref{\onyxop{}{throw}{}}{systemdict:throw} is called.  An error can
have any name, but only the following error names are generated internally by
Onyx:
\begin{description}
\label{dstackunderflow}
\item[dstackunderflow: ] An attempt was made to remove one of the initial
dictionaries from dstack.
\label{estackoverflow}
\item[estackoverflow: ] Maximum interpreter recursion was exceeded.
\label{invalidaccess}
\item[invalidaccess: ] Permission error.
\label{invalidexit}
\item[invalidexit: ] The \onyxop{}{exit}{} operator was called outside of any
loop.  This error is generated as a result of catching an exit, so the execution
state for where the error really happened is gone.
\label{invalidfileaccess}
\item[invalidfileaccess: ] Insufficient file permissions.
\label{ioerror}
\item[ioerror: ] I/O error (read(), write(), etc.).
\label{limitcheck}
\item[limitcheck: ] Value outside of legal range.
\label{rangecheck}
\item[rangecheck: ] Out of bounds string or array access.
\label{stackunderflow}
\item[stackunderflow: ] Not enough objects on ostack.
\label{syntaxerror}
\item[syntaxerror: ] Scanner syntax error.
\label{typecheck}
\item[typecheck: ] Incorrect argument type.
\label{undefined}
\item[undefined: ] Name not defined in any of the dictionaries on dstack.
\label{undefinedfilename}
\item[undefinedfilename: ] Bad filename.
\label{undefinedresult}
\item[undefinedresult: ] Attempt to divide by 0.
\label{unmatchedfino}
\item[unmatchedfino: ] No fino on ostack.
\label{unmatchedmark}
\item[unmatchedmark: ] No mark on ostack.
\label{unregistered}
\item[unregistered: ] Non-enumerated error.
\end{description}

The Onyx scanner handles syntax errors specially, in that it pushes an
executable string onto the operand stack that represents the code that caused
the syntax error and records the line and column numbers in currenterror before
invoking \htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

The Onyx scanner also handles immediate name evaluation errors specially, in
that it pushes the name that could not be evaluated onto ostack before invoking
\htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

\section{Threads}

Onyx supports multiple threads of execution by using the operating system's
native threading facilities.  Along with threads comes the need for methods of
synchronization between threads.

\subsection{Implicit synchronization}
\label{sec:implicit_synchronization}

Implicit synchronization is a mandatory language feature, since objects such as
\htmlref{globaldict}{systemdict:globaldict} are implicitly accessed by the
interpreter, which makes it impossible to require the user to explicitly handle
all synchronization.  Onyx provides optional implicit synchronization
capabilities for composite objects on an object by object basis.  Each thread
has a setting which can be accessed via
\htmlref{\onyxop{}{currentlocking}{}}{systemdict:currentlocking} (initially set
to false) and set via \htmlref{\onyxop{}{setlocking}{}}{systemdict:setlocking}.
If implicit locking is active, then new objects will be created such that simple
accesses are synchronized.

Implicit synchronization can be a source of deadlock, so care must be taken when
accessing implicitly locked objects.  For example, if two threads copy two
implicitly locked strings to the other string, deadlock can result.

\begin{verbatim}
% Initialization.
/A `aaaaaa'
/B `bbbbbb'

...

% In thread A:
A B copy

...

% In thread B:
B A copy
\end{verbatim}

The following are descriptions of the implicit locking semantics for each type
of composite object:
\begin{description}
\item[array: ] Array copying is protected.  Array element modifications are
protected, but element reads are not protected.
\item[condition: ] No implicit locking is done for conditions.
\item[dict: ] All dict operations are protected.
\item[file: ] All file operations are protected.  There are no potential
deadlocks due to implicit file locking.
\item[hook: ] No implicit locking is done for hooks.
\item[mutex: ] No implicit locking is done for mutexes.
\item[stack: ] All stack operations are protected.  There are no potential
deadlocks due to implicit stack locking.  However, there are races in stack
copying, such that the results of copying a stack that is concurrently being
modified are unpredictable.  In addition, removing an object that is being
concurrently accessed from a stack is unsafe.
\item[string: ] String copying is protected.  Character access is protected by
many operators, but string copying is the only potential cause of deadlock for
string access.
\item[thread: ]  Implicit locking is not done for thread operations, since other
synchronization is adequate to protect thread objects.
\end{description}

\subsection{Explicit synchronization}

Onyx includes a foundation of mutexes and condition variables, with which all
other synchronization primitives can be constructed.

\section{Memory management}
Onyx programs do not need to track memory allocations, since memory reclamation
is done implicitly via automatic garbage collection.  Onyx uses an atomic mark
and sweep garbage collector.

The atomic nature of garbage collection may sound worrisome with regard to
performance, but in fact there are tangible benefits and no significant negative
impacts for most applications.  Total throughput is improved, since minimal
locking is necessary.  Concurrent garbage collection would impose a significant
locking overhead.

On the down side, atomic garbage collection cannot make strong real-time
guarantees.  However, the garbage collector is very efficient, and for typical
applications, garbage collection delays are measured in microseconds up to tens
of milliseconds on current hardware as of the year 2000.  For interactive
applications, anything under about 100 milliseconds is undetectable by the user,
so under normal circumstances the user will not notice that garbage collection
is happening.

There are three parameters that can be used to control garbage collection:
\begin{enumerate}
\item{The garbage collector can be turned off for situations where many objects
are being created over a short period of time.}
\item{The garbage collector runs whenever a certain number of bytes of memory
have been allocated since the last collection.  This threshold can be changed or
disabled.}
\item{If no composite objects have been created for an extended period of time
(seconds), the garbage collector will run if any composite objects have been
allocated since the last collection.  This idle timeout period can be changed or
disabled.}
\end{enumerate}

There is one situation in which it is possible for garbage to never be
collected, despite the garbage collector being properly configured.  Suppose
that a program creates some objects, the garbage collector runs, then the
program enters a code path that clobbers object references, such that the
objects could be collected, but no new objects are allocated.  In such a
situation, neither the allocation inactivity timer (period), nor the object
allocation threshold will trigger a collection, and garbage will remain
uncollected.  In practice this situation is unlikely, and is not a significant
problem since the program size is not growing.

Garbage collection is controlled via the \htmlref{gcdict}{systemdict:gcdict}
dictionary, which is described in Section~\ref{sec:gcdict}.

\section{Dictionary reference}

All operators built in to Onyx have corresponding names that are composed
entirely of lower case letters.  In order to avoid any possibility of namespace
collisions with names defined by current and future versions of Onyx, use at
least one character that is not a lower case letter in names (for example,
capital letters, numbers, underscore, etc.).

\subsection{currenterror}
\label{sec:currenterror}

Each thread has its own currenterror dictionary, which is used by the error
handling machinery to store error state.

\begin{longtable}{\optableformat{3}}
\caption[currenterror summary]{currenterror summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
-- & {\bf \htmlref{newerror}{currenterror:newerror}} & boolean & Set to true
during error handling. \\
\hline
-- & {\bf \htmlref{errorname}{currenterror:errorname}} & name & Name of most
recent error. \\
\hline
-- & {\bf \htmlref{line}{currenterror:line}} & number & Get line number of
syntax error. \\
\hline
-- & {\bf \htmlref{column}{currenterror:column}} & number & Get column number of
syntax error. \\
\hline
-- & {\bf \htmlref{ostack}{currenterror:ostack}} & stack & ostack snapshot. \\
\hline
-- & {\bf \htmlref{dstack}{currenterror:dstack}} & stack & dstack snaphot. \\
\hline
-- & {\bf \htmlref{estack}{currenterror:estack}} & stack & estack snapshot. \\
\hline
-- & {\bf \htmlref{istack}{currenterror:istack}} & stack & istack snapshot. \\
\end{longtable}

\begin{description}
\label{currenterror:column}
\index{column@\onyxop{}{column}{}}
\item[{\onyxop{--}{column}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			Column number, valid only if the error was a
			syntaxerror.  Column numbering starts at 0.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the column number that a syntaxerror occurred on.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2 3}' cvx eval
At line 1, column 5: Error /syntaxerror
ostack: (1 2 3 `}')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..3):
0:      `1 2 3}'
1:      --eval--
2:      -file-
3:      --start--
onyx:5> currenterror /column get 1 sprint
5
onyx:5>
		\end{verbatim}
	\end{description}
\label{currenterror:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A dstack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is a dstack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin dstack end 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:errorname}
\index{errorname@\onyxop{}{errorname}{}}
\item[{\onyxop{--}{errorname}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			Name of the most recent error.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the name of the most recent error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin errorname end 1 sprint
/undefined
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An estack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an estack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin estack end 1 sprint
(--start-- -file- x)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An istack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an istack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin istack end 1 sprint
(0 0 0)
onyx:1>
		\end{verbatim}
	\end{description}
\label{currenterror:newerror}
\index{newerror@\onyxop{}{newerror}{}}
\item[{\onyxop{--}{newerror}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			False if there has been no error since the last time
			newerror was reset; true otherwise.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a boolean that represents whether there has been an error
		since the last time newerror was set to false (as during
		interpreter initialization).  It is the application's
		responsibility to reset newerror after each error if it expects
		the value to be useful across multiple errors.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currenterror begin
onyx:0> newerror 1 sprint
false
onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> newerror 1 sprint
true
onyx:1> /newerror false def
onyx:1> newerror 1 sprint
false
onyx:1> resume
onyx:1> y
Error /undefined
ostack: (x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      y
1:      -file-
2:      --start--
onyx:2> newerror 1 sprint
true
onyx:2>
		\end{verbatim}
	\end{description}
\label{currenterror:line}
\index{line@\onyxop{}{line}{}}
\item[{\onyxop{--}{line}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			Line number, valid only if the error was a syntaxerror.
			Line numbering starts at 1.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the line number that a syntaxerror occurred on.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2 3}' cvx eval
At line 1, column 5: Error /syntaxerror
ostack: (1 2 3 `}')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..3):
0:      `1 2 3}'
1:      --eval--
2:      -file-
3:      --start--
onyx:5> currenterror /line get 1 sprint
1
onyx:5>
		\end{verbatim}
	\end{description}
\label{currenterror:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An ostack snapshot.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a stack that is an ostack snapshot as of the most recent
		error.
	\item[Example(s): ]\begin{verbatim}

onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
onyx:1> currenterror begin ostack end 1 sprint
()
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{envdict}
\label{sec:envdict}

The envdict dictionary contains keys of type name and values of type string that
correspond to the environment passed into the program.  All threads share the
same envdict, which is implicitly locked.  Modifications to envdict should be
made via the \htmlref{\onyxop{}{setenv}{}}{systemdict:setenv} and
\htmlref{\onyxop{}{unsetenv}{}}{systemdict:unsetenv} operators.  If envdict is
modified directly, the changes will not be visible to programs such as
\binname{ps}.

\subsection{errordict}
\label{sec:errordict}

Each thread has its own errordict, which is used by default by the error
handling machinery.

\begin{longtable}{\optableformat{3}}
\caption[errordict summary]{errordict summary} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
-- & {\bf \htmlref{handleerror}{errordict:handleerror}} & -- & Print a state
dump. \\
\hline
-- & {\bf \htmlref{stop}{errordict:stop}} & -- & Last operation during error
handling. \\
\end{longtable}

\begin{description}
\label{handleerror}
\label{errordict:handleerror}
\index{handleerror@\onyxop{}{handleerror}{}}
\item[{\onyxop{--}{handleerror}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		Under normal conditions, no errors occur.  However, it is
		possible for the application to corrupt the error handling
		machinery to the point that an error will occur.  If that
		happens, the result is possible infinite recursion, and program
		crashes are a real possibility.
	\item[Description: ]
		Print a dump of the most recent error recorded in the
		currenterror dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {true {true 1 sprint x y} if} eval
true
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1> errordict begin handleerror end
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..5):
0:      x
1: {
        true
        1
        sprint
 3:-->  x
        y
}
2:      --if--
3:      --eval--
4:      -file-
5:      --start--
onyx:1>
		\end{verbatim}
	\end{description}
\label{errordict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		This is called as the very last operation when an error occurs.
		Initially, its value is the same as that for the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operator in
		systemdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> errordict begin
onyx:0> /stop {`Custom stop\n' print flush quit} def
onyx:0> x
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      x
1:      -file-
2:      --start--
Custom stop
		\end{verbatim}
	\end{description}
\end{description}

\subsection{gcdict}
\label{sec:gcdict}

The gcdict dictionary provides garbage collection control and status
capabilities.

\begin{longtable}{\optableformat{3.75}}
\caption[gcdict summary]{gcdict summary by functional group}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{4}{|l|}{Control operators} \\
\hline \hline
-- & {\bf \htmlref{collect}{gcdict:collect}} & -- & Force a garbage
collection. \\
\hline
boolean & {\bf \htmlref{setactive}{gcdict:setactive}} & -- & Set whether the
garbage collector is active. \\
\hline
seconds & {\bf \htmlref{setperiod}{gcdict:setperiod}} & -- & Set the inactivity
period before the garbage collector will run. \\
\hline
count & {\bf \htmlref{setthreshold}{gcdict:setthreshold}} & -- & Set the number
of bytes of memory allocation that will trigger a garbage collection. \\
\hline \hline
\multicolumn{4}{|l|}{State and statistics operators} \\
\hline \hline
-- & {\bf \htmlref{active}{gcdict:active}} & boolean & Get whether the garbage
collector is active. \\
\hline
-- & {\bf \htmlref{period}{gcdict:period}} & seconds & Get the inactivity period
befor the garbage collector will run. \\
\hline
-- & {\bf \htmlref{threshold}{gcdict:threshold}} & count & Get the number of
bytes of memory allocation that will trigger a garbage collection. \\
\hline
-- & {\bf \htmlref{stats}{gcdict:stats}} & array & Get garbage collection
statistics. \\
\end{longtable}

\begin{description}
\label{gcdict:active}
\index{active@\onyxop{}{active}{}}
\item[{\onyxop{--}{active}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true, the garbage collector is active; otherwise it
			is not active.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get whether the garbage collector is active.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin active end 1 sprint
false
		\end{verbatim}
	\end{description}
\label{gcdict:collect}
\index{collect@\onyxop{}{collect}{}}
\item[{\onyxop{--}{collect}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Force a garbage collection.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin collect end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:period}
\index{period@\onyxop{}{period}{}}
\item[{\onyxop{--}{period}{seconds}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin period end 1 sprint
60
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setactive}
\index{setactive@\onyxop{}{setactive}{}}
\item[{\onyxop{boolean}{setactive}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true (initial setting), activate the garbage
			collector; otherwise deactivate the garbage collector.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set whether the garbage collector is active.  This setting takes
		effect asynchronously, so it is possible for the garbage
		collector to run even after it has been deactivated.  This
		setting overrides the allocation inactivity period and
		allocation threshold settings, so that if this setting is set to
		false, the other settings have no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin false setactive end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setperiod}
\index{setperiod@\onyxop{}{setperiod}{}}
\item[{\onyxop{seconds}{setperiod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seconds: ]
			The minimum number of seconds since the last object
			allocation that the garbage collector will wait before
			doing a garbage collection.  0 is treated specially to
			mean forever.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the minimum number of seconds of object allocation
		inactivity that the garbage collector will wait before doing a
		garbage collection.  This setting is disjoint from the threshold
		setting, and does not prevent garbage collection due to the
		threshold having been reached.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 60 setperiod end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:setthreshold}
\index{setthreshold@\onyxop{}{setthreshold}{}}
\item[{\onyxop{count}{setthreshold}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of bytes of memory allocation since the last
			garbage collection that will trigger a garbage
			collection.  0 is treated specially to mean infinity.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Set the number of bytes of memory allocation since the last
		garbage collection that will trigger a garbage collection.  This
		setting is disjoint from the inactivity period setting, and does
		not prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin 40000 setthreshold end
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:stats}
\index{stats@\onyxop{}{stats}{}}
\item[{\onyxop{--}{stats}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array with the format {\lb}collections count
			{\lb}ccount cmark csweep{\rb} {\lb}mcount mmark
			msweep{\rb} {\lb}scount smark ssweep{\rb}{\rb}, where
			the fields have the following meanings:
			\begin{description}\item[]
			\item[collections: ]
				Total number of collections the garbage
				collector has performed.
			\item[count: ]
				Current number of bytes of memory allocated.
			\item[ccount: ]
				Number of bytes of memory allocated as of the
				end of the most recent garbage collection.
			\item[cmark: ]
				Number of microseconds taken by the most recent
				garbage collection mark phase.
			\item[csweep: ]
				Number of microseconds taken by the most recent
				garbage collection sweep phase.
			\item[mcount: ]
				Largest number of bytes of memory ever allocated
				at any point in time.
			\item[mmark: ]
				Maximum number of microseconds taken by any
				garbage collection mark phase.
			\item[msweep: ]
				Number of microseconds taken by any garbage
				collection sweep phase.
			\item[scount: ]
				Total number of bytes of memory ever allocated.
			\item[smark: ]
				Total number of microseconds taken by all
				garbage collection mark phases.
			\item[ssweep: ]
				Total number of microseconds taken by all
				garbage collection sweep phases.
			\end{description}
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get statistics about the garbage collector.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin
onyx:0> stats 2 sprint
[23 72673 [72268 754 3467] [4752223 930 36492] [51057886 17448 136807]]
onyx:0>
		\end{verbatim}
	\end{description}
\label{gcdict:threshold}
\index{threshold@\onyxop{}{threshold}{}}
\item[{\onyxop{--}{threshold}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of bytes of memory allocation since the last
			garbage collection that will trigger a garbage
			collection.  0 is treated specially to mean infinity.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of bytes of memory allocation since the last
		garbage collection that will trigger a garbage collection.  This
		setting is disjoint from the inactivity period setting, and does
		not prevent garbage collection due to the allocation inactivity
		period having been exceeded.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict begin threshold end 1 sprint
65536
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{globaldict}
\label{sec:globaldict}

All threads share the same globaldict, which is meant as a repository for
globally shared objects.  globaldict is empty when the Onyx interpreter is
initialized, and is implicitly locked.

\subsection{onyxdict}
\label{sec:onyxdict}

Various portions of Onyx use the onyxdict dictionary for storage of
miscellaneous objects that normally should not be part of the namespace visible
to dstack searches.

\begin{longtable}{\optableformat{3}}
\caption[onyxdict summary]{onyxdict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
-- & {\bf \htmlref{mpath\_post}{onyxdict:mpath_post}} & array & Get path
searched by \htmlref{mrequire}{systemdict:mrequire}. \\
\hline
-- & {\bf \htmlref{mpath\_pre}{onyxdict:mpath_pre}} & array & Get path searched
by \htmlref{mrequire}{systemdict:mrequire}. \\
\hline
-- & {\bf \htmlref{rpath\_post}{onyxdict:rpath_post}} & array & Get path
searched by \htmlref{require}{systemdict:require}. \\
\hline
-- & {\bf \htmlref{rpath\_pre}{onyxdict:rpath_pre}} & array & Get path searched
by \htmlref{require}{systemdict:require}. \\
\end{longtable}

\begin{description}
\label{onyxdict:mpath_post}
\index{mpath_post@\onyxop{}{mpath\_post}{}}
\item[{\onyxop{--}{mpath\_post}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{mrequire}{systemdict:mrequire} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict /mpath_post get 1 sprint
[`/usr/local/share/onyx-3.0.0/nxm']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:mpath_pre}
\index{mpath_pre@\onyxop{}{mpath\_pre}{}}
\item[{\onyxop{--}{mpath\_pre}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{mrequire}{systemdict:mrequire} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict /mpath_pre get 1 sprint
[`' `.']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:rpath_post}
\index{rpath_post@\onyxop{}{rpath\_post}{}}
\item[{\onyxop{--}{rpath\_post}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{require}{systemdict:require} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict /rpath_post get 1 sprint
[`/usr/local/share/onyx-3.0.0/nx']
onyx:0>
		\end{verbatim}
	\end{description}
\label{onyxdict:rpath_pre}
\index{rpath_pre@\onyxop{}{rpath\_pre}{}}
\item[{\onyxop{--}{rpath\_pre}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of strings.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get an array of strings used by
		\htmlref{require}{systemdict:require} as prefixes for file
		searches.  The elements of the array are tried in the order
		listed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict /rpath_pre get 1 sprint
[`' `.']
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{outputsdict}
\label{sec:outputsdict}

The outputsdict dictionary is primarily used to support
\htmlref{\onyxop{}{outputs}{}}{systemdict:outputs}, but its contents may be of
use to an application that wishes to extend or modify formatted printing.

There is an entry in outputsdict for each Onyx type.  Each entry renders objects
that correspond to its name using optional flags stored in a dictionary.  The
following flags are supported for all types:
\begin{description}
\item[{\tt /n}: ]
	Maximum length, in bytes.  Default: disabled.
\item[{\tt /w}: ]
	Minimum length, in bytes.  Default: disabled.
\item[{\tt /j}: ]
	Justification.  Legal values:
	\begin{description}
	\item[{\tt /l}: ]
		Left.
	\item[{\tt /c}: ]
		Center.
	\item[{\tt /r}: ]
		Right (default).
	\end{description}
\item[{\tt /p}: ]
	Padding character.  Default: {\tt ` '}.
\item[{\tt /r}: ]
	Syntactic rendering recursion depth.  Default: 1.
\end{description}

The following additional flags are supported for integers:
\begin{description}
\item[{\tt /b}: ]
	Base, from 2 to 36.  Default: 10.
\item[{\tt /s}: ]
	Sign.  Legal values:
	\begin{description}
	\item[{\tt /-}: ]
		Only print sign if output is negative (default).
	\item[{\tt /+}: ]
		Always print sign.
	\end{description}
\end{description}

The following additional flags are supported for reals:
\begin{description}
\item[{\tt /d}: ]
	Digits of precision past decimal point.  Default: 6.
\item[{\tt /e}: ]
	Exponential notation, if true.  Default: false.
\end{description}

\begin{longtable}{\optableformat{3}}
\caption[outputsdict summary]{outputsdict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
array flags & {\bf \htmlref{arraytype}{outputsdict:arraytype}} & string &
Create formatted string from array. \\
\hline
boolean flags & {\bf \htmlref{booleantype}{outputsdict:booleantype}} & string &
Create formatted string from boolean. \\
\hline
condition flags & {\bf \htmlref{conditiontype}{outputsdict:conditiontype}} &
string & Create formatted string from condition. \\
\hline
dict flags & {\bf \htmlref{dicttype}{outputsdict:dicttype}} & string &
Create formatted string from dict. \\
\hline
file flags & {\bf \htmlref{filetype}{outputsdict:filetype}} & string &
Create formatted string from file. \\
\hline
fino flags & {\bf \htmlref{finotype}{outputsdict:finotype}} & string &
Create formatted string from fino. \\
\hline
hook flags & {\bf \htmlref{hooktype}{outputsdict:hooktype}} & string &
Create formatted string from hook. \\
\hline
integer flags & {\bf \htmlref{integertype}{outputsdict:integertype}} & string &
Create formatted string from integer. \\
\hline
mark flags & {\bf \htmlref{marktype}{outputsdict:marktype}} & string &
Create formatted string from mark. \\
\hline
mutex flags & {\bf \htmlref{mutextype}{outputsdict:mutextype}} & string &
Create formatted string from mutex. \\
\hline
name flags & {\bf \htmlref{nametype}{outputsdict:nametype}} & string &
Create formatted string from name. \\
\hline
null flags & {\bf \htmlref{nulltype}{outputsdict:nulltype}} & string &
Create formatted string from null. \\
\hline
operator flags & {\bf \htmlref{operatortype}{outputsdict:operatortype}} & string
& Create formatted string from operator. \\
\hline
pmark flags & {\bf \htmlref{pmarktype}{outputsdict:pmarktype}} & string &
Create formatted string from pmark. \\
\hline
real flags & {\bf \htmlref{realtype}{outputsdict:realtype}} & string &
Create formatted string from real. \\
\hline
stack flags & {\bf \htmlref{stacktype}{outputsdict:stacktype}} & string &
Create formatted string from stack. \\
\hline
string flags & {\bf \htmlref{stringtype}{outputsdict:stringtype}} & string &
Create formatted string from string. \\
\hline
thread flags & {\bf \htmlref{threadtype}{outputsdict:threadtype}} & string &
Create formatted string from thread. \\
\end{longtable}

\begin{description}
\label{outputsdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array flags}{arraytype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{array}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{array}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup </w 9 /p `_' /r 0> arraytype print `\n' print flush
__-array-
onyx:1> dup </w 9 /p `_' /r 1> arraytype print `\n' print flush
[1 -array- 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{outputsdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean flags}{booleantype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{boolean}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> false
onyx:1> dup </n 3> booleantype print `\n' print flush
fal
onyx:1> dup </n 7> booleantype print `\n' print flush
false
onyx:1>
		\end{verbatim}
	\end{description}
\label{outputsdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition flags}{conditiontype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{condition}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{condition}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> condition
onyx:1> </w 15 /p `_' /j /c> booleantype print `\n' print flush
__-condition-__
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict flags}{dicttype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{dict}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> </foo `foo'> </w 30 /p `.' /j /r> dicttype print `\n' print flush
..................</foo `foo'>
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file flags}{filetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> stdin
onyx:1> </w 30 /p `.' /j /c> filetype print `\n' print flush
............-file-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino flags}{finotype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{fino}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{fino}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> (
onyx:1> </w 30 /p `.' /j /c> finotype print `\n' print flush
............-fino-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:hooktype}
\index{hooktype@\onyxop{}{hooktype}{}}
\item[{\onyxop{hook flags}{hooktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{hook}.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a hook object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhook exists that
		creates a hook with a tag that is the name ``tagged''.
		\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> taggedhook
onyx:1> </w 30 /p `.' /j /l hooktype print `\n' print flush
=tagged=......................
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer flags}{integertype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{integer}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{integer}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> 42 </w 6 /p `_' /j /c /s /-> integertype print `\n' print flush
__42__
onyx:0> 42 </w 6 /p `_' /j /c /s /+> integertype print `\n' print flush
_+42__
onyx:0> `0x' print 42 </w 6 /p `0' /b 16> integertype print `\n' print flush
0x00002a
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark flags}{marktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{mark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> mark
onyx:1> </w 30 /p `.' /j /c> marktype print `\n' print flush
............-mark-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex flags}{mutextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{mutex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> mutex
onyx:1> </w 30 /p `.' /j /c> mutextype print `\n' print flush
...........-mutex-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name flags}{nametype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{name}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{name}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> /foo
onyx:1> </w 30 /p `.' /j /c> nametype print `\n' print flush
............./foo.............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null flags}{nulltype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{null}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{null}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> null
onyx:1> </w 30 /p `.' /j /c> nulltype print `\n' print flush
.............null.............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator flags}{operatortype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{operator}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{operator}.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> //realtime
onyx:1> </w 30 /p `.' /j /c> operatortype print `\n' print flush
.........--realtime--.........
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark flags}{pmarktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{pmark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{pmark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> { //x
Error /undefined
ostack: (-pmark- /x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> </w 30 /p `.' /j /c> pmarktype print `\n' print flush
...........-pmark-............
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:realtype}
\index{realtype@\onyxop{}{realtype}{}}
\item[{\onyxop{real flags}{realtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{real}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{real}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> 6.022e23 </d 4> realtype print `\n' print flush
602200000000000027262976.0000
onyx:0> 6.022e23 </d 4 /e true> realtype print `\n' print flush
6.0220e+23
onyx:0> 6.022e23 </d 0 /e true> realtype print `\n' print flush
6e+23
onyx:0> 6.022e23 </d 4 /w 40 /p `0'> realtype print `\n' print flush
00000000000602200000000000027262976.0000
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack flags}{stacktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup </w 9 /p `_' /r 0> stacktype print `\n' print flush
__-stack-
onyx:1> </w 9 /p `_' /r 1> stacktype print `\n' print flush
(1 -stack- 4)
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string flags}{stringtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> `A string'
onyx:1> </w 30 /p `.' /j /c> stringtype print `\n' print flush
...........A string...........
onyx:0>
		\end{verbatim}
	\end{description}
\label{outputsdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread flags}{threadtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\item[flags: ]
			Formatting flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Formatted string representation of \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict begin
onyx:0> () {} thread
onyx:1> </w 30 /p `.' /j /c> threadtype print `\n' print flush
...........-thread-...........
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{sprintsdict}
\label{sec:sprintsdict}

The sprintsdict dictionary is primarily used to support
\htmlref{\onyxop{}{sprints}{}}{systemdict:sprints}, but its contents may be of
use to an application that wishes to extend or modify syntactical printing.

There is an entry in sprintsdict for each Onyx type.  If there is a
syntactically valid representation for an object and the recursion depth is
greater than 0, the corresponding operator creates a string that syntactically
represents the object.  Otherwise, a string with a non-syntictical
representation of the object is created, except for booleans, integers, names,
nulls, reals, and strings, for which the results are always syntactical.  If the
recursion depth is greater than 0, the operators will recursively convert any
contained objects.

The implementation of \htmlref{\onyxop{}{sprints}{}}{systemdict:sprints} is
useful in illustrating a useful method of doing type-dependent operations:

\begin{verbatim}
/sprints {
        1 index type /sprintsdict load exch get eval
} def
\end{verbatim}

\begin{longtable}{\optableformat{3}}
\caption[sprintsdict summary]{sprintsdict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
array depth & {\bf \htmlref{arraytype}{sprintsdict:arraytype}} & string &
Create syntactical string from array. \\
\hline
boolean depth & {\bf \htmlref{booleantype}{sprintsdict:booleantype}} & string &
Create syntactical string from boolean. \\
\hline
condition depth & {\bf \htmlref{conditiontype}{sprintsdict:conditiontype}} &
string & Create syntactical string from condition. \\
\hline
dict depth & {\bf \htmlref{dicttype}{sprintsdict:dicttype}} & string &
Create syntactical string from dict. \\
\hline
file depth & {\bf \htmlref{filetype}{sprintsdict:filetype}} & string &
Create syntactical string from file. \\
\hline
fino depth & {\bf \htmlref{finotype}{sprintsdict:finotype}} & string &
Create syntactical string from fino. \\
\hline
hook depth & {\bf \htmlref{hooktype}{sprintsdict:hooktype}} & string &
Create syntactical string from hook. \\
\hline
integer depth & {\bf \htmlref{integertype}{sprintsdict:integertype}} & string &
Create syntactical string from integer. \\
\hline
mark depth & {\bf \htmlref{marktype}{sprintsdict:marktype}} & string &
Create syntactical string from mark. \\
\hline
mutex depth & {\bf \htmlref{mutextype}{sprintsdict:mutextype}} & string &
Create syntactical string from mutex. \\
\hline
name depth & {\bf \htmlref{nametype}{sprintsdict:nametype}} & string &
Create syntactical string from name. \\
\hline
null depth & {\bf \htmlref{nulltype}{sprintsdict:nulltype}} & string &
Create syntactical string from null. \\
\hline
operator depth & {\bf \htmlref{operatortype}{sprintsdict:operatortype}} & string
& Create syntactical string from operator. \\
\hline
pmark depth & {\bf \htmlref{pmarktype}{sprintsdict:pmarktype}} & string &
Create syntactical string from pmark. \\
\hline
real depth & {\bf \htmlref{realtype}{sprintsdict:realtype}} & string &
Create syntactical string from real. \\
\hline
stack depth & {\bf \htmlref{stacktype}{sprintsdict:stacktype}} & string &
Create syntactical string from stack. \\
\hline
string depth & {\bf \htmlref{stringtype}{sprintsdict:stringtype}} & string &
Create syntactical string from string. \\
\hline
thread depth & {\bf \htmlref{threadtype}{sprintsdict:threadtype}} & string &
Create syntactical string from thread. \\
\end{longtable}

\begin{description}
\label{sprintsdict:arraytype}
\index{arraytype@\onyxop{}{arraytype}{}}
\item[{\onyxop{array depth}{arraytype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{array}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{array}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> [1 [2 3] 4]
onyx:1> dup 0 arraytype print `\n' print flush
-array-
onyx:1> dup 1 arraytype print `\n' print flush
[1 -array- 4]
onyx:1> dup 2 arraytype print `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:booleantype}
\index{booleantype@\onyxop{}{booleantype}{}}
\item[{\onyxop{boolean depth}{booleantype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{boolean}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{boolean}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> true
onyx:1> dup 0 booleantype print `\n' print flush
true
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:conditiontype}
\index{conditiontype@\onyxop{}{conditiontype}{}}
\item[{\onyxop{condition depth}{conditiontype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{condition}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{condition}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> condition
onyx:1> dup 0 conditiontype print `\n' print flush
-condition-
onyx:1> dup 1 conditiontype print `\n' print flush
-condition-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:dicttype}
\index{dicttype@\onyxop{}{dicttype}{}}
\item[{\onyxop{dict depth}{dicttype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dict object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{dict}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> </a `a' /subdict </b `b'>>
onyx:1> dup 0 dicttype print `\n' print flush
-dict-
onyx:1> dup 1 dicttype print `\n' print flush
</subdict -dict- /a `a'>
onyx:1> dup 2 dicttype print `\n' print flush
</subdict </b `b'> /a `a'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:filetype}
\index{filetype@\onyxop{}{filetype}{}}
\item[{\onyxop{file depth}{filetype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> stdout
onyx:1> dup 0 filetype print `\n' print flush
-file-
onyx:1> dup 1 filetype print `\n' print flush
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:finotype}
\index{finotype@\onyxop{}{finotype}{}}
\item[{\onyxop{fino depth}{finotype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{fino}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{fino}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (
onyx:1> dup 0 finotype print `\n' print flush
-fino-
onyx:1> dup 1 finotype print `\n' print flush
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:hooktype}
\index{hooktype@\onyxop{}{hooktype}{}}
\item[{\onyxop{hook depth}{hooktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{hook}.
	\item[Example(s): ]
		The following example is a bit contrived, since there is no way
		to create a hook object with a stock onyx interpreter.
		Therefore, imagine that an operator named taggedhook exists that
		creates a hook with a tag that is the name ``tagged'', and that
		an operator named untaggedhook exists that creates an untagged
		hook.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> taggedhook
onyx:1> dup 0 hooktype print `\n' print flush
=tagged=
onyx:1> 1 hooktype print `\n' print flush
=tagged=
onyx:0> untaggedhook
onyx:1> dup 0 hooktype print `\n' print flush
-hook-
onyx:1> 1 hooktype print `\n' print flush
-hook-
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:integertype}
\index{integertype@\onyxop{}{integertype}{}}
\item[{\onyxop{integer depth}{integertype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{integer}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{integer}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42
onyx:1> dup 0 integertype print `\n' print flush
42
onyx:1> dup 1 integertype print `\n' print flush
42
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:marktype}
\index{marktype@\onyxop{}{marktype}{}}
\item[{\onyxop{mark depth}{marktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mark
onyx:1> dup 0 marktype print `\n' print flush
-mark-
onyx:1> dup 1 marktype print `\n' print flush
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:mutextype}
\index{mutextype@\onyxop{}{mutextype}{}}
\item[{\onyxop{mutex depth}{mutextype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{mutex}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> mutex
onyx:1> dup 0 mutextype print `\n' print flush
-mutex-
onyx:1> dup 1 mutextype print `\n' print flush
-mutex-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nametype}
\index{nametype@\onyxop{}{nametype}{}}
\item[{\onyxop{name depth}{nametype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ]
			A name object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{name}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{name}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> /foo
onyx:1> dup 0 nametype print `\n' print flush
/foo
onyx:1> dup 1 nametype print `\n' print flush
/foo
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:nulltype}
\index{nulltype@\onyxop{}{nulltype}{}}
\item[{\onyxop{null depth}{nulltype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{null}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{null}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> null
onyx:1> dup 0 nulltype print `\n' print flush
-null-
onyx:1> dup 1 nulltype print `\n' print flush
-null-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:operatortype}
\index{operatortype@\onyxop{}{operatortype}{}}
\item[{\onyxop{operator depth}{operatortype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[operator: ]
			An operator object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{operator}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{operator}.
	\item[Example(s): ]
		The following example shows an operator printed out with two
		leading and trailing dashes.  If the interpreter cannot
		determine the name associated with an operator, as will be the
		case for custom operators, the operator will be printed as
		{\tt -operator-}.
		\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> //realtime
onyx:1> dup 0 operatortype print `\n' print flush
--realtime--
onyx:1> 1 operatortype print `\n' print flush
--realtime--
onyx:0>
		\end{verbatim}
	\end{description}
\label{sprintsdict:pmarktype}
\index{pmarktype@\onyxop{}{pmarktype}{}}
\item[{\onyxop{pmark depth}{pmarktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pmark: ]
			A pmark object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{pmark}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{pmark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> { //x
Error /undefined
ostack: (-pmark- /x)
dstack: (-dict- -dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:3> pop pop resume
onyx:1> dup 0 pmarktype print `\n' print flush
-pmark-
onyx:1> dup 1 pmarktype print `\n' print flush
-pmark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:realtype}
\index{realtype@\onyxop{}{realtype}{}}
\item[{\onyxop{real depth}{realtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{real}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{real}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> 42.0
onyx:1> dup 0 realtype print `\n' print flush
4.200000e+01
onyx:1> dup 1 realtype print `\n' print flush
4.200000e+01
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stacktype}
\index{stacktype@\onyxop{}{stacktype}{}}
\item[{\onyxop{stack depth}{stacktype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> (1 (2 3) 4)
onyx:1> dup 0 stacktype print `\n' print flush
-stack-
onyx:1> dup 1 stacktype print `\n' print flush
(1 -stack- 4)
onyx:1> dup 2 stacktype print `\n' print flush
(1 (2 3) 4)
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:stringtype}
\index{stringtype@\onyxop{}{stringtype}{}}
\item[{\onyxop{string depth}{stringtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> `abcd'
onyx:1> dup 0 stringtype print `\n' print flush
`abcd'
onyx:1> dup 1 stringtype print `\n' print flush
`abcd'
onyx:1>
		\end{verbatim}
	\end{description}
\label{sprintsdict:threadtype}
\index{threadtype@\onyxop{}{threadtype}{}}
\item[{\onyxop{thread depth}{threadtype}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\item[depth: ]
			Recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			Syntactical string representation of \oparg{thread}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{thread}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict begin
onyx:0> thread
onyx:1> dup 0 threadtype print `\n' print flush
-thread-
onyx:1> dup 1 threadtype print `\n' print flush
-thread-
onyx:1>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{systemdict}
\label{sec:systemdict}

The systemdict dictionary contains most of the operators that are of general
use.  Although there are no mechanisms that prevent modification of systemdict,
programs should not normally need to modify systemdict, since globaldict
provides a place for storing globally shared objects.  All threads share the
same systemdict, which is implicitly locked.

\begin{longtable}{\optableformat{1.80}}
\caption[systemdict summary]{systemdict summary by functional group} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
\multicolumn{4}{|l|}{Operand stack operators} \\
\hline \hline
-- & {\bf \htmlref{mark}{systemdict:mark}} & mark & Create a mark. \\
\hline
-- & {\bf \htmlref{count}{systemdict:count}} & count & Get the number of objects
on ostack. \\
\hline
mark \dots & {\bf \htmlref{counttomark}{systemdict:counttomark}} & mark \dots
count & Get the depth of the topmost mark on ostack. \\
\hline
object & {\bf \htmlref{dup}{systemdict:dup}} & object object & Duplicate an
object. \\
\hline
objects count & {\bf \htmlref{ndup}{systemdict:ndup}} & objects objects &
Duplicate objects. \\
\hline
object \dots index & {\bf \htmlref{index}{systemdict:index}} & object \dots
object & Duplicate object on ostack at a given index. \\
\hline
a b & {\bf \htmlref{exch}{systemdict:exch}} & b a & Exchange the top two objects
on ostack. \\
\hline
\oparg{region} \oparg{count} \oparg{amount} & {\bf
\htmlref{roll}{systemdict:roll}} & \oparg{rolled} & Roll the top
\oparg{count} objects up by \oparg{amount}. \\
\hline
any & {\bf \htmlref{pop}{systemdict:pop}} & -- & Remove the top object from
ostack. \\
\hline
objects count & {\bf \htmlref{npop}{systemdict:npop}} & -- & Remove objects from
ostack. \\
\hline
objects & {\bf \htmlref{clear}{systemdict:clear}} & -- & Pop all objects off
ostack. \\
\hline
mark \dots & {\bf \htmlref{cleartomark}{systemdict:cleartomark}} & -- & Remove
objects from ostack through topmost mark. \\
\hline
-- & {\bf \htmlref{ostack}{systemdict:ostack}} & stack & Get a current ostack
snapshot. \\
\hline \hline
\multicolumn{4}{|l|}{Execution, control, and execution stack operators} \\
\hline \hline
object & {\bf \htmlref{eval}{systemdict:eval}} & -- & Evaluate object. \\
\hline
boolean object & {\bf \htmlref{if}{systemdict:if}} & -- & Conditionally evaluate
object. \\
\hline
boolean a b & {\bf \htmlref{ifelse}{systemdict:ifelse}} & -- & Conditionally
evaluate one of two objects. \\
\hline
init inc limit proc & {\bf \htmlref{for}{systemdict:for}} & -- & Iterate with a
control variable. \\
\hline
count proc & {\bf \htmlref{repeat}{systemdict:repeat}} & -- & Iterate a set
number of times. \\
\hline
proc & {\bf \htmlref{loop}{systemdict:loop}} & -- &  Iterate indefinitely. \\
\hline
array proc & {\bf \htmlref{foreach}{systemdict:foreach}} & -- & Iterate on array
elements. \\
dict proc & {\bf \htmlref{foreach}{systemdict:foreach}} & -- & Iterate on
dictionary key/value pairs. \\
stack proc & {\bf \htmlref{foreach}{systemdict:foreach}} & -- & Iterate on stack
elements. \\
string proc & {\bf \htmlref{foreach}{systemdict:foreach}} & -- & Iterate on
string elements. \\
\hline
-- & {\bf \htmlref{exit}{systemdict:exit}} & -- & Terminate innermost looping
context. \\
\hline
%begin{latexonly}
file/string & {\bf \htmlref{token}{systemdict:token}} & false & Scan for a
token. \\
file/string & {\bf \htmlref{token}{systemdict:token}} & rem object true & \\
\hline
%end{latexonly}
\begin{htmlonly}
file/string & {\bf \htmlref{token}{systemdict:token}} & false & Scan for a
token. \\
file/string & {\bf \htmlref{token}{systemdict:token}} & file/substring object
true & Scan for a token. \\
\end{htmlonly}
object & {\bf \htmlref{start}{systemdict:start}} & -- & Evaluate object. \\
\hline
-- & {\bf \htmlref{quit}{systemdict:quit}} & -- & Unwind to innermost start
context. \\
\hline
object & {\bf \htmlref{stopped}{systemdict:stopped}} & boolean & Evaluate
object. \\
\hline
-- & {\bf \htmlref{stop}{systemdict:stop}} & -- & Unwind to innermost stopped or
start context. \\
\hline
name & {\bf \htmlref{throw}{systemdict:throw}} & object & Throw an error. \\
\hline
-- & {\bf \htmlref{estack}{systemdict:estack}} & stack & Get a current estack
snapshot. \\
\hline
-- & {\bf \htmlref{countestack}{systemdict:countestack}} & count & Get current
estack depth. \\
\hline
-- & {\bf \htmlref{istack}{systemdict:istack}} & stack & Get a current istack
snapshot. \\
\hline
status & {\bf \htmlref{die}{systemdict:die}} & -- & Exit program. \\
\hline
path symbol & {\bf \htmlref{modload}{systemdict:modload}} & -- & Load a
module. \\
\hline
file symbol & {\bf \htmlref{mrequire}{systemdict:mrequire}} & -- & Search for
and load a module. \\
\hline
file & {\bf \htmlref{require}{systemdict:require}} & -- & Search for and
evaluate a source file. \\
\hline
-- & {\bf \htmlref{fork}{systemdict:fork}} & pid & Fork a new process. \\
\hline
args & {\bf \htmlref{exec}{systemdict:exec}} & -- & Overlay a new program and
execute it. \\
\hline
pid & {\bf \htmlref{waitpid}{systemdict:waitpid}} & status & Wait for a program
to terminate. \\
\hline
args & {\bf \htmlref{system}{systemdict:system}} & status & Execute a
program. \\
\hline
-- & {\bf \htmlref{pid}{systemdict:pid}} & pid & Get process ID. \\
\hline
-- & {\bf \htmlref{ppid}{systemdict:ppid}} & pid & Get parent's process ID. \\
\hline
-- & {\bf \htmlref{uid}{systemdict:uid}} & uid & Get the process's user ID. \\
\hline
uid & {\bf \htmlref{setuid}{systemdict:setuid}} & boolean & Set the process's
user ID. \\
\hline
-- & {\bf \htmlref{euid}{systemdict:euid}} & uid & Get the process's effective
user ID. \\
\hline
uid & {\bf \htmlref{seteuid}{systemdict:seteuid}} & boolean & Set the process's
effective user ID. \\
\hline
-- & {\bf \htmlref{gid}{systemdict:gid}} & gid & Get the process's group ID. \\
\hline
gid & {\bf \htmlref{setgid}{systemdict:setgid}} & boolean & Set the process's
group ID. \\
\hline
-- & {\bf \htmlref{egid}{systemdict:egid}} & gid & Get the process's effective
group ID. \\
\hline
gid & {\bf \htmlref{setegid}{systemdict:setegid}} & boolean & Set the process's
effective group ID. \\
\hline
-- & {\bf \htmlref{realtime}{systemdict:realtime}} & nsecs & Get the number of
nanoseconds since the epoch. \\
\hline
nanoseconds & {\bf \htmlref{nsleep}{systemdict:nsleep}} & -- & Nanosleep. \\
\hline \hline
\multicolumn{4}{|l|}{Stack operators} \\
\hline \hline
-- & {\bf \htmlref{(}{systemdict:sym_lp}} & fino & Begin a stack declaration. \\
\hline
fino objects & {\bf \htmlref{)}{systemdict:sym_rp}} & stack & Create a stack. \\
\hline
-- & {\bf \htmlref{stack}{systemdict:stack}} & stack & Create a stack. \\
\hline
stack object & {\bf \htmlref{spush}{systemdict:spush}} & -- & Push an object
onto a stack. \\
\hline
stack & {\bf \htmlref{scount}{systemdict:scount}} & count & Get the number of
objects on a stack. \\
\hline
stack & {\bf \htmlref{scounttomark}{systemdict:scounttomark}} & count & Get the
depth of the topmost mark on stack. \\
\hline
stack & {\bf \htmlref{sdup}{systemdict:sdup}} & -- & Duplicate an object. \\
\hline
stack index & {\bf \htmlref{sindex}{systemdict:sindex}} & -- & Duplicate object
in a stack at a given index. \\
\hline
stack & {\bf \htmlref{sexch}{systemdict:sexch}} & -- & Exchange top objects on
stack. \\
\hline
stack count amount & {\bf \htmlref{sroll}{systemdict:sroll}} & -- & Roll objects
on stack. \\
\hline
stack & {\bf \htmlref{spop}{systemdict:spop}} & object & Pop an object off
stack. \\
\hline
stack & {\bf \htmlref{sclear}{systemdict:sclear}} & -- & Remove all objects on
stack. \\
\hline
stack & {\bf \htmlref{scleartomark}{systemdict:scleartomark}} & -- & Remove
objects from stack down through topmost mark. \\
\hline
(a) (b) & {\bf \htmlref{cat}{systemdict:cat}} & (a b) & Catenate two stacks. \\
\hline
srcstack dststack & {\bf \htmlref{copy}{systemdict:copy}} & dststack & Copy
stack contents. \\
\hline \hline
\multicolumn{4}{|l|}{Number (integer, real) and math operators} \\
\hline \hline
a b & {\bf \htmlref{add}{systemdict:add}} & r & Add a and b. \\
\hline
a b & {\bf \htmlref{sub}{systemdict:sub}} & r & Subtract b from a. \\
\hline
a b & {\bf \htmlref{mul}{systemdict:mul}} & r & Multiply a and b. \\
\hline
a b & {\bf \htmlref{div}{systemdict:div}} & r & Divide a by b. \\
\hline
a b & {\bf \htmlref{idiv}{systemdict:idiv}} & r & Divide a by b (integers). \\
\hline
a b & {\bf \htmlref{mod}{systemdict:mod}} & r & Mod a by b (integers). \\
\hline
a b & {\bf \htmlref{exp}{systemdict:exp}} & r & Raise a to the power of b. \\
\hline
a & {\bf \htmlref{sqrt}{systemdict:sqrt}} & r & Square root. \\
\hline
a & {\bf \htmlref{ln}{systemdict:ln}} & r & Natural log. \\
\hline
a & {\bf \htmlref{log}{systemdict:log}} & r & Base 10 log. \\
\hline
a & {\bf \htmlref{abs}{systemdict:abs}} & r & Get the absolute value of a. \\
\hline
a & {\bf \htmlref{neg}{systemdict:neg}} & r & Get the negative of a. \\
\hline
a & {\bf \htmlref{ceiling}{systemdict:ceiling}} & r & Integer ceiling of a
real. \\
\hline
a & {\bf \htmlref{floor}{systemdict:floor}} & r & Integer floor of a real. \\
\hline
a & {\bf \htmlref{round}{systemdict:round}} & r & Real rounded to integer. \\
\hline
a & {\bf \htmlref{trunc}{systemdict:trunc}} & r & Integer from real with
truncated fractional. \\
\hline
a & {\bf \htmlref{sin}{systemdict:sin}} & r & Sine in radians. \\
\hline
a & {\bf \htmlref{cos}{systemdict:cos}} & r & Cosine in radians. \\
\hline
y x & {\bf \htmlref{atan}{systemdict:atan}} & r & Arctangent in radians of
$y/x$. \\
\hline
seed & {\bf \htmlref{srand}{systemdict:srand}} & -- & Seed pseudo-random number
generator. \\
\hline
-- & {\bf \htmlref{rand}{systemdict:rand}} & integer & Get a pseudo-random
number. \\
\hline \hline
\multicolumn{4}{|l|}{String operators} \\
\hline \hline
length & {\bf \htmlref{string}{systemdict:string}} & string & Create a
string. \\
\hline
string & {\bf \htmlref{length}{systemdict:length}} & count & Get string
length. \\
\hline
string index & {\bf \htmlref{get}{systemdict:get}} & integer & Get string
element. \\
\hline
string index integer & {\bf \htmlref{put}{systemdict:put}} & -- & Set string
element. \\
\hline
string index length & {\bf \htmlref{getinterval}{systemdict:getinterval}} &
substring & Get a string interval. \\
\hline
string index substring & {\bf \htmlref{putinterval}{systemdict:putinterval}} &
-- & Copy substring into string. \\
\hline
`a' `b' & {\bf \htmlref{cat}{systemdict:cat}} & `ab' & Catenate two strings. \\
\hline
srcstring dststring & {\bf \htmlref{copy}{systemdict:copy}} & dstsubstring &
Copy string. \\
\hline
object depth & {\bf \htmlref{sprints}{systemdict:sprints}} & string &
Create syntactical string from object. \\
\hline
object flags & {\bf \htmlref{outputs}{systemdict:outputs}} & string &
Create formatted string from object. \\
\hline
string pattern & {\bf \htmlref{search}{systemdict:search}} & post pattern pre
true & Successfully search for pattern. \\
string pattern & {\bf \htmlref{search}{systemdict:search}} & string false &
Unsuccessfully earch for pattern. \\
\hline \hline
\multicolumn{4}{|l|}{Name operators} \\
\hline \hline
name & {\bf \htmlref{length}{systemdict:length}} & count & Get name length. \\
\hline \hline
\multicolumn{4}{|l|}{Array operators} \\
\hline \hline
-- & {\bf \htmlref{argv}{systemdict:argv}} & args & Get program arguments. \\
\hline
-- & {\bf \htmlref{[}{systemdict:sym_lb}} & mark & Begin an array
declaration. \\
\hline
mark objects & {\bf \htmlref{]}{systemdict:sym_rb}} & array & Construct an
array. \\
\hline
length & {\bf \htmlref{array}{systemdict:array}} & array & Create an array. \\
\hline
array & {\bf \htmlref{length}{systemdict:length}} & count & Get array length. \\
\hline
array index & {\bf \htmlref{get}{systemdict:get}} & object & Get array
element. \\
\hline
array index object & {\bf \htmlref{put}{systemdict:put}} & -- & Set array
element. \\
\hline
array index length & {\bf \htmlref{getinterval}{systemdict:getinterval}} &
subarray & Get an array interval. \\
\hline
array index subarray & {\bf \htmlref{putinterval}{systemdict:putinterval}} & --
& Copy subarray into array. \\
\hline
[a] [b] & {\bf \htmlref{cat}{systemdict:cat}} & [a b] & Catenate two arrays. \\
\hline
srcarray dstarray & {\bf \htmlref{copy}{systemdict:copy}} & dstsubarray & Copy
array. \\
\hline \hline
\multicolumn{4}{|l|}{Dictionary and dictionary stack operators} \\
\hline \hline
-- & {\bf \htmlref{gcdict}{systemdict:gcdict}} & dict & Get gcdict. \\
\hline
-- & {\bf \htmlref{globaldict}{systemdict:globaldict}} & dict & Get
globaldict. \\
\hline
-- & {\bf \htmlref{onyxdict}{systemdict:onyxdict}} & dict & Get onyxdict. \\
\hline
-- & {\bf \htmlref{sprintsdict}{systemdict:sprintsdict}} & dict & Get
sprintsdict. \\
\hline
-- & {\bf \htmlref{outputsdict}{systemdict:outputsdict}} & dict & Get
outputsdict. \\
\hline
-- & {\bf \htmlref{envdict}{systemdict:envdict}} & dict & Get envdict. \\
\hline
key val & {\bf \htmlref{setenv}{systemdict:setenv}} & -- & Set environment
variable. \\
\hline
key & {\bf \htmlref{unsetenv}{systemdict:unsetenv}} & -- & Unset environment
variable. \\
\hline
-- & {\bf \htmlref{{\lt}}{systemdict:sym_lt}} & mark & Begin a dictionary
declaration. \\
\hline
mark kvpairs & {\bf \htmlref{{\gt}}{systemdict:sym_gt}} & dict & Construct a
dictionary. \\
\hline
-- & {\bf \htmlref{dict}{systemdict:dict}} & dict & Create a dictionary. \\
\hline
dict & {\bf \htmlref{begin}{systemdict:begin}} & -- & Pust dict onto dstack. \\
\hline
-- & {\bf \htmlref{end}{systemdict:end}} & -- & Pop a dictionary off dstack. \\
\hline
key val & {\bf \htmlref{def}{systemdict:def}} & -- & Define key/value pair. \\
\hline
dict key & {\bf \htmlref{undef}{systemdict:undef}} & -- & Undefine key in
dict. \\
\hline
key & {\bf \htmlref{load}{systemdict:load}} & val & Look up a key's value. \\
\hline
dict key & {\bf \htmlref{known}{systemdict:known}} & boolean & Check for key in
dict. \\
\hline
%begin{latexonly}
key & {\bf \htmlref{where}{systemdict:where}} & false & Get topmost dstack
dictionary that \\
key & {\bf \htmlref{where}{systemdict:where}} & dict true & defines key. \\
\hline
%end{latexonly}
\begin{htmlonly}
key & {\bf \htmlref{where}{systemdict:where}} & false & Get topmost dstack
dictionary that defines key. \\
key & {\bf \htmlref{where}{systemdict:where}} & dict true & Get topmost dstack
dictionary that defines key. \\
\end{htmlonly}
dict & {\bf \htmlref{length}{systemdict:length}} & count & Get number of
dictionary key/value pairs. \\
\hline
dict key & {\bf \htmlref{get}{systemdict:get}} & value & Get dict value
associate with key. \\
\hline
dict key value & {\bf \htmlref{put}{systemdict:put}} & -- & Set dict key/value
pair. \\
\hline
srcdict dstdict & {\bf \htmlref{copy}{systemdict:copy}} & dstdict & Copy
dictionary contents. \\
\hline
-- & {\bf \htmlref{currentdict}{systemdict:currentdict}} & dict & Get topmost
dstack dictionary. \\
\hline
-- & {\bf \htmlref{dstack}{systemdict:dstack}} & stack & Get dstack snapshot. \\
\hline
-- & {\bf \htmlref{countdstack}{systemdict:countdstack}} & count & Get number of
stacks on dstack. \\
\hline
-- & {\bf \htmlref{cleardstack}{systemdict:cleardstack}} & -- & Pop all dstack
elements pushed by \htmlref{\onyxop{}{begin}{}}{systemdict:begin}. \\
\hline \hline
\multicolumn{4}{|l|}{File and filesystem operators} \\
\hline \hline
filename flags & {\bf \htmlref{open}{systemdict:open}} & file & Open a file. \\
\hline
filename flags mode & {\bf \htmlref{open}{systemdict:open}} & file & Open a
file, creation mode specified. \\
\hline
file & {\bf \htmlref{close}{systemdict:close}} & -- & Close file. \\
\hline
%begin{latexonly}
file & {\bf \htmlref{read}{systemdict:read}} & integer boolean & Read from
file. \\
file string & {\bf \htmlref{read}{systemdict:read}} & string boolean & \\
\hline
%end{latexonly}
\begin{htmlonly}
file & {\bf \htmlref{read}{systemdict:read}} & integer boolean & Read from
file. \\
file string & {\bf \htmlref{read}{systemdict:read}} & substring boolean &
Read from file. \\
\end{htmlonly}
file & {\bf \htmlref{readline}{systemdict:readline}} & string boolean &
Read a line from file. \\
\hline
{\lt}file dict \dots{\gt} & {\bf \htmlref{poll}{systemdict:poll}} & {\lt}file
dict \dots{\gt} & Wait for file(s) to change status. \\
\hline
file & {\bf \htmlref{bytesavailable}{systemdict:bytesavailable}} & count &
Get number of buffered readable bytes. \\
\hline
file & {\bf \htmlref{iobuf}{systemdict:iobuf}} & count & Get size of I/O
buffer. \\
\hline
file count & {\bf \htmlref{setiobuf}{systemdict:setiobuf}} & -- & Set size of
I/O buffer. \\
\hline
file integer/string & {\bf \htmlref{write}{systemdict:write}} & -- & Write
to file. \\
\hline
string & {\bf \htmlref{print}{systemdict:print}} & -- & Print string to
stdout. \\
\hline
object depth & {\bf \htmlref{sprint}{systemdict:sprint}} & -- &
Syntactically print object to stdout. \\
\hline
object flags & {\bf \htmlref{output}{systemdict:output}} & -- & Formatted print
to stdout. \\
\hline
-- & {\bf \htmlref{pstack}{systemdict:pstack}} & -- & Syntactically print
ostack elements. \\
\hline
file & {\bf \htmlref{flushfile}{systemdict:flushfile}} & -- & Flush file
buffer. \\
\hline
-- & {\bf \htmlref{flush}{systemdict:flush}} & -- & Flush stdout buffer. \\
\hline
file length & {\bf \htmlref{truncate}{systemdict:truncate}} & -- & Truncate
file. \\
\hline
file offset & {\bf \htmlref{seek}{systemdict:seek}} & -- & Move file position
pointer. \\
\hline
file & {\bf \htmlref{tell}{systemdict:tell}} & offset & Get file position
pointer offset. \\
\hline
path mode & {\bf \htmlref{mkdir}{systemdict:mkdir}} & -- & Create a
directory. \\
\hline
old new & {\bf \htmlref{rename}{systemdict:rename}} & -- & Rename a file or
directory. \\
\hline
file/filename mode & {\bf \htmlref{chmod}{systemdict:chmod}} & -- & Change file
permissions. \\
\hline
file/filename uid gid & {\bf \htmlref{chown}{systemdict:chown}} & -- & Change
file owner and group. \\
\hline
filename linkname & {\bf \htmlref{link}{systemdict:link}} & -- & Create a hard
link. \\
\hline
filename linkname & {\bf \htmlref{symlink}{systemdict:symlink}} & -- & Create a
symbolic link. \\
\hline
filename & {\bf \htmlref{unlink}{systemdict:unlink}} & -- & Unlink a file. \\
\hline
path & {\bf \htmlref{rmdir}{systemdict:rmdir}} & -- & Remove an empty
directory. \\
\hline
file/filename flag & {\bf \htmlref{test}{systemdict:test}} & boolean & Test a
file. \\
\hline
file/filename & {\bf \htmlref{status}{systemdict:status}} & dict & Get file
information. \\
\hline
path proc & {\bf \htmlref{dirforeach}{systemdict:dirforeach}} & -- & Iterate on
directory entries. \\
\hline
-- & {\bf \htmlref{pwd}{systemdict:pwd}} & path & Get present working
directory. \\
\hline
path & {\bf \htmlref{cd}{systemdict:cd}} & -- & Change present working
directory. \\
\hline
-- & {\bf \htmlref{stdin}{systemdict:stdin}} & file & Get stdin. \\
\hline
-- & {\bf \htmlref{stdout}{systemdict:stdout}} & file & Get stdout. \\
\hline
-- & {\bf \htmlref{stderr}{systemdict:stderr}} & file & Get stderr. \\
\hline \hline
\multicolumn{4}{|l|}{Logical and bitwise operators} \\
\hline \hline
a b & {\bf \htmlref{lt}{systemdict:lt}} & boolean & a less than b?
(integer/real, string) \\
\hline
a b & {\bf \htmlref{le}{systemdict:le}} & boolean & a less than or equal to b?
(integer/real, string) \\
\hline
a b & {\bf \htmlref{eq}{systemdict:eq}} & boolean & a equal to b? (any type) \\
\hline
a b & {\bf \htmlref{ne}{systemdict:ne}} & boolean & a not equal to b? (any type)
\\
\hline
a b & {\bf \htmlref{ge}{systemdict:ge}} & boolean & a greater than or equal to
b? (integer/real, string) \\
\hline
a b & {\bf \htmlref{gt}{systemdict:gt}} & boolean & a greater than b?
(integer/real, string) \\
\hline
a b & {\bf \htmlref{and}{systemdict:and}} & r & Logical/bitwise and.
(boolean/integer)  \\
\hline
a b & {\bf \htmlref{or}{systemdict:or}} & r & Logical/bitwise or.
(boolean/integer) \\
\hline
a b & {\bf \htmlref{xor}{systemdict:xor}} & r & Logical/bitwise exclusive or.
(boolean/integer) \\
\hline
a & {\bf \htmlref{not}{systemdict:not}} & r & Logical/bitwise not.
(boolean/integer) \\
\hline
a shift & {\bf \htmlref{shift}{systemdict:shift}} & integer & Bitwise shift. \\
\hline
-- & {\bf \htmlref{false}{systemdict:false}} & false & Return true. \\
\hline
-- & {\bf \htmlref{true}{systemdict:true}} & true & Return false. \\
\hline \hline
\multicolumn{4}{|l|}{Type, conversion, and attribute operators} \\
\hline \hline
object & {\bf \htmlref{type}{systemdict:type}} & name & Get object type. \\
\hline
object & {\bf \htmlref{echeck}{systemdict:echeck}} & boolean & Evaluatable? \\
\hline
object & {\bf \htmlref{xcheck}{systemdict:xcheck}} & boolean & Executable? \\
\hline
object & {\bf \htmlref{cve}{systemdict:cve}} & object & Set evaluatable
attribute. \\
\hline
object & {\bf \htmlref{cvx}{systemdict:cvx}} & object & Set executable
attribute. \\
\hline
object & {\bf \htmlref{cvlit}{systemdict:cvlit}} & object & Set literal
attribute. \\
\hline
string & {\bf \htmlref{cvn}{systemdict:cvn}} & name & Convert string to name. \\
\hline
object & {\bf \htmlref{cvs}{systemdict:cvs}} & string & Convert object to
string. \\
\hline
integer radix & {\bf \htmlref{cvrs}{systemdict:cvrs}} & string & Convert integer
to radix string. \\
\hline
real precision & {\bf \htmlref{cvds}{systemdict:cvds}} & string & Convert real
to decimal string. \\
\hline
real precision & {\bf \htmlref{cves}{systemdict:cves}} & string & Convert real
to exponential string. \\
\hline
hook & {\bf \htmlref{hooktag}{systemdict:hooktag}} & tag & Get hook tag. \\
\hline \hline
\multicolumn{4}{|l|}{Threading and synchronization operators} \\
\hline \hline
stack entry & {\bf \htmlref{thread}{systemdict:thread}} & thread & Create and
run a thread. \\
\hline
-- & {\bf \htmlref{self}{systemdict:self}} & thread & Get a thread object for
the running thread. \\
\hline
thread & {\bf \htmlref{join}{systemdict:join}} & -- & Wait for thread to
exit. \\
\hline
thread & {\bf \htmlref{detach}{systemdict:detach}} & -- & Detach thread. \\
\hline
-- & {\bf \htmlref{yield}{systemdict:yield}} & -- & Voluntarily yield the
processor. \\
\hline
-- & {\bf \htmlref{mutex}{systemdict:mutex}} & mutex & Create a mutex. \\
\hline
mutex proc & {\bf \htmlref{monitor}{systemdict:mutex}} & -- & Evaluate an object
under the protection of a mutex. \\
\hline
mutex & {\bf \htmlref{lock}{systemdict:lock}} & -- & Acquire mutex. \\
\hline
mutex & {\bf \htmlref{trylock}{systemdict:trylock}} & boolean & Try to acquire
mutex. \\
\hline
mutex & {\bf \htmlref{unlock}{systemdict:unlock}} & -- & Release mutex. \\
\hline
-- & {\bf \htmlref{condition}{systemdict:condition}} & condition & Create a
condition variable. \\
\hline
condition mutex & {\bf \htmlref{wait}{systemdict:wait}} & -- & Wait on
condition. \\
\hline
condition mutex timeout & {\bf \htmlref{timedwait}{systemdict:timedwait}} &
boolean & Wait on condition with timeout. \\
\hline
condition & {\bf \htmlref{signal}{systemdict:signal}} & -- & Signal a condition
waiter. \\
\hline
condition & {\bf \htmlref{broadcast}{systemdict:broadcast}} & -- & Signal all
condition waiters. \\
\hline
-- & {\bf \htmlref{currentlocking}{systemdict:currentlocking}} & boolean & Get
implicit locking mode. \\
\hline
boolean & {\bf \htmlref{setlocking}{systemdict:setlocking}} & -- & Set implicit
locking mode. \\
\hline
object & {\bf \htmlref{lcheck}{systemdict:lcheck}} & boolean & Implicitly
locked? \\
\hline \hline
\multicolumn{4}{|l|}{Miscellaneous operators} \\
\hline \hline
-- & {\bf \htmlref{\#!}{systemdict:sym_hash_bang}} & mark & Begin interpreter
magic. \\
\hline
mark names & {\bf \htmlref{!\#}{systemdict:sym_bang_hash}} & -- & End
interpreter magic. \\
\hline
-- & {\bf \htmlref{product}{systemdict:product}} & string & Get the product
string. \\
\hline
-- & {\bf \htmlref{version}{systemdict:version}} & string & Get the version
string. \\
\hline
proc & {\bf \htmlref{bind}{systemdict:bind}} & proc & Bind names to
operators. \\
\hline
-- & {\bf \htmlref{null}{systemdict:null}} & null & Create a null object. \\
\end{longtable}

\begin{description}
\label{systemdict:sym_bang_hash}
\index{"!#@\onyxop{}{"!\#}{}}
\item[{\onyxop{mark names}{!\#}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[names: ]
			Zero or more name objects.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove mark and name objects constructed as a side effect of
		interpreter magic.  This operator is an alias of
		\htmlref{cleartomark}{systemdict:cleartomark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> #!/usr/local/bin/onyx pstack
/onyx
/bin
/local
/usr
-mark-
onyx:5> !#
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_hash_bang}
\index{#"!@\onyxop{}{\#"!}{}}
\item[{\onyxop{--}{\#!}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a mark object in preparation for an interpreter path.
		This operator is an alias of \htmlref{mark}{systemdict:mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> #! pstack
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lp}
\index{(@\onyxop{}{(}{}}
\item[{\onyxop{--}{(}{fino}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a fino object onto ostack to denote the bottom of a stack
		that has not yet been constructed.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (
onyx:1> pstack
-fino-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_rp}
\index{)@\onyxop{}{)}{}}
\item[{\onyxop{fino objects}{)}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fino: ]
			A fino object, usually created by the \onyxop{}{)}{}
			operator.
		\item[objects: ]
			0 or more objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedfino}{unmatchedfino}.]
		\end{description}
	\item[Description: ]
		Create a stack object and move all objects from ostack down to
		the first fino object to the new stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ()
onyx:1> 1 sprint
()
onyx:0> (1 2
onyx:3> pstack
2
1
-fino-
onyx:3> )
onyx:1> 1 sprint
(1 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lt}
\index{<@\onyxop{}{{\lt}}{}}
\item[{\onyxop{--}{{\lt}}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Begin a dictionary declaration.  See the
		\htmlref{\onyxop{}{>}{}}{systemdict:sym_gt} operator
		documentation for more details on dictionary construction.
	\item[Example(s): ]\begin{verbatim}

onyx:0> < 1 sprint
-mark-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_gt}
\index{>@\onyxop{}{{\gt}}{}}
\item[{\onyxop{mark kvpairs}{{\gt}}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[kvpairs: ]
			Zero or more pairs of non-mark objects, where the first
			is a key and the second is an associated value.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary that contains \oparg{kvpairs}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Construct a dictionary that contains \oparg{kvpairs}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> <
onyx:1> /foo `foo'
onyx:3> /bar `bar'
onyx:5> /biz `biz'
onyx:7> /pop //pop
onyx:9> >
onyx:1> pstack
</pop --pop-- /biz `biz' /bar `bar' /foo `foo'>
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_lb}
\index{[@\onyxop{}{{\lb}}{}}
\item[{\onyxop{--}{{\lb}}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Begin an array declaration.  See the
		\htmlref{\onyxop{}{]}{}}{systemdict:sym_rb} operator
		documentation for more details on array construction.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [ 1 sprint
-mark-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sym_rb}
\index{]@\onyxop{}{{\rb}}{}}
\item[{\onyxop{mark objects}{{\rb}}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[objects: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array that contains \oparg{objects}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Construct an array that contains all \oparg{objects} on ostack
		down to the first \oparg{mark}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mark 1 2 3 ] 1 sprint
[1 2 3]
		\end{verbatim}
	\end{description}
\label{systemdict:abs}
\index{abs@\onyxop{}{abs}{}}
\item[{\onyxop{a}{abs}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Absolute value of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the absolute value of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 abs 1 sprint
5
onyx:0> -5 abs 1 sprint
5
onyx:0> 3.14 abs 1 sprint
3.140000e+00
onyx:0> -3.14 abs 1 sprint
3.140000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:add}
\index{add@\onyxop{}{add}{}}
\item[{\onyxop{a b}{add}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The sum of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the sum of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 2 add 1 sprint
4
onyx:0> -1 3 add 1 sprint
2
onyx:0> 2.0 3.1 add 1 sprint
5.100000e+00
onyx:0> -1.5 +3e1 add 1 sprint
2.850000e+01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:and}
\index{and@\onyxop{}{and}{}}
\item[{\onyxop{a b}{and}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			and, otherwise their logical and.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise and of two integers, or the logical and of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false true and 1 sprint
false
onyx:0> true true and 1 sprint
true
onyx:0> 5 3 and 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:argv}
\index{argv@\onyxop{}{argv}{}}
\item[{\onyxop{--}{argv}{args}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of this program, and any additional
			array elements are the arguments that were passed during
			invocation.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the argument vector that was used to invoke this program.
	\item[Example(s): ]\begin{verbatim}

onyx:0> argv 1 sprint
[`/usr/local/bin/onyx']
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:array}
\index{array@\onyxop{}{array}{}}
\item[{\onyxop{length}{array}{array}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[length: ]
			Non-negative number of array elements.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array of \oparg{length} elements.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create an array of \oparg{length} elements.  The elements are
		initialized to null objects.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 array 1 sprint
[null null null]
onyx:0> 0 array 1 sprint
[]
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:atan}
\index{atan@\onyxop{}{atan}{}}
\item[{\onyxop{y x}{atan}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[y: ]
			An integer or real.
		\item[x: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Arctangent of $y/x$ in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the arctangent of $y/x$ in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 1 atan 1 sprint
7.853982e-01
onyx:0> 0 1 atan 1 sprint
0.000000e+00
onyx:0> -1.0 0 atan 1 sprint
-1.570796e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:begin}
\index{begin@\onyxop{}{begin}{}}
\item[{\onyxop{dict}{begin}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{dict} onto dstack, thereby adding its keys to the
		namespace.
	\item[Example(s): ]\begin{verbatim}

onyx:0> </foo `foo'> begin
onyx:0> foo 1 sprint
`foo'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:bind}
\index{bind@\onyxop{}{bind}{}}
\item[{\onyxop{proc}{bind}{proc}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			A procedure (array).  \oparg{proc} will be bound even if
			it is literal, but contained literal arrays will not be
			recursively bound.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[proc: ]
			The same procedure as was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Recursively bind unbound procedures.  Executable names within a
		procedure are replaced with their values if defined in dstack,
		in any of the following cases:
		\begin{itemize}
		\item{The value is a literal object.}
		\item{The value is an executable or evaluatable operator.}
		\item{The value is an executable or evaluatable hook.}
		\item{The value is an evaluatable array.}
		\end{itemize}
	\item[Example(s): ]\begin{verbatim}

onyx:0> {pop sprint {pop sprint}}
onyx:1> dup 2 sprint
{pop sprint {pop sprint}}
onyx:1> bind
onyx:1> dup 2 sprint
{--pop-- _{sprints --print-- `\n' --print-- --flush--}_ {--pop-- -array-}}
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:broadcast}
\index{broadcast@\onyxop{}{broadcast}{}}
\item[{\onyxop{condition}{broadcast}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Signal all threads that are waiting on \oparg{condition}.  If
		there are no waiters, this operator has no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch broadcast unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:bytesavailable}
\index{bytesavailable@\onyxop{}{bytesavailable}{}}
\item[{\onyxop{file}{bytesavailable}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of buffered readable bytes.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the number of buffered readable bytes that can be read
		without the possibility of blocking.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup `Goodbye\n' write
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1> dup bytesavailable 1 sprint
8
onyx:1>
	\end{verbatim}
	\end{description}
\label{systemdict:cat}
\index{cat@\onyxop{}{cat}{}}
\item[{\onyxop{[a] [b]}{cat}{[a b]}}: ]
\item[{\onyxop{(a) (b)}{cat}{(a b)}}: ]
\item[{\onyxop{`a' `b'}{cat}{`ab'}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An array, stack, or string.
		\item[b: ]
			An array, stack, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[ab: ]
			The catenation of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Catenate two arrays, strings, or stacks.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b'] cat
onyx:1> 1 sprint
[`a' `b']
onyx:0> (`a') (`b') cat
onyx:1> 1 sprint
(`a' `b')
onyx:0> `a' `b' cat
onyx:1> 1 sprint
`ab'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cd}
\index{cd@\onyxop{}{cd}{}}
\item[{\onyxop{path}{cd}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Change the present working directory to \oparg{path}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd 1 sprint
`/usr/local'
onyx:0> `bin' cd
onyx:0> pwd 1 sprint
`/usr/local/bin'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ceiling}
\index{ceiling@\onyxop{}{ceiling}{}}
\item[{\onyxop{a}{ceiling}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer ceiling of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the integer ceiling of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 ceiling 1 sprint
-1
onyx:0> -1.49 ceiling 1 sprint
-1
onyx:0> 0 ceiling 1 sprint
0
onyx:0> 1.49 ceiling 1 sprint
2
onyx:0> 1.51 ceiling 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:chmod}
\index{chmod@\onyxop{}{chmod}{}}
\item[{\onyxop{file/filename mode}{chmod}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[mode: ]
			An integer that represents a Unix file mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8#755 mkdir 
onyx:0> `/tmp/tdir' status /mode get 1 sprint
16877
onyx:0> `/tmp/tdir' `r' open 
onyx:1> dup 8#555 chmod
onyx:1> `/tmp/tdir' status /mode get 1 sprint
16749
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:chown}
\index{chown@\onyxop{}{chown}{}}
\item[{\onyxop{file/filename uid gid}{chown}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[uid: ]
			An integer that represents a user ID.
		\item[gid: ]
			An integer that represents a group ID.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Change the owner and group of a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8#755 mkdir
onyx:0> `/tmp/tdir' status 
onyx:1> dup /uid get 1 sprint
1001
onyx:1> /gid get 1 sprint
0
onyx:0> `/tmp/tdir' 1001 1001 chown
onyx:0> `/tmp/tdir' status
onyx:1> dup /uid get 1 sprint
1001
onyx:1> /gid get 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:clear}
\index{clear@\onyxop{}{clear}{}}
\item[{\onyxop{objects}{clear}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			All objects on ostack.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Pop all objects off of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 pstack
3
2
1
onyx:3> clear pstack
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cleardstack}
\index{cleardstack@\onyxop{}{cleardstack}{}}
\item[{\onyxop{--}{cleardstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Pop all dictionaries on dstack that were pushed by
		\htmlref{\onyxop{}{begin}{}}{systemdict:begin}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> dict begin
onyx:0> dstack 1 sprint
(-dict- -dict- -dict- -dict- -dict-)
onyx:0> cleardstack
onyx:0> dstack 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:0> cleardstack
onyx:0> dstack 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cleartomark}
\index{cleartomark@\onyxop{}{cleartomark}{}}
\item[{\onyxop{mark \dots}{cleartomark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[\dots: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from ostack down to and including the topmost
		mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 mark 1 0 pstack
0
1
-mark-
3
onyx:4> cleartomark pstack
3
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:close}
\index{close@\onyxop{}{close}{}}
\item[{\onyxop{file}{close}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Close a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> close
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:condition}
\index{condition@\onyxop{}{condition}{}}
\item[{\onyxop{--}{condition}{condition}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a condition object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition 1 sprint
-condition-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:copy}
\index{copy@\onyxop{}{copy}{}}
\item[{\onyxop{srcarray dstarray}{copy}{dstsubarray}}: ]
\item[{\onyxop{srcdict dstdict}{copy}{dstdict}}: ]
\item[{\onyxop{srcstack dststack}{copy}{dststack}}: ]
\item[{\onyxop{srcstring dststring}{copy}{dstsubstring}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[srcarray: ]
			An array object.
		\item[srcdict: ]
			A dict object.
		\item[srcstack: ]
			A stack object.
		\item[srcstring: ]
			A string object.
		\item[dstarray: ]
			An array object, at least as long as \oparg{srcarray}.
		\item[dstdict: ]
			A dict object.
		\item[dststack: ]
			A stack object.
		\item[dststring: ]
			A string object, at least as long as \oparg{srcstring}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dstsubarray: ]
			A subarray of \oparg{dstarray}, with the same contents
			as \oparg{srcarray}.
		\item[dstdict: ]
			The same object as the input \oparg{dstdict}, but with
			the contents of \oparg{srcdict} inserted.
		\item[dststack: ]
			The same object as the input \oparg{dststack}, but with
			the contents of \oparg{srcstack} pushed.
		\item[dstsubstring: ]
			A substring of \oparg{dststring}, with the same contents
			as \oparg{srcstring}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Copy from one object to another.  Array and string copying are
		destructive; dictionary and stack copying are not.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a'] [`b' `c'] copy 1 sprint
[`a']
onyx:0> </foo `foo'> </bar `bar'> copy 1 sprint
</bar `bar' /foo `foo'>
onyx:1> (1 2) (3 4) copy 1 sprint
(3 4 1 2)
onyx:1> `a' `bc' copy 1 sprint
`a'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:cos}
\index{cos@\onyxop{}{cos}{}}
\item[{\onyxop{a}{cos}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Cosine of \oparg{a} in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the cosine of \oparg{a} in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 cos 1 sprint
1.000000e+00
onyx:0> 3.14 cos 1 sprint
-9.999987e-01
onyx:0> 3.1415927 cos 1 sprint
-1.000000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:count}
\index{count@\onyxop{}{count}{}}
\item[{\onyxop{--}{count}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects on ostack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 2 1 0 count pstack
3
0
1
2
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:countdstack}
\index{countdstack@\onyxop{}{countdstack}{}}
\item[{\onyxop{--}{countdstack}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of dictionaries on dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of dictionaries on dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> countdstack 1 sprint
4
onyx:0> dict begin
onyx:0> countdstack 1 sprint
5
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:countestack}
\index{countestack@\onyxop{}{countestack}{}}
\item[{\onyxop{--}{countestack}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects currently on the execution stack
			(recursion depth).
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the current number of objects on the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> countestack 1 sprint
3
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:counttomark}
\index{counttomark@\onyxop{}{counttomark}{}}
\item[{\onyxop{mark \dots}{counttomark}{mark \dots count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\item[\dots: ]
			Zero or more non-mark objects.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			The same mark that was passed in.
		\item[\dots: ]
			The same non-mark objects that were passed in.
		\item[count: ]
			The depth of \oparg{mark} on ostack.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 mark 2 1 0 counttomark 1 sprint
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:currentdict}
\index{currentdict@\onyxop{}{currentdict}{}}
\item[{\onyxop{--}{currentdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			Topmost stack on dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the topmost dictionary on dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> </foo `foo'> begin 
onyx:0> currentdict 1 sprint
</foo `foo'>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:currentlocking}
\index{currentlocking@\onyxop{}{currentlocking}{}}
\item[{\onyxop{--}{currentlocking}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, new objects are created with implicit locking
			disabled.  Otherwise, new objects are created with
			implicit locking enabled.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the current implicit locking mode.  See
		Section~\ref{sec:implicit_synchronization} for implicit
		synchronization details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currentlocking 1 sprint
false
onyx:0> true setlocking
onyx:0> currentlocking 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvds}
\index{cvds@\onyxop{}{cvds}{}}
\item[{\onyxop{real precision}{cvds}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real.
		\item[precision: ]
			Number of digits after the decimal point to show.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{real} in decimal form
			with \oparg{precision} digits of decimal precision.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{real} to a string representation in decimal
		notation, with \oparg{precision} digits of decimal precision.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42.3 0 cvds 1 sprint
`42'
onyx:0> 42.3 1 cvds 1 sprint
`42.3'
onyx:0> -42.3 4 cvds 1 sprint
`-42.3000'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cve}
\index{cve@\onyxop{}{cve}{}}
\item[{\onyxop{object}{cve}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in, but with the
			evaluatable attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the evaluatable attribute for \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] cve 1 sprint
_{1 2 3}_
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cves}
\index{cves@\onyxop{}{cves}{}}
\item[{\onyxop{real precision}{cves}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[real: ]
			A real.
		\item[precision: ]
			Number of digits after the decimal point to show.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{real} in exponential
			form with \oparg{precision} digits of decimal precision.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{real} to a string representation in exponential
		notation, with \oparg{precision} digits of decimal precision.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42.3 0 cves 1 sprint
`4e+01'
onyx:0> 42.3 1 cves 1 sprint
`4.2e+01'
onyx:0> 42.3 2 cves 1 sprint
`4.23e+01'
onyx:0> -42.3 5 cves 1 sprint
`-4.23000e+01'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvlit}
\index{cvlit@\onyxop{}{cvlit}{}}
\item[{\onyxop{object}{cvlit}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in, but with the literal
			attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the literal attribute for \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} cvlit 1 sprint
[1 2 3]
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvn}
\index{cvn@\onyxop{}{cvn}{}}
\item[{\onyxop{string}{cvn}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			A literal name that corresponds to \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{string} to a literal name.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `foo' cvn 1 sprint
/foo
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvrs}
\index{cvrs@\onyxop{}{cvrs}{}}
\item[{\onyxop{integer radix}{cvrs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer.
		\item[radix: ]
			A numerical base, from 2 to 36, inclusive.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{integer} in base
			\oparg{radix}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{integer} to a string representation in base
		\oparg{radix}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 42 2 cvrs 1 sprint
`101010'
onyx:0> 42 16 cvrs 1 sprint
`2a'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvs}
\index{cvs@\onyxop{}{cvs}{}}
\item[{\onyxop{object}{cvs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string representation of \oparg{object}.  The string
			depends on the type of \oparg{object}:
			\begin{description}
			\item[boolean: ] {\tt `true'} or  {\tt `false'}.
			\item[name: ] The string representation of the name.
			\item[integer: ] The integer in base 10.
			\item[operator: ] The string representation of the
			operator name or {\tt `-operator-'}.
			\item[real: ] The real in exponential notation.
			\item[string: ] A printable representation of
			\oparg{object}.  The result can be evaluated to produce
			the original string.
			\item[Other types: ] {\tt `--nostringval--'}.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Convert \oparg{object} to a string representation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true cvs 1 sprint
`true'
onyx:0> /foo cvs 1 sprint
`foo'
onyx:0> 42 cvs 1 sprint
`42'
onyx:0> //pop cvs 1 sprint
`pop'
onyx:0> 42.0 cvs 1 sprint
`4.200000e+01'
onyx:0> `foo\nbar\\biz\`baz' cvs 1 sprint
`\`foo\\nbar\\\\biz\\\`baz\''
onyx:0> mutex cvs 1 sprint
`--nostringval--'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:cvx}
\index{cvx@\onyxop{}{cvx}{}}
\item[{\onyxop{object}{cvx}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in, but with the
			executable attribute set.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Set the executable attribute for \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] cvx 1 sprint
{1 2 3}
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:def}
\index{def@\onyxop{}{def}{}}
\item[{\onyxop{key val}{def}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			An object.
		\item[val: ]
			A value associated with \oparg{key}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Define \oparg{key} with associated value \oparg{val} in the
		topmost dictionary on dstack.  If \oparg{key} is already defined
		in that dictionary, the old definition is replaced.
	\item[Example(s): ]\begin{verbatim}

onyx:0> /foo `foo' def
onyx:0> foo 1 sprint
`foo'
onyx:0> /foo `FOO' def
onyx:0> foo 1 sprint
`FOO'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:detach}
\index{detach@\onyxop{}{detach}{}}
\item[{\onyxop{thread}{detach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Detach \oparg{thread} so that its resources will be
		automatically reclaimed after it exits.  A thread may only be
		detached or joined once; any attempt to do so more than once
		results in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint self detach} thread
3
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:dict}
\index{dict@\onyxop{}{dict}{}}
\item[{\onyxop{--}{dict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			An empty dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create an empty dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> dict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:die}
\index{die@\onyxop{}{die}{}}
\item[{\onyxop{status}{die}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[status: ]
			A integer from 0 to 255 that is used as the program exit
			code.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Exit the program with exit code \oparg{status}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 die
		\end{verbatim}
	\end{description}
\label{systemdict:dirforeach}
\index{dirforeach@\onyxop{}{dirforeach}{}}
\item[{\onyxop{path proc}{dirforeach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a filesystem path.
		\item[proc: ]
			An object to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		For each entry in the directory represented by \oparg{path}
		except for ``.'' and ``..'', push a string that represents the
		entry onto ostack and execute \oparg{proc}.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd {1 sprint} dirforeach
`CVS'
`.cvsignore'
`Cookfile'
`Cookfile.inc'
`latex'
`Cookfile.inc.in'
onyx:0> pwd {`Cookfile.inc' search
     {pop `Yes: ' print 1 sprint pop exit}
     {`Not: ' print 1 sprint} ifelse
} dirforeach
Not: `CVS'
Not: `.cvsignore'
Not: `Cookfile'
Yes: `Cookfile.inc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:div}
\index{div@\onyxop{}{div}{}}
\item[{\onyxop{a b}{div}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			A non-zero integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The quotient of \oparg{a} divided by \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
		Return the quotient of \oparg{a} divided by \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 div 1 sprint
2.000000e+00
onyx:0> 5 2.0 div 1 sprint
2.500000e+00
onyx:0> 5.0 0 div
Error /undefinedresult
ostack: (5.000000e+00 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --div--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:dstack}
\index{dstack@\onyxop{}{dstack}{}}
\item[{\onyxop{--}{dstack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A snapshot of dstack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a snapshot of dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> dstack 1 sprint
(-dict- -dict- -dict- -dict-)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:dup}
\index{dup@\onyxop{}{dup}{}}
\item[{\onyxop{object}{dup}{object object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the top object on ostack.  For composite
		objects, the new object is a reference to the same composite
		object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 dup pstack
1
1
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:echeck}
\index{echeck@\onyxop{}{echeck}{}}
\item[{\onyxop{object}{echeck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{object} has the evaluatable attribute,
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Check \oparg{object} for evaluatable attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} cve
onyx:1> dup 1 sprint
_{1 2 3}_
onyx:1> echeck 1 sprint
true
onyx:0> {1 2 3} echeck 1 sprint
false
onyx:0> [1 2 3] echeck 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:egid}
\index{egid@\onyxop{}{egid}{}}
\item[{\onyxop{--}{egid}{gid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[gid: ]
			Process's effective group ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's effective group ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> egid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:end}
\index{end@\onyxop{}{end}{}}
\item[{\onyxop{--}{end}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{dstackunderflow}{dstackunderflow}.]
		\end{description}
	\item[Description: ]
		Pop the topmost dictionary off dstack, thereby removing its
		contents from the namespace.
	\item[Example(s): ]\begin{verbatim}

onyx:0> </foo `foo'> begin
onyx:0> foo 1 sprint
`foo'
onyx:0> end
onyx:0> foo 1 sprint
Error /undefined
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      foo
1:      -file-
2:      --start--
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:envdict}
\index{envdict@\onyxop{}{envdict}{}}
\item[{\onyxop{--}{envdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get envdict.  See Section~\ref{sec:envdict} for details on
		envdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> envdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:eq}
\index{eq@\onyxop{}{eq}{}}
\item[{\onyxop{a b}{eq}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for equality.  Equality has the following
		meaning, depending on the types of \oparg{a} and \oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are equal iff they refer to
		the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are equal iff they
		refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are equal iff they
		are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are equal iff they
		are the same value.
		\item[integer, real: ] \oparg{a} and \oparg{b} are equal iff
		they are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex eq 1 sprint
false
onyx:0> mutex dup eq 1 sprint
true
onyx:0> /foo `foo' eq 1 sprint
true
onyx:0> true true eq 1 sprint
true
onyx:0> true false eq 1 sprint
false
onyx:0> 1 1 eq 1 sprint
true
onyx:0> 1 2 eq 1 sprint
false
onyx:0> 1.0 1 eq 1 sprint
true
onyx:0> 1.0 1.1 eq 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:estack}
\index{estack@\onyxop{}{estack}{}}
\item[{\onyxop{--}{estack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the execution stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:euid}
\index{euid@\onyxop{}{euid}{}}
\item[{\onyxop{--}{euid}{uid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[uid: ]
			Process's effective user ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's effective user ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> euid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:eval}
\index{eval@\onyxop{}{eval}{}}
\item[{\onyxop{object}{eval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ``hi' 1 sprint' cvx eval
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exch}
\index{exch@\onyxop{}{exch}{}}
\item[{\onyxop{a b}{exch}{b a}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[b: ]
			The same object that was passed in.
		\item[a: ]
			The same object that was passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 pstack
2
1
onyx:2> exch pstack
1
2
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:exec}
\index{exec@\onyxop{}{exec}{}}
\item[{\onyxop{args}{exec}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of the program to invoke, and any additional
			array elements are passed as command line arguments to
			the invoked program.
		\end{description}
	\item[Output(s): ] None (this operator does not return).
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Overlay a new program and execute it.  The current contents of
		envdict are used to construct the new program's environment.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Old program'
onyx:1> [`/usr/local/bin/onyx'] exec
Canonware Onyx, version 1.0.0.
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exit}
\index{exit@\onyxop{}{exit}{}}
\item[{\onyxop{--}{exit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Exit the innermost enclosing looping context immediately.
		This operator can be called within the looping context of
		\htmlref{\onyxop{}{for}{}}{systemdict:for},
		\htmlref{\onyxop{}{repeat}{}}{systemdict:repeat},
		\htmlref{\onyxop{}{loop}{}}{systemdict:loop},
		\htmlref{\onyxop{}{foreach}{}}{systemdict:foreach}, and
		\htmlref{\onyxop{}{dirforeach}{}}{systemdict:dirforeach}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {`hi' 1 sprint exit `bye' 1 sprint} loop
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:exp}
\index{exp@\onyxop{}{exp}{}}
\item[{\onyxop{a b}{exp}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} to the \oparg{b} power.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return \oparg{a} to the \oparg{b} power.  If a negative exponent
		is specified, the result will always be a real, even if both
		arguments are integers.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 0 exp 1 sprint
1
onyx:0> 5 1 exp 1 sprint
5
onyx:0> 5 2 exp 1 sprint
25
onyx:0> -5 3 exp 1 sprint
-125
onyx:0> 5 -3 exp 1 sprint
8.000000e-03
onyx:0> 2.1 3.5 exp 1 sprint
1.342046e+01
onyx:0> 100 .01 exp 1 sprint
1.000000e+02
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:false}
\index{false@\onyxop{}{false}{}}
\item[{\onyxop{--}{false}{false}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[false: ]
			The boolean value false.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return false.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:floor}
\index{floor@\onyxop{}{floor}{}}
\item[{\onyxop{a}{floor}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer floor of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the integer floor of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 floor 1 sprint
-2
onyx:0> -1.49 floor 1 sprint
-2
onyx:0> 0 floor 1 sprint
0
onyx:0> 1.49 floor 1 sprint
1
onyx:0> 1.51 floor 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:flush}
\index{flush@\onyxop{}{flush}{}}
\item[{\onyxop{--}{flush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\end{description}
	\item[Description: ]
		Flush any buffered data associated with stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print
onyx:0> flush
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:flushfile}
\index{flushfile@\onyxop{}{flushfile}{}}
\item[{\onyxop{file}{flushfile}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Flush any buffered data associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print
onyx:0> stdout flushfile
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:for}
\index{for@\onyxop{}{for}{}}
\item[{\onyxop{init inc limit proc}{for}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[init: ]
			Initial value of control variable.
		\item[inc: ]
			Amount to increment control variable by at the end of
			each iteration.
		\item[limit: ]
			Inclusive upper bound for control variable if less than
			or equal to \oparg{init}, otherwise inclusive lower
			bound for control variable.
		\item[proc: ]
			An object.
		\end{description}
	\item[Output(s): ]  At the beginning of each iteration, the current
		value of the control variable is pushed onto ostack.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Iteratively evaluate \oparg{proc}, pushing a control variable
		onto ostack at the beginning of each iteration, until the
		control variable has exceeded \oparg{limit}.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 1 3 {1 sprint} for
0
1
2
3
onyx:0> 0 -1 -3 {1 sprint} for
0
-1
-2
-3
onyx:0> 0 2 7 {1 sprint} for
0
2
4
6
onyx:0> 0 1 1000 {dup 1 sprint 3 eq {exit} if} for
0
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:foreach}
\index{foreach@\onyxop{}{foreach}{}}
\item[{\onyxop{array proc}{foreach}{--}}: ]
\item[{\onyxop{dict proc}{foreach}{--}}: ]
\item[{\onyxop{stack proc}{foreach}{--}}: ]
\item[{\onyxop{string proc}{foreach}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[stack: ]
			A stack object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		For each entry in the first input argument (\oparg{array},
		\oparg{dict}, \oparg{stack}, or \oparg{string}), push the entry
		onto ostack and execute \oparg{proc}.  This operator supports
		the \htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2] {1 sprint} foreach
1
2
onyx:0> </foo `foo' /bar `bar'> {pstack clear} foreach
`bar'
/bar
`foo'
/foo
onyx:0> (1 2) {pstack clear} foreach
2
1
onyx:0> `ab' {pstack clear} foreach
97
98
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:fork}
\index{fork@\onyxop{}{fork}{}}
\item[{\onyxop{--}{fork}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier for the new process, or 0 if the
			child process.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\end{description}
	\item[Description: ]
		Fork a new process.  Care must be taken when using the fork
		operator due to the fact that onyx consumes programs on the
		fly.  The child process cannot reliably scan onyx code from the
		same source as the parent, so the child process should be forked
		into an environment where it is executing an object that has
		already been constructed by the interpreter, which in turn
		avoids unwinding the onyx execution stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {fork dup 0 eq
        {pop `Child\n' print flush}
        {`Parent\n' print flush waitpid}
        ifelse} eval
Parent
Child
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gcdict}
\index{gcdict@\onyxop{}{gcdict}{}}
\item[{\onyxop{--}{gcdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get gcdict.  See Section~\ref{sec:gcdict} for details on
		gcdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gcdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ge}
\index{ge@\onyxop{}{ge}{}}
\item[{\onyxop{a b}{ge}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 ge 1 sprint
false
onyx:0> 1 1 ge 1 sprint
true
onyx:0> 2 1 ge 1 sprint
true
onyx:0> 1 1.1 ge 1 sprint
false
onyx:0> 1.1 1.1 ge 1 sprint
true
onyx:0> 1.1 1 ge 1 sprint
true
onyx:0> `a' `b' ge 1 sprint
false
onyx:0> `a' `a' ge 1 sprint
true
onyx:0> `b' `a' ge 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:get}
\index{get@\onyxop{}{get}{}}
\item[{\onyxop{array index}{get}{object}}: ]
\item[{\onyxop{dict key}{get}{value}}: ]
\item[{\onyxop{string index}{get}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[string: ]
			A string object.
		\item[index: ] Offset of \oparg{array} element or \oparg{string}
		element.
		\item[key: ]
			A key in \oparg{dict}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The object in \oparg{array} at offset \oparg{index}.
		\item[value: ]
			The value in \oparg{dict} corresponding to \oparg{key}.
		\item[integer: ]
			The ascii value of the character in \oparg{string} at
			offset \oparg{index}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Get an element of \oparg{array}, a value in \oparg{dict}, or an
		element of \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`a' `b' `c'] 1 get 1 sprint
`b'
onyx:0> </foo `foo' /bar `bar'> /bar get 1 sprint
`bar'
onyx:0> `abc' 1 get 1 sprint
98
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:getinterval}
\index{getinterval@\onyxop{}{getinterval}{}}
\item[{\onyxop{array index length}{getinterval}{subarray}}: ]
\item[{\onyxop{string index length}{getinterval}{substring}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[string: ]
			A string object.
		\item[index: ]
			The offset into \oparg{array} or \oparg{string} to get
			the interval from.
		\item[length: ]
			The length of the interval in \oparg{array} or
			\oparg{string} to get.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[subarray: ]
			A subarray of \oparg{array} at offset \oparg{index} and
			of length \oparg{length}.
		\item[substring: ]
			A substring of \oparg{string} at offset \oparg{index}
			and of length \oparg{length}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get an interval of \oparg{array} or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [0 1 2 3] 1 2 getinterval 1 sprint
[1 2]
onyx:0> `abcd' 1 2 getinterval 1 sprint
`bc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gid}
\index{gid@\onyxop{}{gid}{}}
\item[{\onyxop{--}{gid}{gid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[gid: ]
			Process's group ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's group ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> gid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:globaldict}
\index{globaldict@\onyxop{}{globaldict}{}}
\item[{\onyxop{--}{globaldict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get globaldict.  See Section~\ref{sec:globaldict} for details on
		globaldict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> globaldict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:gt}
\index{gt@\onyxop{}{gt}{}}
\item[{\onyxop{a b}{gt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is greater than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 1 gt 1 sprint
false
onyx:0> 2 1 gt 1 sprint
true
onyx:0> 1.1 1.1 gt 1 sprint
false
onyx:0> 1.1 1 gt 1 sprint
true
onyx:0> `a' `a' gt 1 sprint
false
onyx:0> `b' `a' gt 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:hooktag}
\index{hooktag@\onyxop{}{hooktag}{}}
\item[{\onyxop{hook}{hooktag}{tag}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[hook: ]
			A hook object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[tag: ]
			The tag associated with \oparg{hook}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the tag associated with \oparg{hook}.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:idiv}
\index{idiv@\onyxop{}{idiv}{}}
\item[{\onyxop{a b}{idiv}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The integer quotient of \oparg{a} divided by \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
		Return the integer quotient of \oparg{a} divided by \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 idiv 1 sprint
2
onyx:0> 5 2 idiv 1 sprint
2
onyx:0> 5 0 idiv
Error /undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --idiv--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:if}
\index{if@\onyxop{}{if}{}}
\item[{\onyxop{boolean object}{if}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object} if \oparg{boolean} is true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes' 1 sprint} if
`yes'
onyx:0> false {`yes' 1 sprint} if
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ifelse}
\index{ifelse@\onyxop{}{ifelse}{}}
\item[{\onyxop{boolean a b}{ifelse}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean.
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{a} if \oparg{boolean} is true, evaluate
		\oparg{b} otherwise.  See Section~\ref{sec:onyx_objects} for
		details on object evaluation.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true {`yes'}{`no'} ifelse 1 sprint
`yes'
onyx:0> false {`yes'}{`no'} ifelse 1 sprint
`no'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:index}
\index{index@\onyxop{}{index}{}}
\item[{\onyxop{object \dots index}{index}{object \dots object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\item[\dots: ]
			\oparg{index} objects.
		\item[index: ]
			Depth (count starts at 0, not counting \oparg{index}) of
			the object to duplicate on ostack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The same object that was passed in.
		\item[\dots: ]
			The same \oparg{index} objects that were passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on on ostack at depth
		\oparg{index}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 2 index pstack
2
0
1
2
3
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:iobuf}
\index{iobuf@\onyxop{}{iobuf}{}}
\item[{\onyxop{file}{iobuf}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The size in bytes of the I/O buffer associated with
			\oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the size of the I/O buffer associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout iobuf 1 sprint
512
onyx:0> stderr iobuf 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:istack}
\index{istack@\onyxop{}{istack}{}}
\item[{\onyxop{--}{istack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of the index stack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of the index stack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> istack 1 sprint
(0 0 0)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:join}
\index{join@\onyxop{}{join}{}}
\item[{\onyxop{thread}{join}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for \oparg{thread} to exit.  A thread may only be detached
		or joined once; any attempt to do so more than once results in
		undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint} thread join `Done\n' print flush
3
Done
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:known}
\index{known@\onyxop{}{known}{}}
\item[{\onyxop{dict key}{known}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\item[key: ]
			A key to look for in \oparg{dict}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{key} is defined in \oparg{dict}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Check whether \oparg{key} is defined in \oparg{dict}.
	\item[Example(s): ]\begin{verbatim}

onyx:1> </foo `foo'> /foo known 1 sprint
true
onyx:1> </foo `foo'> /bar known 1 sprint
false
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:lcheck}
\index{lcheck@\onyxop{}{lcheck}{}}
\item[{\onyxop{object}{lcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An array, dict, file, or string.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{object} is implicitly locked, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Check if \oparg{object} is implicitly locked.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false setlocking
onyx:0> [1 2 3] lcheck 1 sprint
false
onyx:0> true setlocking
onyx:0> [1 2 3] lcheck 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:le}
\index{le@\onyxop{}{le}{}}
\item[{\onyxop{a b}{le}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than or equal to \oparg{b},
			false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 le 1 sprint
true
onyx:0> 1 1 le 1 sprint
true
onyx:0> 2 1 le 1 sprint
false
onyx:0> 1 1.1 le 1 sprint
true
onyx:0> 1.1 1.1 le 1 sprint
true
onyx:0> 1.1 1 le 1 sprint
false
onyx:0> `a' `b' le 1 sprint
true
onyx:0> `a' `a' le 1 sprint
true
onyx:0> `b' `a' le 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:length}
\index{length@\onyxop{}{length}{}}
\item[{\onyxop{array}{length}{count}}: ]
\item[{\onyxop{dict}{length}{count}}: ]
\item[{\onyxop{name}{length}{count}}: ]
\item[{\onyxop{string}{length}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[name: ]
			A name object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of elements in \oparg{array}, number of entries
			in \oparg{dict}, number of characters in \oparg{name},
			or number of characters in \oparg{string}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the umber of elements in \oparg{array}, number of entries in
		\oparg{dict}, number of characters in \oparg{name}, or number of
		characters in \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 2 3] length 1 sprint
3
onyx:0> </foo `foo' /bar `bar'> length 1 sprint
2
onyx:0> /foo length 1 sprint
3
onyx:0> `foo' length 1 sprint
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:link}
\index{link@\onyxop{}{link}{}}
\item[{\onyxop{filename linkname}{link}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[linkname: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a hard link from \oparg{linkname} to \oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' `/tmp/bar' link
onyx:0> `/tmp/bar' `r' open
onyx:1> readline
onyx:2> pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:ln}
\index{ln@\onyxop{}{ln}{}}
\item[{\onyxop{a}{ln}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Natural logarithm of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the natural logarithm of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 ln 1 sprint
1.609438e+00
onyx:0> 8.5 ln 1 sprint
2.140066e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:load}
\index{load@\onyxop{}{load}{}}
\item[{\onyxop{key}{load}{val}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A key to look up in dstack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[val: ]
			The value associated with the topmost definition of
			\oparg{key} in dstack.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Get the topmost definition of \oparg{key} in dstack.
	\item[Example(s): ]\begin{verbatim}

onyx:1> </foo `foo'> begin
onyx:1> </foo `FOO'> begin
onyx:1> /foo load 1 sprint
`FOO'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:lock}
\index{lock@\onyxop{}{lock}{}}
\item[{\onyxop{mutex}{lock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Acquire \oparg{mutex}, waiting if necessary.  Attempting to
		acquire \oparg{mutex} recursively will result in undefined
		behavior (likely deadlock or crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup lock unlock
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:log}
\index{log@\onyxop{}{log}{}}
\item[{\onyxop{a}{log}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Base 10 logarithm of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the base 10 logarithm of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 log 1 sprint
6.989700e-01
onyx:0> 8.5 log 1 sprint
9.294189e-01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:loop}
\index{loop@\onyxop{}{loop}{}}
\item[{\onyxop{proc}{loop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Iteratively evaluate \oparg{proc} indefinitely.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 {1 add dup 1 sprint dup 3 eq {pop exit} if} loop
1
2
3
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:lt}
\index{lt@\onyxop{}{lt}{}}
\item[{\onyxop{a b}{lt}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A number (integer or real) or string.
		\item[b: ]
			An object of a type compatible with \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is less than \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Compare two numbers or strings.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 lt 1 sprint
true
onyx:0> 1 1 lt 1 sprint
false
onyx:0> 1 1.1 lt 1 sprint
true
onyx:0> 1.1 1.1 lt 1 sprint
false
onyx:0> 1.1 1 lt 1 sprint
false
onyx:0> `a' `b' lt 1 sprint
true
onyx:0> `a' `a' lt 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mark}
\index{mark@\onyxop{}{mark}{}}
\item[{\onyxop{--}{mark}{mark}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mark: ]
			A mark object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Push a mark onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mark pstack
-mark-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:mkdir}
\index{mkdir@\onyxop{}{mkdir}{}}
\item[{\onyxop{path mode}{mkdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string object that represents a directory path.
		\item[mode: ]
			An integer that represents a Unix file mode.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8#755 mkdir
onyx:0> `/tmp/tdir' {1 sprint} dirforeach
`.'
`..'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mod}
\index{mod@\onyxop{}{mod}{}}
\item[{\onyxop{a b}{mod}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[b: ]
			A non-zero integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The modulus of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedresult}{undefinedresult}.]
		\end{description}
	\item[Description: ]
			Return the modulus of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 2 mod 1 sprint
0
onyx:0> 5 2 mod 1 sprint
1
onyx:0> 5 0 mod
Error /undefinedresult
ostack: (5 0)
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --mod--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:modload}
\index{modload@\onyxop{}{modload}{}}
\item[{\onyxop{path symbol}{modload}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents a module filename.
		\item[symbol: ]
			A string that represents the symbol name of a
			module initialization function to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Dynamically load a module, create a hook object that
		encapsulates the handle returned by dlopen(3) (hook data
		pointer) and the module initialization function (hook evaluation
		function), and evaluate the hook.

		All objects that refer to code and/or data that are part of the
		module must directly and/or indirectly maintain a reference to
		the hook that is evaluated by this operator, since failing to do
		so would allow the garbage collector to unload the module, which
		could result in dangling pointers to unmapped memory regions.

		Loadable modules present a problem for the garbage collector
		during the sweep phase.  All objects that refer to memory that
		is dynamically mapped as part of the module must be destroyed
		before the module is unloaded.  Destruction ordering constraints
		show up in other situations as well, but in the case of loadable
		modules, there is no reasonable solution except to explicitly
		order the destruction of objects.  Therefore, by default, the
		hook that is evaluated by modload is destroyed during the second
		sweep pass.  It is possible for a module to override what sweep
		pass the hook is destroyed on, in cases where there are
		additional ordering constraints for the objects created by a
		module.  This isn't important from the Onyx language
		perspective, but is important to understand when implementing
		modules.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/usr/local/share/onyx/nxmod/gtk.nxm' `modpane_init'
onyx:2> modload
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:monitor}
\index{monitor@\onyxop{}{monitor}{}}
\item[{\onyxop{mutex proc}{monitor}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex.
		\item[proc: ]
			Any object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Execute \oparg{proc} while holding \oparg{mutex}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex {`hello\n' print} monitor flush
hello
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mrequire}
\index{mrequire@\onyxop{}{mrequire}{}}
\item[{\onyxop{file symbol}{mrequire}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A string that represents a module filename.
		\item[symbol: ]
			A string that represents the symbol name of a
			module initialization function to be executed.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Search for and load a module.  The module is searched for by
		catenating a prefix, a ``/'', and \oparg{file} to form a file
		path.  Prefixes are tried in the following order:
		\begin{enumerate}
			\item{The ordered elements of the
			\htmlref{mpath\_pre}{onyxdict:mpath_pre} array, which is
			defined in \htmlref{onyxdict}{sec:onyxdict}.}
			\item{If defined, the ordered elements of the
			ONYX\_MPATH environment variable, which is a
			colon-separated list.}
			\item{The ordered elements of the
			\htmlref{mpath\_post}{onyxdict:mpath_post} array, which
			is defined in \htmlref{onyxdict}{sec:onyxdict}.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> `modgtk.nxm' `modgtk_init' mrequire
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:mul}
\index{mul@\onyxop{}{mul}{}}
\item[{\onyxop{a b}{mul}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The product of \oparg{a} and \oparg{b}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the product of \oparg{a} and \oparg{b}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 17 mul 1 sprint
51
onyx:0> -5 -6 mul 1 sprint
30
onyx:0> 3.5 4.0 mul 1 sprint
1.400000e+01
onyx:0> -1.5 3 mul 1 sprint
-4.500000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:mutex}
\index{mutex@\onyxop{}{mutex}{}}
\item[{\onyxop{--}{mutex}{mutex}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a mutex.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex 1 sprint
-mutex-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ndup}
\index{ndup@\onyxop{}{ndup}{}}
\item[{\onyxop{objects count}{ndup}{objects objects}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			Zero or more objects.
		\item[count: ]
			The number of \oparg{objects} do duplicate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[objects: ]
			The same objects that were passed in.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create duplicates of the top \oparg{count} objects on ostack.
		For composite objects, the new object is a reference to the same
		composite object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 2 ndup pstack
`c'
`b'
`c'
`b'
`a'
onyx:5>
		\end{verbatim}
	\end{description}
\label{systemdict:ne}
\index{ne@\onyxop{}{ne}{}}
\item[{\onyxop{a b}{ne}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An object.
		\item[b: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{a} is not equal to \oparg{b}, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Compare two objects for inequality.  Inequality has the
		following meaning, depending on the types of \oparg{a} and
		\oparg{b}:
		\begin{description}
		\item[array, condition, dict, file, hook, mutex, stack,
		thread: ] \oparg{a} and \oparg{b} are not equal unless they
		refer to the same memory.
		\item[operator: ] \oparg{a} and \oparg{b} are not equal unless
		they refer to the same function.
		\item[name, string: ] \oparg{a} and \oparg{b} are not equal iff
		they are lexically equivalent.  A name can be equal to a string.
		\item[boolean: ] \oparg{a} and \oparg{b} are not equal unless
		they are the same value.
		\item[integer, real: ] \oparg{a} and \oparg{b} are not equal
		unless they are the same value.
		\end{description}
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex mutex ne 1 sprint
true
onyx:0> mutex dup ne 1 sprint
false
onyx:0> /foo `foo' ne 1 sprint
false
onyx:0> /foo /bar ne 1 sprint
true
onyx:0> true false ne 1 sprint
true
onyx:0> true true ne 1 sprint
false
onyx:0> 1 1 ne 1 sprint
false
onyx:0> 1 2 ne 1 sprint
true
onyx:0> 1.0 1 ne 1 sprint
false
onyx:0> 1.0 1.1 ne 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:neg}
\index{neg@\onyxop{}{neg}{}}
\item[{\onyxop{a}{neg}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The negative of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the negative of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 neg 1 sprint
0
onyx:0> 5 neg 1 sprint
-5
onyx:0> -5 neg 1 sprint
5
onyx:0> 3.14 neg 1 sprint
-3.140000e+00
onyx:0> -3.14 neg 1 sprint
3.140000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:not}
\index{not@\onyxop{}{not}{}}
\item[{\onyxop{a}{not}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} is an integer, the bitwise negation of
			\oparg{a}, otherwise the logical negation of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise negation of an integer, or the logical
		negation of a boolean.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true not 1 sprint
false
onyx:0> false not 1 sprint
true
onyx:0> 1 not 1 sprint
-2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:npop}
\index{npop@\onyxop{}{npop}{}}
\item[{\onyxop{objects count}{npop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[objects: ]
			Zero or more objects.
		\item[count: ]
			Number of \oparg{objects} to pop.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove the top \oparg{count} \oparg{objects} off ostack and
		discard them.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' `b' `c' 2 npop pstack
`a'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:nsleep}
\index{nsleep@\onyxop{}{nsleep}{}}
\item[{\onyxop{nanoseconds}{nsleep}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[nanoseconds: ]
			Minimum number of nanoseconds to sleep.  Must be greater
			than 0.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Sleep for at least \oparg{nanoseconds} nanonseconds.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1000 nsleep
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:null}
\index{null@\onyxop{}{null}{}}
\item[{\onyxop{--}{null}{null}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[null: ]
			A null object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a null object.
	\item[Example(s): ]\begin{verbatim}

onyx:0> null pstack
null
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:onyxdict}
\index{onyxdict@\onyxop{}{onyxdict}{}}
\item[{\onyxop{--}{onyxdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get onyxdict.  See Section~\ref{sec:onyxdict} for details on
		onyxdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> onyxdict 1 sprint
</rpath_pre -array- /rpath_post -array- /mpath_pre -array- /mpath_post -array->
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:open}
\index{open@\onyxop{}{open}{}}
\item[{\onyxop{filename flags}{open}{file}}: ]
\item[{\onyxop{filename flags mode}{open}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[flags: ]
			A string that represents a file mode:
			\begin{description}\item[]
			\item[`r': ]
				Read only.
			\item[`r+': ]
				Read/write, starting at offset 0.
			\item[`w': ]
				Write only.  Create file if necessary.  Truncate
				file if non-zero length.
			\item[`w+': ]
				Read/write, starting at offset 0.  Create
				file if necessary.
			\item[`a': ]
				Write only, starting at end of file.
			\item[`a+': ]
				Read/write, starting at end of file.
			\end{description}
		\item[mode: ]
			Mode to use when creating a new file (defaults to 0777).
			Note that the process's umask also affects creation
			mode.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Open a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:or}
\index{or@\onyxop{}{or}{}}
\item[{\onyxop{a b}{or}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			or, otherwise their logical or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise or of two integers, or the logical or of
		two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> false false or 1 sprint
false
onyx:0> true false or 1 sprint
true
onyx:0> 5 3 or 1 sprint
7
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:ostack}
\index{ostack@\onyxop{}{ostack}{}}
\item[{\onyxop{--}{ostack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A current snapshot (copy) of ostack.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a current snapshot of ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2 3 ostack pstack
(1 2 3)
3
2
1
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:output}
\index{output@\onyxop{}{output}{}}
\item[{\onyxop{object depth}{output}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{object}.  See
		Section~\ref{sec:outputsdict} for format specifier details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4] </w 20 /p `_' /j /c /r 1> output `\n' print flush
___[1 -array- 4]____
onyx:0> [1 [2 3] 4] </w 20 /p `_' /j /c /r 2> output `\n' print flush
____[1 [2 3] 4]_____
onyx:0> 4242 </s /+> output `\n' print flush
+4242
onyx:0> `0x' print 4242 </b 16> output `\n' print flush
0x1092
onyx:0> `0x' 4242 </b 16> outputs cat </w 10 /p `.'>
onyx:2>  output `\n' print flush
....0x1092
onyx:0> `0x' print 4242 </w 8 /p `0' /b 16> output `\n' print flush
0x00001092
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:outputs}
\index{outputs@\onyxop{}{outputs}{}}
\item[{\onyxop{object flags}{outputs}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to print syntactically.
		\item[depth: ]
			Formatting flags.  See Section~\ref{sec:outputsdict} for
			details on the supported flags.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A formatted string representation of \oparg{object}.
			See Section~\ref{sec:outputsdict} for format specifier
			details.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a formatted string representation of \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4] </w 20 /p `_' /j /c /r 1> outputs print `\n' print flush
___[1 -array- 4]____
onyx:0> [1 [2 3] 4] </w 20 /p `_' /j /c /r 2> outputs print `\n' print flush
____[1 [2 3] 4]_____
onyx:0> 4242 </s /+> outputs print `\n' print flush
+4242
onyx:0> `0x' print 4242 </b 16> outputs print `\n' print flush
0x1092
onyx:0> `0x' 4242 </b 16> outputs cat </w 10 /p `.'> outputs 
onyx:1> print `\n' print flush
....0x1092
onyx:0> `0x' print 4242 </w 8 /p `0' /b 16> outputs print `\n' print flush
0x00001092
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:outputsdict}
\index{outputsdict@\onyxop{}{outputsdict}{}}
\item[{\onyxop{--}{outputsdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get outputsdict.  See Section~\ref{sec:outputsdict} for details
		on outputsdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> outputsdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pid}
\index{pid@\onyxop{}{pid}{}}
\item[{\onyxop{--}{pid}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process ID of the running process.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pid 1 sprint
80624
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pop}
\index{pop@\onyxop{}{pop}{}}
\item[{\onyxop{any}{pop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[any: ]
			Any object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Remove the top object off ostack and discard it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1 2
onyx:2> pstack
2
1
onyx:2> pop
onyx:1> pstack
1
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:poll}
\index{poll@\onyxop{}{poll}{}}
\item[{\onyxop{{\lt}file dict \dots{\gt} timeout}{poll}{{\lt}file dict
      \dots{\gt}}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[{\lt}\dots{\gt}: ]
			A dictionary of \oparg{file}/\oparg{dict} key/value
			pairs.
			\begin{description}\item[]
			\item[file: ]
				A file object.
			\item[dict: ]
				A dictionary that contains keys corresponding to
				\oparg{file} status attributes to poll.  The
				following keys are heeded:
				\begin{description}\item[]
				\item[POLLIN: ]
					Normal or priority data are available
					for reading.
				\item[POLLRDNORM: ]
					Normal data are available for reading.
				\item[POLLRDBAND: ]
					Priority data are available for reading.
				\item[POLLPRI: ]
					High-priority data are available for
					reading.
				\item[POLLOUT: ]
					Normal data can be written.
				\item[POLLWRNORM: ]
					Normal data can be written.
				\item[POLLWRBAND: ]
					Priority data can be written.
				\end{description}
				The values associated with the keys are
				disregarded, but are set appropriately before
				\onyxop{}{poll}{} returns.
			\end{description}
		\item[timeout: ]
			Timeout, in milliseconds (maximum $2^{31} - 1$).  -1 is
			treated specially to mean infinite timeout.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			The file object passed in.
		\item[dict: ]
			The dictionary passed in.  For each of the keys defined,
			the associated value is set to true or false, depending
			on the status of \oparg{file}.  In addition, the
			following keys may defined (if not already defined) with
			an associated value of true in the case of errors:
			\begin{description}\item[]
			\item[POLLERR: ]
				An error has occurred.
			\item[POLLHUP: ]
				Hangup has occurred.
			\item[POLLNVAL: ]
				\oparg{file} is not an open file.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for \oparg{file} to change status, and report status
		changes.
	\item[Example(s): ]\begin{verbatim}

		\end{verbatim}
	\end{description}
\label{systemdict:ppid}
\index{ppid@\onyxop{}{ppid}{}}
\item[{\onyxop{--}{ppid}{pid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process ID of the running process's parent.
	\item[Example(s): ]\begin{verbatim}

onyx:0> ppid 1 sprint
352
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:print}
\index{print@\onyxop{}{print}{}}
\item[{\onyxop{string}{print}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Print \oparg{string} to stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `Hi\n' print flush
Hi
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:product}
\index{product@\onyxop{}{product}{}}
\item[{\onyxop{--}{product}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the product name, normally
			`Canonware Onyx'.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the product string.  The string returned is a reference to
		the original product string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> product pstack
`Canonware Onyx'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:pstack}
\index{pstack@\onyxop{}{pstack}{}}
\item[{\onyxop{--}{pstack}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\end{description}
	\item[Description: ]
		Syntactically print the elements of ostack, one per line.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `a' 1 mark /foo [1 2 3] (4 5 6)
onyx:6> pstack
(4 5 6)
[1 2 3]
/foo
-mark-
1
`a'
onyx:6>
		\end{verbatim}
	\end{description}
\label{systemdict:put}
\index{put@\onyxop{}{put}{}}
\item[{\onyxop{array index object}{put}{--}}: ]
\item[{\onyxop{dict key value}{put}{--}}: ]
\item[{\onyxop{string index integer}{put}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[dict: ]
			A dict object.
		\item[string: ]
			A string object.
		\item[index: ]
			Offset in \oparg{array} or \oparg{string} to put
			\oparg{object} or \oparg{integer}, respectively.
		\item[key: ]
			An object to use as a key in \oparg{dict}.
		\item[object: ]
			An object to insert into \oparg{array} at offset
			\oparg{index}.
		\item[value: ]
			An object to associate with \oparg{key} in \oparg{dict}.
		\item[integer: ]
			The ascii value of a character to insert into
			\oparg{string} at offset \oparg{index}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Insert into \oparg{array}, \oparg{dict}, or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 array dup 1 `a' put 1 sprint
[null `a' null]
onyx:0> dict dup /foo `foo' put 1 sprint
</foo `foo'>
onyx:0> 3 string dup 1 97 put 1 sprint
`\x00a\x00'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:putinterval}
\index{putinterval@\onyxop{}{putinterval}{}}
\item[{\onyxop{array index subarray}{putinterval}{--}}: ]
\item[{\onyxop{string index substring}{putinterval}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[array: ]
			An array object.
		\item[string: ]
			A string object.
		\item[index: ]
			Offset into \oparg{array} or \oparg{string} to put
			\oparg{subarray} or \oparg{substring}, respectively.
		\item[subarray: ]
			An array object to put into \oparg{array} at offset
			\oparg{index}.  When inserted \oparg{subarray} must not
			extend past the end of \oparg{array}.
		\item[substring: ]
			A string object to put into \oparg{string} at offset
			\oparg{index}.  When inserted \oparg{substring} must not
			extend past the end of \oparg{string}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Replace a portion of \oparg{array} or \oparg{string}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 array dup 1 [`a' `b'] putinterval 1 sprint
[null `a' `b' null]
onyx:0> 4 string dup 1 `ab' putinterval 1 sprint
`\x00ab\x00'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:pwd}
\index{pwd@\onyxop{}{pwd}{}}
\item[{\onyxop{--}{pwd}{path}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string that represents the present working directory.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidaccess}{invalidaccess}.]
		\end{description}
	\item[Description: ]
		Push a string onto ostack that represents the present working
		directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> pwd
onyx:1> pstack
`/usr/local/bin'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:quit}
\index{quit@\onyxop{}{quit}{}}
\item[{\onyxop{--}{quit}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.  Under
		normal circumstances, there is always at least one such context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> estack 1 sprint
(--start-- -file- --start-- -file- --estack--)
onyx:0> quit
onyx:0> estack 1 sprint
(--start-- -file- --estack--)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rand}
\index{rand@\onyxop{}{rand}{}}
\item[{\onyxop{--}{rand}{integer}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			A pseudo-random non-negative integer, with 63 bits of
			psuedo-randomness.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return a pseudo-random integer.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 srand
onyx:0> rand 1 sprint
9018578418316157091
onyx:0> rand 1 sprint
8979240987855095636
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:read}
\index{read@\onyxop{}{read}{}}
\item[{\onyxop{file}{read}{integer boolean}}: ]
\item[{\onyxop{file string}{read}{substring boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[integer: ]
			An integer that represents the ascii value of a
			character that was read from \oparg{file}.
		\item[substring: ]
			A substring of \oparg{string} that contains data
			read from \oparg{file}.
		\item[boolean: ]
			If true, end of file reached during read.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Read from \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hello\n'
		\end{verbatim}
	\end{description}
\label{systemdict:readline}
\index{readline@\onyxop{}{readline}{}}
\item[{\onyxop{file}{readline}{string boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains a line of text from \oparg{file}.
		\item[boolean: ]
			If true, end of file reached during read.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Read a line of text from \oparg{file}.  Lines are separated
		by ``{\bs}n'' or ``{\bs}r{\bs}n'', which is removed.  The
		last line in a file may not have a newline at the end.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup `Goodbye\n' write
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1> dup readline 1 sprint 1 sprint
false
`Goodbye'
onyx:1> dup readline 1 sprint 1 sprint
true
`'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:realtime}
\index{realtime@\onyxop{}{realtime}{}}
\item[{\onyxop{--}{realtime}{nsecs}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[nsecs: ]
			Number of nanoseconds since the epoch (midnight on 1
			January 1970).
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the number of nanoseconds since the epoch.
	\item[Example(s): ]\begin{verbatim}

onyx:0> realtime 1 sprint
993539837806479000
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:rename}
\index{rename@\onyxop{}{rename}{}}
\item[{\onyxop{old new}{rename}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[old: ]
			A string object that represents a file path.
		\item[new: ]
			A string object that represents a file path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{limitcheck}{limitcheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Rename a file or directory from \oparg{old} to \oparg{new}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8#755 mkdir 
onyx:0> `/tmp/tdir' `/tmp/ndir' rename
onyx:0> `/tmp/ndir' {1 sprint} dirforeach
`.'
`..'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:repeat}
\index{repeat@\onyxop{}{repeat}{}}
\item[{\onyxop{count proc}{repeat}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[count: ]
			Number of times to evaluate \oparg{proc} (non-negative).
		\item[proc: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{proc} \oparg{count} times.  This operator
		supports the \htmlref{\onyxop{}{exit}{}}{systemdict:exit}
		operator.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 {`hi' 1 sprint} repeat
`hi'
`hi'
`hi'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:require}
\index{require@\onyxop{}{require}{}}
\item[{\onyxop{file}{require}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A string that represents a module filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\end{description}
	\item[Description: ]
		Search for and evaluate an Onyx source file.  The file is
		searched for by catenating a prefix, a ``/'', and \oparg{file}
		to form a file path.  Prefixes are tried in the following order:
		\begin{enumerate}
			\item{The ordered elements of the
			\htmlref{rpath\_pre}{onyxdict:rpath_pre} array, which is
			defined in \htmlref{onyxdict}{sec:onyxdict}.}
			\item{If defined, the ordered elements of the
			ONYX\_RPATH environment variable, which is a
			colon-separated list.}
			\item{The ordered elements of the
			\htmlref{rpath\_post}{onyxdict:rpath_post} array, which
			is defined in \htmlref{onyxdict}{sec:onyxdict}.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> `modgtk/modgtk_defs.nx' require
onyx:0>
	\end{verbatim}
	\end{description}
\label{systemdict:rmdir}
\index{rmdir@\onyxop{}{rmdir}{}}
\item[{\onyxop{path}{rmdir}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[path: ]
			A string object that represents a directory path.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Remove an empty directory.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/tdir' 8#755 mkdir
onyx:0> `/tmp/tdir' rmdir
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:roll}
\index{roll@\onyxop{}{roll}{}}
\item[{\onyxop{region count amount}{roll}{rolled}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[region: ]
			0 or more objects to be rolled.
		\item[count: ]
			Number of objects in \oparg{region}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[rolled: ]
			Rolled version of \oparg{region}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on ostack (not counting
		\oparg{count} and \oparg{amount}) by \oparg{amount} positions.
		A positive \oparg{amount} indicates an upward roll, whereas a
		negative \oparg{amount} indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 2 1 0 
onyx:4> pstack
0
1
2
3
onyx:4> 3 1 roll
onyx:4> pstack
1
2
0
3
onyx:4> 3 -2 roll
onyx:4> pstack
2
0
1
3
onyx:4> 4 0 roll
onyx:4> pstack
2
0
1
3
onyx:4>
		\end{verbatim}
	\end{description}
\label{systemdict:round}
\index{round@\onyxop{}{round}{}}
\item[{\onyxop{a}{round}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer round of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Round \oparg{a} to the nearest integer and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 round 1 sprint
-2
onyx:0> -1.49 round 1 sprint
-1
onyx:0> 0 round 1 sprint
0
onyx:0> 1.49 round 1 sprint
1
onyx:0> 1.51 round 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sclear}
\index{sclear@\onyxop{}{sclear}{}}
\item[{\onyxop{stack}{sclear}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Remove all objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3 4) dup sclear pstack
()
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scleartomark}
\index{scleartomark@\onyxop{}{scleartomark}{}}
\item[{\onyxop{stack}{scleartomark}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Remove objects from \oparg{stack} down to and including the
		topmost mark.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) dup scleartomark pstack
(3)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:scount}
\index{scount@\onyxop{}{scount}{}}
\item[{\onyxop{stack}{scount}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The number of objects on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the number of objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) scount 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:scounttomark}
\index{scounttomark@\onyxop{}{scounttomark}{}}
\item[{\onyxop{stack}{scounttomark}{count}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[count: ]
			The depth of the topmost mark on \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unmatchedmark}{unmatchedmark}.]
		\end{description}
	\item[Description: ]
		Get the depth of the topmost mark on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 mark 1 0) scounttomark 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sdup}
\index{sdup@\onyxop{}{sdup}{}}
\item[{\onyxop{stack}{sdup}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Duplicate the top object on \oparg{stack} and push it onto
		\oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1) dup sdup 1 sprint
(1 1)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:search}
\index{search@\onyxop{}{search}{}}
\item[{\onyxop{string pattern}{search}{post pattern pre true}}: ]
\item[{\onyxop{string pattern}{search}{string false}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string object.
		\item[pattern: ]
			A string that represents a substring to search for in
			\oparg{string}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[post: ]
			The substring of \oparg{string} that follows the match.
		\item[pattern: ]
			The substring of \oparg{string} that matches the input
			\oparg{pattern}.
		\item[pre: ]
			The substring of \oparg{string} that precedes the match.
		\item[true: ]
			Success.
		\item[string: ]
			The same object as the input \oparg{string}.
		\item[false: ]
			Failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Search for the first instance of \oparg{pattern} in
		\oparg{string}, and if found, return substrings that partition
		\oparg{string} into \oparg{pre}, \oparg{pattern}, and
		\oparg{post}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `abcabc' `ab' search pstack clear
true
`'
`ab'
`cabc'
onyx:0> `abcabc' `ca' search pstack clear
true
`ab'
`ca'
`bc'
onyx:0> `abcabc' `cb' search pstack clear
false
`abcabc'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:seek}
\index{seek@\onyxop{}{seek}{}}
\item[{\onyxop{file offset}{seek}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[offset: ]
			Offset in bytes from the beginning of \oparg{file}
			to move the file position pointer to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Move the file position pointer for \oparg{file} to
		\oparg{offset}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup 0 seek
onyx:1> readline pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:self}
\index{self@\onyxop{}{self}{}}
\item[{\onyxop{--}{self}{thread}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object that corresponds to the running thread.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get a thread object for the running thread.
	\item[Example(s): ]\begin{verbatim}

onyx:0> self 1 sprint
-thread-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setegid}
\index{setegid@\onyxop{}{setegid}{}}
\item[{\onyxop{gid}{setegid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[gid: ]
			A group ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's effective group ID to \oparg{gid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setegid 1 sprint
false
onyx:0> 0 setegid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setenv}
\index{setenv@\onyxop{}{setenv}{}}
\item[{\onyxop{key val}{setenv}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A name object.
		\item[val: ]
			A value to associate with \oparg{key}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set an environment variable named \oparg{key} and associate
		\oparg{val} with it.  If \oparg{val} is not a string, it is
		converted to a string using the
		\htmlref{\onyxop{}{cvs}{}}{systemdict:cvs} operator before the
		environment variable is set.  An corresponding entry is also
		created in the envdict dictionary.
	\item[Example(s): ]\begin{verbatim}

onyx:0> /foo `foo' setenv
onyx:0> envdict /foo known 1 sprint
true
onyx:0> envdict /foo get 1 sprint
`foo'
onyx:0> /foo unsetenv
onyx:0> envdict /foo known 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:seteuid}
\index{seteuid@\onyxop{}{seteuid}{}}
\item[{\onyxop{uid}{seteuid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[uid: ]
			A user ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's effective user ID to \oparg{uid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 seteuid 1 sprint
false
onyx:0> 0 seteuid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setgid}
\index{setgid@\onyxop{}{setgid}{}}
\item[{\onyxop{gid}{setgid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[gid: ]
			A group ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's group ID to \oparg{gid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setgid 1 sprint
false
onyx:0> 0 setgid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setiobuf}
\index{setiobuf@\onyxop{}{setiobuf}{}}
\item[{\onyxop{file count}{setiobuf}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[count: ]
			The size in bytes to set the I/O buffer associated with
			\oparg{file} to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the size of the I/O buffer associated with \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout iobuf 1 sprint
512
onyx:0> stdout 0 setiobuf
onyx:0> stdout iobuf 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setlocking}
\index{setlocking@\onyxop{}{setlocking}{}}
\item[{\onyxop{boolean}{setlocking}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			A boolean to set the implicit locking mode to.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the current implicit locking mode.  See
		Section~\ref{sec:implicit_synchronization} for implicit
		synchronization details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currentlocking 1 sprint
false
onyx:0> true setlocking
onyx:0> currentlocking 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:setuid}
\index{setuid@\onyxop{}{setuid}{}}
\item[{\onyxop{uid}{setuid}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[uid: ]
			A user ID.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise failure.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the process's user ID to \oparg{uid}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 1001 setuid 1 sprint
false
onyx:0> 0 setuid 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sexch}
\index{sexch@\onyxop{}{sexch}{}}
\item[{\onyxop{stack}{sexch}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Exchange the top two objects on \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2 3) dup sexch pstack
(1 3 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:shift}
\index{shift@\onyxop{}{shift}{}}
\item[{\onyxop{--}{shift}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer.
		\item[shift: ]
			An integer that represents a bitwise shift amount.
			Negative means right shift, and positive means left
			shift.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			\oparg{a} shifted by \oparg{shift} bits.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Shift an integer bitwise.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 1 shift 1 sprint
8
onyx:0> 4 -1 shift 1 sprint
2
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:signal}
\index{signal@\onyxop{}{signal}{}}
\item[{\onyxop{condition}{signal}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Signal a thread that is waiting on \oparg{condition}.  If there
		are no waiters, this operator has no effect.
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sin}
\index{sin@\onyxop{}{sin}{}}
\item[{\onyxop{a}{sin}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Sine of \oparg{a} in radians.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the sine of \oparg{a} in radians.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 sin 1 sprint
0.000000e+00
onyx:0> 1.570796 sin 1 sprint
1.000000e+00
onyx:0> 0.7853982 sin 1 sprint
7.071068e-01
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sindex}
\index{sindex@\onyxop{}{sindex}{}}
\item[{\onyxop{stack index}{sindex}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[index: ]
			Depth (count starts at 0) of the object to duplicate in
			\oparg{stack}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a duplicate of the object on \oparg{stack} at depth
		\oparg{index} and push it onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0) dup 2 sindex
onyx:1> 1 sprint
(3 2 1 0 2)
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:spop}
\index{spop@\onyxop{}{spop}{}}
\item[{\onyxop{stack}{spop}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The object that was popped off of \oparg{stack}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Pop an object off of \oparg{stack} and push it onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) dup spop
onyx:2> pstack
2
(1)
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:sprint}
\index{sprint@\onyxop{}{sprint}{}}
\item[{\onyxop{object depth}{sprint}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Syntactically print \oparg{object}.  See
		Section~\ref{sec:sprintsdict} for printing details.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4]
onyx:1> dup 0 sprint
-array-
onyx:1> dup 1 sprint
[1 -array- 4]
onyx:1> dup 2 sprint
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sprints}
\index{sprints@\onyxop{}{sprints}{}}
\item[{\onyxop{object depth}{sprints}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to print syntactically.
		\item[depth: ]
			Maximum recursion depth.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A syntactical string representation of \oparg{object}.
			See Section~\ref{sec:sprintsdict} for printing details.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a syntactical string representation of \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [1 [2 3] 4]
onyx:1> dup 0 sprints print `\n' print flush
-array-
onyx:1> dup 1 sprints print `\n' print flush
[1 -array- 4]
onyx:1> dup 2 sprints print `\n' print flush
[1 [2 3] 4]
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sprintsdict}
\index{sprintsdict@\onyxop{}{sprintsdict}{}}
\item[{\onyxop{--}{sprintsdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get sprintsdict.  See Section~\ref{sec:sprintsdict} for details
		on sprintsdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> sprintsdict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:spush}
\index{spush@\onyxop{}{spush}{}}
\item[{\onyxop{stack object}{spush}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Push \oparg{object} onto \oparg{stack}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> () dup 1 spush
onyx:1> pstack
(1)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:sqrt}
\index{sqrt@\onyxop{}{sqrt}{}}
\item[{\onyxop{a}{sqrt}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			A non-negative integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Square root of \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the square root of \oparg{a}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 4 sqrt 1 sprint
2.000000e+00
onyx:0> 2.0 sqrt 1 sprint
1.414214e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:srand}
\index{srand@\onyxop{}{srand}{}}
\item[{\onyxop{seed}{srand}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[seed: ]
			A non-negative integer.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Seed the pseudo-random number generator with \oparg{seed}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 srand
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sroll}
\index{sroll@\onyxop{}{sroll}{}}
\item[{\onyxop{stack count amount}{sroll}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack object.
		\item[count: ]
			Number of objects to roll in \oparg{stack}.
		\item[amount: ]
			Amount by which to roll.  If positive, roll
			upward.  If negative, roll downward.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Roll the top \oparg{count} objects on \oparg{stack} by
		\oparg{amount} positions.  A positive \oparg{amount}
		indicates an upward roll, whereas a negative \oparg{amount}
		indicates a downward roll.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (3 2 1 0)
onyx:1> dup 3 1 sroll pstack
(3 0 2 1)
onyx:1> dup 3 -2 sroll pstack
(3 1 0 2)
onyx:1> dup 4 0 sroll pstack
(3 1 0 2)
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stack}
\index{stack@\onyxop{}{stack}{}}
\item[{\onyxop{--}{stack}{stack}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[stack: ]
			An empty stack object.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Create a new stack object and push it onto ostack.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stack
onyx:1> pstack
()
		\end{verbatim}
	\end{description}
\label{systemdict:start}
\index{start@\onyxop{}{start}{}}
\item[{\onyxop{object}{start}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  This operator provides a context that
		silently terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit},
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}, and
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop} operators.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin cvx start
onyx:0> quit
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:status}
\index{status@\onyxop{}{status}{}}
\item[{\onyxop{file/filename}{status}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary that contains the following entries:
			\begin{description}\item[]
			\item[dev: ]
				Inode's device.
			\item[ino: ]
				Inode's number.
			\item[mode: ]
				Inode permissions.
			\item[nlink: ]
				Number of hard links.
			\item[uid: ]
				User ID of the file owner.
			\item[gid: ]
				Group ID of the file owner.
			\item[rdev: ]
				Device type.
			\item[size: ]
				File size in bytes.
			\item[atime: ]
				Time of last access, in nanoseconds since the
				epoch.
			\item[mtime: ]
				Time of last modification, in nanoseconds since
				the epoch.
			\item[ctime: ]
				Time of last file status change, in nanoseconds
				since the epoch.
			\item[blksize: ]
				Optimal block size for I/O.
			\item[blocks: ]
				Number of blocks allocated.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Get status information about a file.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp' status 1 sprint
</dev 134405 /ino 2 /mode 17407 /nlink 5 /uid 0 /gid 0 /rdev 952 /size 3584
/atime 994883041000000000 /mtime 994883041000000000 /ctime 994883041000000000
/blksize 0 /blocks 8>
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stderr}
\index{stderr@\onyxop{}{stderr}{}}
\item[{\onyxop{--}{stderr}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to stderr.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stderr pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stdin}
\index{stdin@\onyxop{}{stdin}{}}
\item[{\onyxop{--}{stdin}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to stdin.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get stdin.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdin pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stdout}
\index{stdout@\onyxop{}{stdout}{}}
\item[{\onyxop{--}{stdout}{file}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object corresponding to stdout.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get stdout.
	\item[Example(s): ]\begin{verbatim}

onyx:0> stdout pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:stop}
\index{stop@\onyxop{}{stop}{}}
\item[{\onyxop{--}{stop}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Unwind the execution stack to the innermost
		\htmlref{\onyxop{}{stopped}{}}{systemdict:stopped} or
		\htmlref{\onyxop{}{start}{}}{systemdict:start} context.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:stopped}
\index{stopped@\onyxop{}{stopped}{}}
\item[{\onyxop{object}{stopped}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object to evaluate.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if stop operator was executed, false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidexit}{invalidexit}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Evaluate \oparg{object}.  This operator provides a context that
		terminates execution stack unwinding due to the
		\htmlref{\onyxop{}{stop}{}}{systemdict:stop}.  It will also
		terminate execution stack unwinding due to the 
		\htmlref{\onyxop{}{exit}{}}{systemdict:exit} operator, but will
		throw an \htmlref{invalidexit}{invalidexit} error, then do the
		equivalent of calling
		\htmlref{\onyxop{}{quit}{}}{systemdict:quit}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {stop} stopped 1 sprint
true
onyx:0> {} stopped 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:string}
\index{string@\onyxop{}{string}{}}
\item[{\onyxop{length}{string}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[length: ]
			Non-negative number of bytes.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string of \oparg{length} bytes.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create a string of \oparg{length} bytes.  The bytes are
		initialized to 0.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 3 string 1 sprint
`\x00\x00\x00'
onyx:0>
onyx:0> 0 string 1 sprint
`'
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:sub}
\index{sub@\onyxop{}{sub}{}}
\item[{\onyxop{a b}{sub}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\item[b: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			The value of \oparg{b} subtracted from \oparg{a}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Subtract \oparg{b} from \oparg{a} and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 5 3 sub 1 sprint
2
onyx:0> -3 4 sub 1 sprint
-7
onyx:0> 5.1 1.1 sub 1 sprint
4.000000e+00
onyx:0> 5 1.0 sub 1 sprint
4.000000e+00
onyx:0> -3.0 4.1 sub 1 sprint
-7.100000e+00
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:symlink}
\index{symlink@\onyxop{}{symlink}{}}
\item[{\onyxop{filename linkname}{symlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\item[linkname: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Create a symbolic link from \oparg{linkname} to
		\oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' `/tmp/bar' symlink
onyx:0> `/tmp/bar' `r' open
onyx:1> readline
onyx:2> pstack
false
`Hello'
onyx:2>
		\end{verbatim}
	\end{description}
\label{systemdict:system}
\index{system@\onyxop{}{system}{}}
\item[{\onyxop{args}{system}{status}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[args: ]
			An array of strings.  The first string in \oparg{args}
			is the path of the program to invoke, and any additional
			array elements are passed as command line arguments to
			the invoked program.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[status: ]
			Exit code of terminated process.  A negative value
			indicates that the process was terminated by a signal
			(use the \htmlref{\onyxop{}{neg}{}}{systemdict:neg}
			operator to get the signal number), and a non-negative
			value is the exit code of a program that terminated
			normally.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Execute a program as a child process and wait for it to
		terminate.
	\item[Example(s): ]\begin{verbatim}

onyx:0> [`/usr/bin/which' `onyx'] system
/usr/local/bin/onyx
onyx:1> 1 sprint
0
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:tell}
\index{tell@\onyxop{}{tell}{}}
\item[{\onyxop{file}{tell}{offset}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[fil: ]
			A file object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[offset: ]
			Offset of the file position pointer for \oparg{file}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Get the file position pointer offset for \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup tell 1 sprint
0
onyx:1> dup `Hello\n' write
onyx:1> dup tell 1 sprint
6
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:test}
\index{test@\onyxop{}{test}{}}
\item[{\onyxop{file/filename flag}{test}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[filename: ]
			A string that represents a filename.
		\item[flag: ]
			A single-character string that represents the test to do
			on \oparg{file} or \oparg{filename}:
			\begin{description}\item[]
			\item[`b': ]
				Block special device?
			\item[`c': ]
				Character special device?
			\item[`d': ]
				Directory?
			\item[`e': ]
				Exists?
			\item[`f': ]
				Regular file?
			\item[`g': ]
				Setgid?
			\item[`k': ]
				Sticky?
			\item[`p': ]
				Named pipe?
			\item[`r': ]
				Readable?
			\item[`s': ]
				Size greater than 0?
			\item[`t': ]
				tty?
			\item[`u': ]
				Setuid?
			\item[`w': ]
				Write bit set?
			\item[`x': ]
				Executable bit set?
			\item[`L': ]
				Symbolic link?
			\item[`O': ]
				Owner matches effective uid?
			\item[`G': ]
				Group matches effective gid?
			\item[`S': ]
				Socket?
			\end{description}
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If true, the test evaluated to true; false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Test a file for an attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/blah' `e' test 1 sprint
false
onyx:0> `/tmp' `e' test 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:thread}
\index{thread@\onyxop{}{thread}{}}
\item[{\onyxop{stack entry}{thread}{thread}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[stack: ]
			A stack that contains the contents for the new thread's
			ostack.
		\item[entry: ]
			An initial object to execute in the new thread.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[thread: ]
			A thread object that corresponds to the new thread.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Create and run a new thread.
	\item[Example(s): ]\begin{verbatim}

onyx:0> (1 2) {add 1 sprint} thread join `Done\n' print flush
3
Done
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:throw}
\index{throw@\onyxop{}{throw}{}}
\item[{\onyxop{name}{throw}{object}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[name: ] The name of an error.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[object: ]
			The object that was being executed when the error was
			thrown.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Throw an error, using the following steps:
		\begin{enumerate}
		\item{Set newerror in the currenterror dictionary to true.}
		\item{Set errorname in the currenterror dictionary to
		\oparg{name}.}
		\item{Set ostack, dstack, estack, and istack in the currenterror
		dictionary to be current stack snapshots.}
		\item{Push the object that was being executed before throw was
		called onto ostack.}
		\item{If there is an error handler in the errordict dictionary
		that corresponds to \oparg{name}, evaluate it.  Otherwise,
		evaluate errordict's
		\htmlref{\onyxop{}{handleerror}{}}{errordict:handleerror} and
		\htmlref{\onyxop{}{stop}{}}{errordict:stop} operators.}
		\end{enumerate}
	\item[Example(s): ]\begin{verbatim}

onyx:0> /unregistered throw
Error /unregistered
ostack: ()
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..1):
0:      -file-
1:      --start--
onyx:1> pstack
-file-
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:timedwait}
\index{timedwait@\onyxop{}{timedwait}{}}
\item[{\onyxop{condition mutex timeout}{timedwait}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[mutex: ]
			A mutex object that this thread currently owns.
		\item[timeout: ]
			Minimum number of nanoseconds to wait for
			\oparg{condition}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, success, otherwise timeout.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait on \oparg{condition} for at least \oparg{timeout}
		nanoseconds.  \oparg{mutex} is atomically released when the
		current thread blocks, then acquired again before the current
		thread runs again.  Using a mutex that the current thread does
		not own will result in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> 1000000000 timedwait 1 sprint unlock join
false
onyx:0> mutex condition 1 index dup lock 1000000000 timedwait 1 sprint unlock
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:token}
\index{token@\onyxop{}{token}{}}
\item[{\onyxop{file/string}{token}{false}}: ]
\item[{\onyxop{file/string}{token}{file/substring object true}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file that is used as onyx source code to scan a token
			from.
		\item[string: ]
			A string that is used as onyx source code to scan a
			token from.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[file: ]
			The same file object that was passed in.
		\item[substring: ]
			The remainder of \oparg{string} after scanning a token.
		\item[object: ]
			An object that was constructed by scanning a token.
		\item[false/true: ]
			If true, a token was successfully scanned, false
			otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{syntaxerror}{syntaxerror}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefined}{undefined}.]
		\end{description}
	\item[Description: ]
		Scan a token from a file or string, using onyx syntax rules.  If
		a token is followed by whitespace, one character of whitespace
		is consumed when the token is scanned.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `1 2' token pstack clear
true
1
`2'
onyx:0> `foo' token pstack clear
true
foo
`'
onyx:0> `foo ' token pstack clear
true
foo
`'
onyx:0> `foo  ' token pstack clear
true
foo
` '
onyx:0> `foo/bar' token pstack clear
true
foo
`/bar'
onyx:0> `foo{}' token pstack clear
true
foo
`{}'
onyx:0> ` ' token pstack clear
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:trunc}
\index{trunc@\onyxop{}{trunc}{}}
\item[{\onyxop{a}{trunc}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or real.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			Integer created from \oparg{a} by discarding the
			fractional portion.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Discard the fractional portion of \oparg{a} to create an
		integer, and return the result.
	\item[Example(s): ]\begin{verbatim}

onyx:0> -1.51 trunc 1 sprint
-1
onyx:0> -1.49 trunc 1 sprint
-1
onyx:0> 0 trunc 1 sprint
0
onyx:0> 1.49 trunc 1 sprint
1
onyx:0> 1.51 trunc 1 sprint
1
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:truncate}
\index{truncate@\onyxop{}{truncate}{}}
\item[{\onyxop{file length}{truncate}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[length: ]
			New length for \oparg{file}.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{rangecheck}{rangecheck}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Set the length of \oparg{file} to \oparg{length}.  If this
		causes the file to grow, the appended bytes will have the
		value zero.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hello\n'
onyx:1> dup 3 truncate
onyx:1> dup 0 seek
onyx:1> dup 10 string read
onyx:3> pop 1 sprint
`Hel'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:true}
\index{true@\onyxop{}{true}{}}
\item[{\onyxop{--}{true}{true}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[true: ]
			The boolean value true.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Return true.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:trylock}
\index{trylock@\onyxop{}{trylock}{}}
\item[{\onyxop{mutex}{trylock}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			If false, \oparg{mutex} was successfully acquired.
			Otherwise the mutex acquisition failed.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Try to acquire \oparg{mutex}, but return a failure immediately
		if \oparg{mutex} cannot be acquired, rather than blocking.
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup 
onyx:2> trylock 1 sprint
false
onyx:1> trylock 1 sprint
true
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:type}
\index{type@\onyxop{}{type}{}}
\item[{\onyxop{object}{type}{name}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[name: ]
			An executable name that corresponds to the type of
			\oparg{object}:
			\begin{description}
			\item[array: ] arraytype.
			\item[boolean: ] booleantype.
			\item[condition: ] conditiontype.
			\item[dict: ] dicttype.
			\item[file: ] filetype.
			\item[fino: ] finotype.
			\item[hook: ] hooktype.
			\item[integer: ] integertype.
			\item[mark: ] marktype.
			\item[mutex: ] mutextype.
			\item[name: ] nametype.
			\item[null: ] nulltype.
			\item[operator: ] operatortype.
			\item[pmark: ] pmarktype.
			\item[stack: ] stacktype.
			\item[string: ] stringtype.
			\item[thread: ] threadtype.
			\end{description}
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Get a name that represent the type of \oparg{object}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true type 1 sprint
booleantype
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:uid}
\index{uid@\onyxop{}{uid}{}}
\item[{\onyxop{--}{uid}{uid}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[uid: ]
			Process's user ID.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the process's user ID.
	\item[Example(s): ]\begin{verbatim}

onyx:0> uid 1 sprint
1001
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:undef}
\index{undef@\onyxop{}{undef}{}}
\item[{\onyxop{dict key}{undef}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[dict: ]
			A dictionary.
		\item[val: ]
			A key in \oparg{dict} to undefine.
		\end{description}
	\item[Output(s): ] None
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		If \oparg{key} is defined in \oparg{dict}, undefine it.
	\item[Example(s): ]\begin{verbatim}

onyx:0> /foo `foo' def
onyx:0> currentdict /foo undef
onyx:0> currentdict /foo undef
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:unlink}
\index{unlink@\onyxop{}{unlink}{}}
\item[{\onyxop{filename}{unlink}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[filename: ]
			A string that represents a filename.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{invalidfileaccess}{invalidfileaccess}.]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\item[\htmlref{undefinedfilename}{undefinedfilename}.]
		\item[\htmlref{unregistered}{unregistered}.]
		\end{description}
	\item[Description: ]
		Unlink \oparg{filename}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w' open
onyx:1> dup `Hello\n' write
onyx:1> dup flushfile
onyx:1> close
onyx:0> `/tmp/foo' unlink
onyx:0> `/tmp/foo' `r' open
Error /invalidfileaccess
ostack: (`/tmp/foo' `r')
dstack: (-dict- -dict- -dict- -dict-)
estack/istack trace (0..2):
0:      --open--
1:      -file-
2:      --start--
onyx:3>
		\end{verbatim}
	\end{description}
\label{systemdict:unlock}
\index{unlock@\onyxop{}{unlock}{}}
\item[{\onyxop{mutex}{unlock}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[mutex: ]
			A mutex object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Unlock \oparg{mutex}.  Unlocking a mutex that the running thread
		does not own will result in undefined behavior (likely crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> mutex dup lock unlock
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:unsetenv}
\index{unsetenv@\onyxop{}{unsetenv}{}}
\item[{\onyxop{key}{unsetenv}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A name object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Unset \oparg{key} in the environment and in the envdict
		dictionary, if \oparg{key} is defined.
	\item[Example(s): ]\begin{verbatim}

onyx:0> /foo `foo' setenv
onyx:0> envdict /foo known 1 sprint
true
onyx:0> envdict /foo get 1 sprint
`foo'
onyx:0> /foo unsetenv
onyx:0> envdict /foo known 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:version}
\index{version@\onyxop{}{version}{}}
\item[{\onyxop{--}{version}{string}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[string: ]
			A string that contains the version name.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get the version string.  The string returned is a reference to
		the original version string.
	\item[Example(s): ]\begin{verbatim}

onyx:0> version pstack
`1.0.0'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:wait}
\index{wait@\onyxop{}{wait}{}}
\item[{\onyxop{condition mutex}{wait}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[condition: ]
			A condition object.
		\item[mutex: ]
			A mutex object that this thread currently owns.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait on \oparg{condition}.  \oparg{mutex} is atomically released
		when the current thread blocks, then acquired again before the
		current thread runs again.  Using a mutex that the current
		thread does not own will result in undefined behavior (likely
		crash).
	\item[Example(s): ]\begin{verbatim}

onyx:0> condition mutex dup lock ostack
onyx:3> {dup lock exch signal unlock}
onyx:4> thread 3 1 roll
onyx:3> dup 3 1 roll
onyx:4> wait unlock join
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:waitpid}
\index{waitpid@\onyxop{}{waitpid}{}}
\item[{\onyxop{pid}{waitpid}{status}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[pid: ]
			Process identifier.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[status: ]
			Exit code of terminated process.  A negative value
			indicates that the process was terminated by a signal
			(use the \htmlref{\onyxop{}{neg}{}}{systemdict:neg}
			operator to get the signal number), and a non-negative
			value is the exit code of a program that terminated
			normally.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Wait for the process with process ID \oparg{pid} to exit.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {fork dup 0 eq
        {pop `Child\n' print flush}
        {`Parent\n' print flush waitpid}
        ifelse} eval
Parent
Child
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:where}
\index{where@\onyxop{}{where}{}}
\item[{\onyxop{key}{where}{false}}: ]
\item[{\onyxop{key}{where}{dict true}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[key: ]
			A key to search for in dstack.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The topmost dictionary in dstack that contains a
			definition for \oparg{key}.
		\item[false/true: ]
			If false, no definition of \oparg{key} was found in
			dstack.  Otherwise \oparg{dict} is the topmost
			dictionary in dstack that contains a definition for
			\oparg{key}.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Get the topmost dictionary in dstack that defines \oparg{key}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> /foo where pstack clear
false
onyx:0> /threaddict where pstack clear
true
</threaddict -dict- /userdict -dict- /currenterror -dict- /errordict -dict-
/resume --stop-->
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:write}
\index{write@\onyxop{}{write}{}}
\item[{\onyxop{file integer/string}{write}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[file: ]
			A file object.
		\item[integer: ]
			An integer that represents an ascii character value.
		\item[string: ]
			A string object.
		\end{description}
	\item[Output(s): ] None.
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{ioerror}{ioerror}.]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Write \oparg{integer} or \oparg{string} to \oparg{file}.
	\item[Example(s): ]\begin{verbatim}

onyx:0> `/tmp/foo' `w+' open
onyx:1> dup `Hello\n' write
onyx:1> dup 0 seek
onyx:1> dup readline 1 sprint 1 sprint
false
`Hello'
onyx:1>
		\end{verbatim}
	\end{description}
\label{systemdict:xcheck}
\index{xcheck@\onyxop{}{xcheck}{}}
\item[{\onyxop{object}{xcheck}{boolean}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[object: ]
			An object.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[boolean: ]
			True if \oparg{object} has the executable or evaluatable
			attribute, false otherwise.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\end{description}
	\item[Description: ]
		Check \oparg{object} for executable or evaluatable attribute.
	\item[Example(s): ]\begin{verbatim}

onyx:0> {1 2 3} xcheck 1 sprint
true
onyx:0> [1 2 3] xcheck 1 sprint
false
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:xor}
\index{xor@\onyxop{}{xor}{}}
\item[{\onyxop{a b}{xor}{r}}: ]
	\begin{description}\item[]
	\item[Input(s): ]
		\begin{description}\item[]
		\item[a: ]
			An integer or boolean.
		\item[b: ]
			The same type as \oparg{a}.
		\end{description}
	\item[Output(s): ]
		\begin{description}\item[]
		\item[r: ]
			If \oparg{a} and \oparg{b} are integers, their bitwise
			exclusive or, otherwise their logical exclusive or.
		\end{description}
	\item[Errors(s): ]
		\begin{description}\item[]
		\item[\htmlref{stackunderflow}{stackunderflow}.]
		\item[\htmlref{typecheck}{typecheck}.]
		\end{description}
	\item[Description: ]
		Return the bitwise exclusive or of two integers, or the logical
		exclusive or of two booleans.
	\item[Example(s): ]\begin{verbatim}

onyx:0> true false xor 1 sprint
true
onyx:0> true true xor 1 sprint
false
onyx:0> 5 3 xor 1 sprint
6
onyx:0>
		\end{verbatim}
	\end{description}
\label{systemdict:yield}
\index{yield@\onyxop{}{yield}{}}
\item[{\onyxop{--}{yield}{--}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ] None.
	\item[Errors(s): ] None.
	\item[Description: ]
		Vuluntarily yield the processor, so that another thread or
		process may be run.
	\item[Example(s): ]\begin{verbatim}

onyx:0> 0 100000 {1 add yield} repeat 1 sprint
100000
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{threaddict}
\label{sec:threaddict}

Each thread has its own threaddict, which is not shared with any other threads.
threaddict is meant to be used for thread-specific definitions that would
otherwise go in systemdict.

\begin{longtable}{\optableformat{3}}
\caption[threaddict summary]{threaddict summary}
\\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Input(s) & Op/Proc/Var & Output(s) & Description \\
\hline \endhead
\multicolumn{4}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
-- & {\bf \htmlref{threaddict}{threaddict:threaddict}} & dict & Get
threaddict. \\
\hline
-- & {\bf \htmlref{userdict}{threaddict:userdict}} & dict & Get userdict. \\
\hline
-- & {\bf \htmlref{currenterror}{threaddict:currenterror}} & dict & Get
currenterror. \\
\hline
-- & {\bf \htmlref{errordict}{threaddict:errordict}} & dict & Get errordict. \\
\end{longtable}

\begin{description}
\label{threaddict:currenterror}
\index{currenterror@\onyxop{}{currenterror}{}}
\item[{\onyxop{--}{currenterror}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The currenterror dictionary.  See
			Section~\ref{sec:currenterror} for details on
			currenterror.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get currenterror.
	\item[Example(s): ]\begin{verbatim}

onyx:0> currenterror 0 sprint
-dict-
onyx:0>
	\end{verbatim}
	\end{description}
\label{threaddict:errordict}
\index{errordict@\onyxop{}{errordict}{}}
\item[{\onyxop{--}{errordict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The errordict dictionary.  See
			Section~\ref{sec:errordict} for details on errordict.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get errordict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> errordict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{threaddict:threaddict}
\index{threaddict@\onyxop{}{threaddict}{}}
\item[{\onyxop{--}{threaddict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The threaddict dictionary.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get threaddict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> threaddict 0 sprint
-dict-
onyx:0>
		\end{verbatim}
	\end{description}
\label{threaddict:userdict}
\index{userdict@\onyxop{}{userdict}{}}
\item[{\onyxop{--}{userdict}{dict}}: ]
	\begin{description}\item[]
	\item[Input(s): ] None.
	\item[Output(s): ]
		\begin{description}\item[]
		\item[dict: ]
			The userdict dictionary.  See
			Section~\ref{sec:userdict} for details on userdict.
		\end{description}
	\item[Errors(s): ] None.
	\item[Description: ]
		Get userdict.
	\item[Example(s): ]\begin{verbatim}

onyx:0> userdict 1 sprint
<>
onyx:0>
		\end{verbatim}
	\end{description}
\end{description}

\subsection{userdict}
\label{sec:userdict}

Each thread has its own userdict, which is not shared with any other threads.
userdict is meant to be used for general storage of definitions that do not need
to be shared among threads.  userdict starts out empty when a thread is
created.

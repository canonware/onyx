%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx examples portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Examples}
\label{onyxex}

This chapter uses a number of example programs in order to demonstrate how Onyx
can be used in constructing actual applications.  Onyx was primarily designed as
an embeddable language, but it is quite possible to implement programs purely in
Onyx.  Therefore, the example programs demonstrate the following idioms for Onyx
use:

\begin{description}
\item[Pure Onyx: ] Programs that are implemented using nothing but the base
  functionality of \htmlref{Onyx}{onyxlang}, via the stand-alone
  \htmlref{onyx}{onyxprog} interpreter.
\item[Pseudo-pure Onyx: ] The base functionality of Onyx can be extended with
  dynamically loadable modules.  As with pure Onyx, programs are written
  entirely in Onyx, and are executed by the stand-alone onyx interpreter, but
  modules are loaded and utilized.
\item[Embedded Onyx: ] The Onyx interpreter is embedded directly into a program,
  and the \htmlref{libonyx}{onyxlib} C library API is utilized in order to
  integrate the interpreter and implement Onyx language extensions that are
  specific to the application.
\end{description}

All of the examples in this chapter are included in their entirety as part of
the onyx source distribution, in the {\tt examples} subdirectory.  They are
integrated into the onyx build system and can be rebuilt via the {\tt examples}
target of the build system.

Pure and pseudo-pure programs can be executed by the \htmlref{onyx}{onyxprog}
program either via {\tt \#!} magic, or by invoking the onyx program directly.
Typically, onyx is installed as {\tt /usr/local/bin/onyx}, so the first lines of
an Onyx program normally look like:

\begin{verbatim}
#!/usr/local/bin/onyx
!#
\end{verbatim}

The {\tt \#!} characters indicate to the operating system that {\tt
/usr/local/bin/onyx} should be invoked.  See the execve(2) manual page for
details on how this works.  From Onyx's perspective, \htmlref{{\tt
\#!}}{systemdict:sym_hash_bang} pushes a mark object onto the operand stack, the
path components create literal name objects ({\tt /usr}, {\tt /local}, {\tt
/bin}, and {\tt /onyx}), and \htmlref{{\tt !\#}}{systemdict:sym_bang_hash} pops
everything off the operand stack down to and including the topmost mark object,
which was created by {\tt \#!}.

The examples in this chapter do not show the {\tt \#!} magic.  The actual
example programs in the source tree do include it, though they specify the path
to an onyx interpreter that is in the source tree, so that onyx need not be
installed in order to run the examples.

\section{Hello world! (hello.nx)}

Any self-respecting language tutorial begins with a ``Hello world!'' program.
Here it is for Onyx:

\begin{verbatim}
`Hello world!\n' print
\end{verbatim}

This program creates a string on the operand stack, then passes it to
\htmlref{{\tt print}}{systemdict:print}.  It doesn't get much simpler than this.
Still, there is something important to be learned from what is {\em not} in this
program.  Under normal circumstances, the \htmlref{{\tt
stdout}}{systemdict:stdout} file object is buffered, so that text that is
printed may not show up immediately unless \htmlref{{\tt
flush}}{systemdict:flush} is called.  Since {\tt flush} is not called, how does
the printed text get flushed?  The answer is that during the onyx interpreter
shutdown, the garbage collector runs one last time, and all objects are
collected.  As a side effect of file object collection, buffered data are
flushed.

\section{Recursive directory listing (find.nx)}

\section{Interactive system monitor}

\section{Native ``database''}

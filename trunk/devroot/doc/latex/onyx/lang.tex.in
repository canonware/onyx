%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% Onyx reference portion of Onyx Manual.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{Onyx Language Reference}
\label{onyxlang}

Onyx is a stack-based, threaded, interpreted language.  Its closest relative is
Adobe PostScript$_{TM}$, followed by Forth.  Experienced PostScript programmers
should find most aspects of Onyx familiar, but there are significant differences
that will prevent a knowledgeable PostScript programmer from programming in Onyx
without first skimming this chapter.  This chapter does not assume specific
knowledge of other programming languages, so stands as a definitive reference
for Onyx.

Onyx is different from most languages in that it is not compiled, but rather
consumed.  For example, there are mechanisms for creating the equivalent of
named procedures that can be called at a later time, but behind the scenes, the
code is actually being interpreted as it is scanned in such a way that an
executable object is created.  As such, Onyx is not suited for compilation,
native or byte code.  However, the language syntax is very simple and the
scanner/parser is extremely fast.  There is also an operator called
\htmlref{\onyxop{}{bind}{}}{systemdict:bind} that optimizes interpreted code
execution to approximately the same performance level as would be expected of a
byte code interpreter.

Onyx is implemented as a C library that can be embedded in other programs.
Mechanisms are provided for extending the set of operators available.  This
manual only documents the base language; see application-specific documentation
for any language extensions.

Following is a list of basic language features that are discussed in more detail
later in this chapter:

\begin{itemize}
\item{Stack-based.  There are no named variables as in procedural languages.
Operations are done using various stacks, so Onyx operations are coded in
postfix order.}
\item{Threaded.  Onyx's threading uses the native POSIX threads implementation
of the operating system (or GNU pth, if so configured).}
\item{Interpreted.  Onyx code is never compiled, but is instead interpreted as
it is encountered.}
\item{Garbage-collected.  There is no need to manually track memory allocation,
since the interpreter has an integrated automatic mark and sweep garbage
collector.}
\end{itemize}

\section{Objects}
\label{sec:onyx_objects}

An Onyx object has three aspects: type, attribute, and value.

Objects fall into two categories according to type: simple and composite.  A
simple object takes up no memory of its own; it uses space within a stack,
array, or dictionary.  A composite object requires space of its own in addition
to the space taken up in stacks, arrays, or dictionaries to refer to the
composite object.  See Table~\ref{simple-composite} for object type
classifications.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Simple	& Composite	\\
\hline \hline
boolean	& array		\\
fino	& class		\\
integer	& condition	\\
mark	& dict		\\
name	& file		\\
null	& handle	\\
operator & instance	\\
pmark	& mutex		\\
real	& regex	\\
	& regsub	\\
	& stack		\\
	& string	\\
	& thread	\\
\hline
\end{tabular}
\end{center}
\caption{\label{simple-composite}
Simple and composite types}
\end{table}

There can be multiple references that refer to the same memory backing composite
objects.  In most cases, composite objects that refer to the same memory are
indistinguishable, but for arrays and strings, composite objects may only be
able to access a subset of the total memory backing them.  This behavior is
described in detail later.

All objects have a literal, executable, evaluable, or callable attribute
associated with them.  Composite objects each have their own attribute, even for
composite objects that share the same backing memory.  Objects are
``interpreted'' when they are encountered directly by the interpreter.  Objects
can also be ``evaluated''.  One of two actions is taken when an object is
interpreted or evaluated:

\begin{itemize}
\item{The object may be treated as code (executed).  When executed, an object is
pushed onto the execution stack and executed.}
\item{The object may be treated as data.  A data object is push onto the operand
stack.}
\end{itemize}

Table~\ref{interp-act} enumerates under what circumstances object interpretation
results in execution.  Table~\ref{eval-act} enumerates under what circumstances
object evaluation results in execution.  Note that executable arrays are the
only objects that behave differently when interpreted versus evaluated.

In practice, attributes are only useful for types that can be executed.
Attributes are not considered in equality test operations.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
Type		& \multicolumn{4}{|c|}{Attribute}	\\
\cline{2-5}
		& literal & executable & evaluable & callable \\
\hline \hline
array		& data	& data	& code	& code		\\
\hline
boolean		& data	& data	& data	& data		\\
\hline
class		& data	& data	& data	& data		\\
\hline
condition	& data	& data	& data	& data		\\
\hline
dict		& data	& data	& data	& data		\\
\hline
file		& data	& code	& code	& code		\\
\hline
fino		& data	& data	& data	& data		\\
\hline
handle		& data	& code	& code	& code		\\
\hline
instance	& data	& data	& data	& data		\\
\hline
integer		& data	& data	& data	& data		\\
\hline
mark		& data	& data	& data	& data		\\
\hline
mutex		& data	& data	& data	& data		\\
\hline
name		& data	& code	& code	& code		\\
\hline
null		& data	& code	& code	& code		\\
\hline
operator	& data	& code	& code	& code		\\
\hline
pmark		& data	& data	& data	& data		\\
\hline
real		& data	& data	& data	& data		\\
\hline
regex		& data	& data	& data	& data		\\
\hline
regsub		& data	& data	& data	& data		\\
\hline
stack		& data	& data	& data	& data		\\
\hline
string		& data	& code	& code	& code		\\
\hline
thread		& data	& data	& data	& data		\\
\hline
\end{tabular}
\end{center}
\caption{\label{interp-act}
Interpretation of objects by type and attribute}
\end{table}

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
Type		& \multicolumn{4}{|c|}{Attribute}	\\
\cline{2-5}
		& literal & executable & evaluable & callable \\
\hline \hline
array		& data	& code	& code	& code		\\
\hline
boolean		& data	& data	& data	& data		\\
\hline
class		& data	& data	& data	& data		\\
\hline
condition	& data	& data	& data	& data		\\
\hline
dict		& data	& data	& data	& data		\\
\hline
file		& data	& code	& code	& code		\\
\hline
fino		& data	& data	& data	& data		\\
\hline
handle		& data	& code	& code	& code		\\
\hline
instance	& data	& data	& data	& data		\\
\hline
integer		& data	& data	& data	& data		\\
\hline
mark		& data	& data	& data	& data		\\
\hline
mutex		& data	& data	& data	& data		\\
\hline
name		& data	& code	& code	& code		\\
\hline
null		& data	& code	& code	& code		\\
\hline
operator	& data	& code	& code	& code		\\
\hline
pmark		& data	& data	& data	& data		\\
\hline
real		& data	& data	& data	& data		\\
\hline
regex		& data	& data	& data	& data		\\
\hline
regsub		& data	& data	& data	& data		\\
\hline
stack		& data	& data	& data	& data		\\
\hline
string		& data	& code	& code	& code		\\
\hline
thread		& data	& data	& data	& data		\\
\hline
\end{tabular}
\end{center}
\caption{\label{eval-act}
Evaluation of objects by type and attribute}
\end{table}

\begin{description}

\item[array: ] An array is an ordered sequence of objects of any type.  The
sequence of objects contained in an array is indexed starting at 0.  References
to existing arrays may be constructed such that a contiguous subsequence is
visible.  The following code creates such an array:

\begin{verbatim}
[0 1 2 3 4]
1 3 getinterval
\end{verbatim}

After the code executes, the array left on the operand stack looks like:

\begin{verbatim}
[1 2 3]
\end{verbatim}

Executable arrays are in effect procedures.  When an array is executed, its
elements are sequentially interpreted.

\item[boolean: ] A boolean can have two values: true or false.

\item[class: ] A class is a class, in the object-oriented sense of the word.
Class objects provide explicit object-oriented programming support.  Classes
allow single inheritance, and provide dynamic lookup/dispatch capabilities.

\item[condition: ] A condition is used for thread synchronization.  The standard
operations on a condition are to wait and to signal.

\item[dict: ] A dict (short for dictionary) is a collection of key/value pairs.
Other names for dictionaries include ``associative array'' and ``hash''.  A key
can be of any type, though in most cases, keys are of type name.  A value can
also be of any type.

\item[file: ] A file is a handle to an ordered sequence of bytes with a current
position.  Read and write permissions are set when a file object is created.

When an executable file is executed, it is used as a source of Onyx code.  Data
are sequentially read from the file and interpreted until the end of the file is
reached.

\item[fino: ] A fino (first in, never out) is used as a stack marker when
constructing stacks.

\item[handle: ] The handle type is not used by the core Onyx language.  It can
be used by applications that extend the interpreter as a container object.
Handles can be executed, but the results are application dependent.

Each handle has a tag associated with it that can used by C extension code as a
form of type checking.  By default, the tag is a null object.  In most cases, an
application that extends the interpreter using handle objects will set handle
tags to be name objects.

\item[instance: ] An instance is an instance of a class, in the object-oriented
sense of the word.  Instances primarily depend on classes for their
functionality, but they also have per-instance data storage.

\item[integer: ] An integer is a signed integer in the range $-2^{63}$ to
$2^{63} - 1$.

\item[mark: ] A mark is used as a stack marker for various stack operations.

\item[mutex: ] A mutex is a mutual exclusion lock.  Mutexes cannot be acquired
recursively, and the application must take care to unlock mutexes before
allowing them to be garbage collected (whether during normal program execution
or at program termination).

\item[name: ] A name is a key that uniquely identifies a sequence of characters.
Two name objects that correspond to the same sequence of characters can be
compared for equality with the same approximate cost as comparing two integers
for equality.  Names are typically used as keys in dictionaries.

When an executable name is executed, the topmost value in the dictionary stack
associated with the name is evaluated.

When a callable name is executed, the name is dynamically looked up as a method
name in the context of the instance which is on the top of the operand stack,
and the associated value is evaluated.

\item[null: ] A null has no significance other than its existence.  When an
executable null is executed, it does nothing.  Executable nulls can be useful as
place holders that can later be replaced with useful code, or for replacing
obsolete code so that the code is no longer executed.

\item[operator: ] An operator is an operation that is built in to the
interpreter.  Operators can be executed.

\item[pmark: ] A pmark is used as a stack marker when creating procedures in
deferred execution mode (i.e. procedures that use the \{\} syntax).  The
application will only encounter pmarks in error conditions, and there is never a
reason for an application to explicitly create a pmark.

\item[real: ] A real is a double precision (64 bit) floating point number.

\item[regex: ] A regex encapsulates a regular expression and associated flags,
which can be used to find substring matches within an input string.

\item[regsub: ] A regsub encapsulates a regular expression, substitution
template, and associated flags, which can be used to do substring substitutions
matches and create an output string from input string.

\item[stack: ] A stack provides LIFO (last in, first out) access to objects that
it contains, as well as some more advanced access methods.  An application can
create, then manipulate stacks in much the same way that the operand stack can
be manipulated.

\item[string: ] A string is an ordered sequence of 8 bit characters.  The bytes
contained in an string are indexed starting at 0.  References to existing
strings may be constructed such that a contiguous subsequence is visible.  The
following code creates such a string:

\begin{verbatim}
`abcde'
1 3 getinterval
\end{verbatim}

After the code executes, the string left on the operand stack looks like:

\begin{verbatim}
`bcd'
\end{verbatim}

When an executable string is executed, its contents are used as a source of Onyx
code.

\item[thread: ] A thread object serves as a handle for operations such as
detaching and joining.

\end{description}

\section{Syntax}
\label{sec:onyx_syntax}
Onyx's syntax is very simple in comparison to most languages.  The scanner and
parser are implemented as a human-understandable finite state machine (nested C
switch statements with a couple of auxiliary variables), which should give the
reader an idea of the simplicity of the language syntax.

CRNL (carriage return, newline) pairs are in all important cases converted to
newlines during scanning.

The characters \#, !, :, \$, {\twid}, {\lb}, {\rb}, \{, \}, (, ), `, ', {\lt},
and {\gt} are special.  In most cases, any of the special characters and
whitespace (space, tab, newline, formfeed, null) terminate any preceding token.
All other characters including non-printing characters are considered regular
characters.

A comment starts with a \# character outside of a string context and extends to
the next newline or formfeed.

Procedures are actually executable arrays, but Onyx provides special syntax for
declaring procedures.  Procedures are delimited by \{ and \}, and can be
nested.  Normally, the interpreter executes code as it is scanned, but inside of
procedure declarations, execution is deferred.  Instead of executing a procedure
body as it is encountered, the tokens of the procedure body are pushed onto the
operand stack until the closing \} is encountered, at which time an executable
array is constructed from the tokens in the procedure body and pushed onto the
operand stack.

A partial grammar specification, using BNF notation (where convenient) is as
follows:

\begin{description}
\item[{\lt}program{\gt} ::= ] {\lt}statement{\gt}

\item[{\lt}statement{\gt} ::= ] {\lt}procedure{\gt} {\lt}statement{\gt} {\pipe}
{\lt}object{\gt} {\lt}statement{\gt} {\pipe} $\epsilon$

\item[{\lt}procedure{\gt} ::= ] \{{\lt}statement{\gt}\}

\item[{\lt}object{\gt} ::= ] {\lt}integer{\gt} {\pipe} {\lt}real{\gt} {\pipe}
{\lt}name{\gt} {\pipe} {\lt}string{\gt}

\item[{\lt}integer{\gt} ::= ] {\lt}dec\_integer{\gt} {\pipe}
{\lt}radix\_integer{\gt}

\item[{\lt}real{\gt} ::= ] {\lt}dec\_real{\gt} {\pipe} {\lt}exp\_real{\gt}

\item[{\lt}name{\gt} : ] Any token that cannot be interpreted as a number or a
string is interpreted as an executable name.  There are five syntaxes for names:
executable, evaluable, callable, literal, and immediately evaluated.  Executable
and evaluable names are looked up in the dictionary stack and executed (unless
execution is deferred).  Evaluable names behave the same as executable names,
except when being processed by the \htmlref{\onyxop{}{bind}{}}{systemdict:bind}
operator.  Callable names are looked up in the context of the topmost object on
the operand stack, which must be an instance.  Literal names are simply pushed
onto the operand stack.  Immediately evaluated names are replaced by their
values as defined in the dictionary stack, even if execution is deferred.
Examples include:
\begin{verbatim}
foo     # executable
4noth3r # executable
!bar    # evaluable
:method # callable
$biz    # literal
~baz    # immediately evaluated
\end{verbatim}

If the result of an immediately evaluated name is an executable array, the
evaluable attribute is set for the array so that when the array is
interpreted, it is executed.  This allows immediate evaluation to be
indiscriminately used without concern for whether the result is an executable
array or, say, an executable operator.

\item[{\lt}string{\gt} ::= ] `'-delimited string.  Ticks may
be embedded in the string without escaping them, as long as the unescaped ticks
are balanced.  The following sequences have special meaning when escaped by a
{\bs} character:
	\begin{description}
	\item[` ] ` character.
	\item[' ] ' character.
	\item[{\bs} ] {\bs} character.
	\item[0 ] Nul.
	\item[n ] Newline.
	\item[r ] Carriage return.
	\item[t ] Tab.
	\item[b ] Backspace.
	\item[f ] Formfeed.
	\item[a ] Alarm.
	\item[e ] Escape.
	\item[x{\lb}0-9a-fA-F{\rb}{\lb}0-9a-fA-F{\rb} ] Hex encoding for a byte.
	\item[c{\lb}a-zA-Z{\rb} ] Control character.
	\item[{\bs}n (newline) ] Ignore.
	\item[{\bs}r{\bs}n (carriage return, newline) ] Ignore.
	\end{description}

{\bs} has no special meaning unless followed by a character in the above list.

Examples include:
\begin{verbatim}
`'
`A string.'
`An embedded \n newline.'
`Another embedded 
newline.'
`An ignored \
newline.'
`Balanced ` and ' are allowed.'
`Manually escaped \` tick.'
`Manually escaped \` tick and `balanced unescaped ticks'.'
`An actual \\ backslash.'
`Another actual \ backslash.'
\end{verbatim}

\item[{\lt}dec\_integer{\gt} : ] Signed decimal integer in the range $-2^{63}$
to $2^{63} - 1$.  The sign is optional.  Examples include:
\begin{verbatim}
0
42
-365
+17
\end{verbatim}

\item[{\lt}radix\_integer{\gt} : ] Signed integer with explicit base between 2
and 36, inclusive, in the range $-2^{63}$ to $2^{63} - 1$.  Integer digits are
composed of decimal numbers and lower or upper case letters.  The sign is
optional.  Examples include:
\begin{verbatim}
2@101
16@ff
16@Ff
16@FF
-10@42
10@42
+10@42
9@18
35@7r3x
35@7R3x
\end{verbatim}

\item[{\lt}dec\_real{\gt} : ] Double precision floating point number in decimal
notation.  At least one decimal digit and a decimal point are required.
Examples include:
\begin{verbatim}
0.
.0
3.
.141
3.141
42.75
+3.50
-5.0
\end{verbatim}

\item[{\lt}exp\_real{\gt} : ] Floating point number in exponential notation.
The format is the same as for {\lt}dec\_real{\gt}, except that an exponent is
appended.  The exponent is composed of an ``e'' or ``E'', an optional sign, and
a base 10 integer that is limited by the precision of the floating point format
(approximately $-308$ to $307$).  Examples include:
\begin{verbatim}
6.022e23
60.22e22
6.022e+23
1.661e-24
1.661E-24
\end{verbatim}

\end{description}

Arrays do not have explicit syntactic support, but the [ and ] operators support
their construction.  Examples of array construction include:
\begin{verbatim}
[]
[0 `A string' `Another string.' true]
[5
42
false]
\end{verbatim}

Dictionaries do not have explicit syntactic support, but the {\lt} and
{\gt} operators support their construction.  Examples of dictionary
construction include:
\begin{verbatim}
<>
<$answer 42 $question `Who knows' $translate {babelfish} >
\end{verbatim}

Stacks do not have explicit syntactic support, but the ( and ) operators support
their construction.  Examples of stack contstruction include:
\begin{verbatim}
()
(1 2 mark `a')
\end{verbatim}

\section{Stacks}

Stacks in Onyx are the core data structure that programs act on.  Stacks store
objects in a last in, first out (LIFO) order.  Onyx includes a number of
operators that manipulate stacks.

Each Onyx thread has four program-visible stacks associated with it:
\begin{description}
\item[Operand stack (ostack): ] Most direct object manipulations are done using
	the operand stack.  Operators use the operand stack for inputs and
	outputs, and code generally uses the operand stack for a place to store
	objects as they are being manipulated.
\item[Dictionary stack (dstack): ] The dictionary stack is used for looking up
	names.  Each thread starts with with four dictionaries on its dictionary
	stack, which are, from top to bottom:
	\begin{itemize}
		\item{userdict}
		\item{globaldict}
		\item{systemdict}
		\item{threaddict}
	\end{itemize}
	The dictionary stack is normally manipulated via the
	\htmlref{\onyxop{}{begin}{}}{systemdict:begin} and
	\htmlref{\onyxop{}{end}{}}{systemdict:end} operators.  The initial
	dictionaries on the dictionary stack should not generally be removed,
	since doing so can cause interpreter crashes.
\item[Execution stack (estack): ] The interpreter uses the execution stack to
	store objects that are being executed.  The application generally does
	not need to explicitly manipulate the execution stack, but its contents
	are accessible, mainly for debugging purposes.
\item[Index stack (istack): ] The interpreter uses the index stack to store
	execution offsets for arrays that are being executed.  There is a one to
	one correspondence of the elements of the execution stack to the
	elements of the index stack, even though the elements of the index stack
	that do not correspond to arrays have no meaning.  The index stack does
	not affect execution, and exists purely to allow useful execution stack
	traces when errors occur.
\end{description}

The application can also create additional stacks and manipulate them in much
the same way as the operand stack can be manipulated.

\section{Standard I/O}
\label{sec:onyx_standard_io}

Onyx provides operators to access the standard I/O file objects:
\htmlref{\onyxop{}{stdin}{}}{systemdict:stdin},
\htmlref{\onyxop{}{stdout}{}}{systemdict:stdout}, and
\htmlref{\onyxop{}{stderr}{}}{systemdict:stderr}.  Under normal circumstances,
these operators are adequate for all standard I/O operations.  However, it may
be desirable to replace these files on a per-thread basis.  This can be
accomplished using \htmlref{\onyxop{}{setstdin}{}}{systemdict:setstdin},
\htmlref{\onyxop{}{setstdout}{}}{systemdict:setstdout}, and
\htmlref{\onyxop{}{setstderr}{}}{systemdict:setstderr}.  Furthermore, the file
objects that are inherited by new threads can be accessed and modified via
\htmlref{\onyxop{}{gstdin}{}}{systemdict:gstdin},
\htmlref{\onyxop{}{gstdout}{}}{systemdict:gstdout},
\htmlref{\onyxop{}{gstderr}{}}{systemdict:gstderr},
\htmlref{\onyxop{}{setgstdin}{}}{systemdict:setgstdin},
\htmlref{\onyxop{}{setgstdout}{}}{systemdict:setgstdout}, and
\htmlref{\onyxop{}{setgstderr}{}}{systemdict:setgstderr}.

\section{Interpreter recursion}

During typical Onyx interpreter initialization, the
\htmlref{\onyxop{}{start}{}}{systemdict:start} operator is executed, which in
turn executes a file object corresponding to stdin.  However, depending on how
the interpreter is invoked, the initial execution stack state may differ.

The interpreter can be recursively invoked.  For example, if the following code
is executed, the \htmlref{\onyxop{}{eval}{}}{systemdict:eval} operator
recursively invokes the interpreter to interpret the string.
\begin{verbatim}
`2 2 add' cvx eval
\end{verbatim}

The depth of the execution stack directly corresponds to the recursion depth of
the interpreter.  Execution stack depth is limited in order to catch unbounded
recursion.

Onyx converts tail calls in order to prevent unbounded execution stack growth
due to tail recursion.  For example, the following code does not cause the
execution stack to grow:

\begin{verbatim}
$foo {foo} def
foo
\end{verbatim}

The following code will result in an execution stack overflow:

\begin{verbatim}
$foo {foo `filler'} def
foo
\end{verbatim}

\section{Error handling}

The error handling mechanisms in Onyx are simple but flexible.  When an error
occurs, \htmlref{\onyxop{}{throw}{}}{systemdict:throw} is called.  An error can
have any name, but only the following error names are generated internally by
Onyx:
\begin{description}
\label{argcheck}
\index{argcheck}
\item[argcheck: ] Incorrect argument value.
\label{estackoverflow}
\index{estackoverflow}
\item[estackoverflow: ] Maximum interpreter recursion was exceeded.
\label{invalidaccess}
\index{invalidaccess}
\item[invalidaccess: ] Permission error.
\label{invalidexit}
\index{invalidexit}
\item[invalidexit: ] The \onyxop{}{exit}{} operator was called outside of any
loop.  This error is generated as a result of catching an exit, so the execution
state for where the error really happened is gone.
\label{invalidfileaccess}
\index{invalidfileaccess}
\item[invalidfileaccess: ] Insufficient file permissions.
\label{ioerror}
\index{ioerror}
\item[ioerror: ] I/O error (read(), write(), etc.).
\label{limitcheck}
\index{limitcheck}
\item[limitcheck: ] Value outside of legal range.
\label{neterror}
\index{neterror}
\item[neterror: ] Network error (refused connection, timeout, unreachable net,
etc.).
\label{rangecheck}
\index{rangecheck}
\item[rangecheck: ] Out of bounds string or array access, or out of bounds
value.
\label{regexerror}
\index{regexerror}
\item[regexerror: ] Regular expression syntax error.
\label{stackunderflow}
\index{stackunderflow}
\item[stackunderflow: ] Not enough objects on stack.
\label{syntaxerror}
\index{syntaxerror}
\item[syntaxerror: ] Scanner syntax error.
\label{typecheck}
\index{typecheck}
\item[typecheck: ] Incorrect argument type.
\label{undefined}
\index{undefined}
\item[undefined: ] Name not defined in any of the dictionaries on dstack, or in
the case of class method dispatch, name not defined in the class hierarchy.
\label{undefinedfilename}
\index{undefinedfilename}
\item[undefinedfilename: ] Bad filename.
\label{undefinedresult}
\index{undefinedresult}
\item[undefinedresult: ] Attempt to divide by 0.
\label{unmatchedfino}
\index{unmatchedfino}
\item[unmatchedfino: ] No fino on ostack.
\label{unmatchedmark}
\index{unmatchedmark}
\item[unmatchedmark: ] No mark on ostack.
\label{unregistered}
\index{unregistered}
\item[unregistered: ] Non-enumerated error.
\end{description}

The Onyx scanner handles syntax errors specially, in that it pushes an
executable string onto the operand stack that represents the code that caused
the syntax error and records the line and column numbers in currenterror before
invoking \htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

The Onyx scanner also handles immediate name evaluation errors specially, in
that it pushes the name that could not be evaluated onto ostack before invoking
\htmlref{\onyxop{}{throw}{}}{systemdict:throw}.

In addition to the \htmlref{\onyxop{}{throw}{}}{systemdict:throw} operator,
there are several other operators that exist specifically for the purpose of
error handling.  The \htmlref{\onyxop{}{start}{}}{systemdict:start} operator
silently catches any uncaught \htmlref{\onyxop{}{stop}{}}{systemdict:stop},
\htmlref{\onyxop{}{exit}{}}{systemdict:exit}, or
\htmlref{\onyxop{}{quit}{}}{systemdict:quit} calls.  The \onyxop{}{start}{}
operator is the first operator called by the Onyx interpreter during startup,
and it can also be used by applications to limit execution stack unwinding.  The
\htmlref{\onyxop{}{stopped}{}}{systemdict:stopped} operator is useful for
catching \htmlref{\onyxop{}{stop}{}}{systemdict:stop} calls, since it reports
whether a \onyxop{}{stop}{} call was caught, allowing conditional error
recovery.

\section{Threads}

Onyx supports multiple threads of execution by using the operating system's
native threading facilities.  Along with threads comes the need for methods of
synchronization between threads.

\subsection{Implicit synchronization}
\label{sec:onyx_implicit_synchronization}

Implicit synchronization is a mandatory language feature, since objects such as
\htmlref{globaldict}{systemdict:globaldict} are implicitly accessed by the
interpreter, which makes it impossible to require the user to explicitly handle
all synchronization.  Onyx provides optional implicit synchronization
capabilities for composite objects on an object by object basis.  Each thread
has a setting which can be accessed via
\htmlref{\onyxop{}{currentlocking}{}}{systemdict:currentlocking} (initially set
to false) and set via \htmlref{\onyxop{}{setlocking}{}}{systemdict:setlocking}.
If implicit locking is active, then new objects will be created such that simple
accesses are synchronized.

Implicit synchronization can be a source of deadlock, so care must be taken when
accessing implicitly locked objects.  For example, if two threads copy two
implicitly locked strings to the other string, deadlock can result.

\begin{verbatim}
# Initialization.
$A `aaaaaa'
$B `bbbbbb'

...

# In thread A:
A B copy

...

# In thread B:
B A copy
\end{verbatim}

The following are descriptions of the implicit locking semantics for each type
of composite object:
\begin{description}
\item[array: ] Array copying is protected.  Array element modifications are
protected, but element reads are not protected.
\item[class: ] No implicit locking is done for classes.
\item[condition: ] No implicit locking is done for conditions.
\item[dict: ] All dict operations are protected.
\item[file: ] All file operations are protected.  There are no potential
deadlocks due to implicit file locking.
\item[handle: ] No implicit locking is done for handles.
\item[instance: ] No implicit locking is done for instances.
\item[mutex: ] No implicit locking is done for mutexes.
\item[regex: ] No implicit locking is done for regexes.
\item[regsub: ] No implicit locking is done for regsubs.
\item[stack: ] All stack operations are protected.  There are no potential
deadlocks due to implicit stack locking.  However, there are races in stack
copying, such that the results of copying a stack that is concurrently being
modified are unpredictable.  In addition, removing an object that is being
concurrently accessed from a stack is unsafe.
\item[string: ] String copying is protected.  Character access is protected by
many operators, but string copying is the only potential cause of deadlock for
string access.
\item[thread: ]  Implicit locking is not done for thread operations, since other
synchronization is adequate to protect thread objects.
\end{description}

\subsection{Explicit synchronization}

Onyx includes a foundation of mutexes and condition variables, with which all
other synchronization primitives can be constructed.

\section{Memory management}
Onyx programs do not need to track memory allocations, since memory reclamation
is done implicitly via automatic garbage collection.  Onyx uses an atomic mark
and sweep garbage collector.

The atomic nature of garbage collection may sound worrisome with regard to
performance, but in fact there are tangible benefits and no significant negative
impacts for most applications.  Total throughput is improved, since minimal
locking is necessary.  Concurrent garbage collection would impose a significant
locking overhead.

On the down side, atomic garbage collection cannot make strong real-time
guarantees.  However, the garbage collector is very efficient, and for typical
applications, garbage collection delays are measured in microseconds up to tens
of milliseconds on current hardware as of the year 2000.  For interactive
applications, anything under about 100 milliseconds is undetectable by the user,
so under normal circumstances the user will not notice that garbage collection
is happening.

There are three parameters that can be used to control garbage collection:
\begin{enumerate}
\item{The garbage collector can be turned off for situations where many objects
are being created over a short period of time.}
\item{The garbage collector runs whenever a certain number of bytes of memory
have been allocated since the last collection.  This threshold can be changed or
disabled.}
\item{If no composite objects have been created for an extended period of time
(seconds), the garbage collector will run if any composite objects have been
allocated since the last collection.  This idle timeout period can be changed or
disabled.}
\end{enumerate}

There is one situation in which it is possible for garbage to never be
collected, despite the garbage collector being properly configured.  Suppose
that a program creates some objects, the garbage collector runs, then the
program enters a code path that clobbers object references, such that the
objects could be collected, but no new objects are allocated.  In such a
situation, neither the allocation inactivity timer (period), nor the object
allocation threshold will trigger a collection, and garbage will remain
uncollected.  In practice this situation is unlikely, and is not a significant
problem since the program size is not growing.

Garbage collection is controlled via the \htmlref{gcdict}{systemdict:gcdict}
dictionary, which is described in Section~\ref{sec:gcdict}.

\section{Regular expressions}
\label{sec:onyx_regular_expressions}

Regular expression support is provided by the PCRE library package, which is
open source software, written by Philip Hazel, and copyright by the University
of Cambridge, England.  PCRE stands for ``Perl-compatible regular
expressions''.  This manual only documents how Onyx interfaces with PCRE.  For
more information about how PCRE's regular expressions work, see the following:

\begin{itemize}
\item{The pcre(3) manual page.}
\item{The official PCRE website: \htmlurl{http://www.pcre.org/}.}
\item{The official PCRE download site:
\htmlurl{ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/}.}
\end{itemize}

For general information about Perl regular expressions, the following are
recommended:

\begin{itemize}
\item{Perl 5.6.1 regular expression documentation:
\htmlurl{http://www.perldoc.com/perl5.6.1/pod/perlre.html}.}
\item{\underline{Mastering Regular Expressions, 2nd Ed.}, by Jeffrey
E. F. Friedl.  ISBN 0-596-00289-0.}
\item{\underline{Perl 5 Pocket Reference, 3rd Ed.}, by Johan Vromans.  ISBN
0-596-00032-4.}
\item{\underline{Programming Perl, 3rd Ed.}, by Larry Wall, Tom Christiansen,
and Jon Orwant.  ISBN 0-596-00027-8.}
\end{itemize}

There are two special Onyx object types that support regular expressions: regex
and regsub.  Objects of these types are created via the
\htmlref{\onyxop{}{regex}{}}{systemdict:regex} and
\htmlref{\onyxop{}{regsub}{}}{systemdict:regsub} operators, respectively.  The
\htmlref{\onyxop{}{match}{}}{systemdict:match} operator applies a regular
expression to an input string, the
\htmlref{\onyxop{}{submatch}{}}{systemdict:submatch} operator returns a
matched substring of the input string, and the
\htmlref{\onyxop{}{offset}{}}{systemdict:offset} operator returns the offset
of a substring match relative to the beginning of the input string.  The
\htmlref{\onyxop{}{split}{}}{systemdict:split} operator creates an array of
substrings that are separated by strings that match a regular expression.  The
\htmlref{\onyxop{}{subst}{}}{systemdict:subst} operator finds regular expression
matches within an input string and applies a substitution template to the
matches, thereby creating an output string.  See Section~\ref{sec:systemdict}
for detailed documentation on the above-mentioned operators.

Regular expressions are written as strings in Onyx, so all of the standard
special sequences within strings are interpreted directly by the Onyx scanner.
Note that the {\bs} character is only special within strings if it is followed
by a special sequence.  This allows regular expressions to seamlessly extend the
set of special sequences within strings while maintaining a reasonably
consistent syntax.

The following sequences have special meaning within strings that specify
substitution templates:

\begin{longtable}{\rxtableformat{5.50}}
\caption{Substitution template special characters} \\
\hline
Sequence & Description \\
\hline \hline
%begin{latexonly}
\endfirsthead
\caption[]{\emph{continued}} \\
\hline
Sequence & Description \\
\hline \hline \endhead
\multicolumn{2}{r}{\emph{Continued on next page...}} \endfoot
\hline \endlastfoot
%end{latexonly}
{\tt {\bs}1..{\bs}9} & Refer to captured expressions 1 through 9. \\
\end{longtable}

\section{Dictionary reference}

All operators built in to Onyx have corresponding names that are composed
entirely of lower case letters and numbers (with the exception of
syntax-supporting operators like {\lb}).  In order to avoid any possibility of
namespace collisions with names defined by current and future versions of Onyx,
use at least one character that is not a lower case letter or a number in names
(for example, capital letters, underscore, etc.).  In practice, namespace
collisions usually aren't a problem, even if they happen, since the only effect
is that the program-defined definition shadows the built in definition during
name lookups.

\input{@abs_srcroot@/doc/latex/onyx/lang_dict_currenterror}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_envdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_errordict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_gcdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_globaldict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_onyxdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_outputsdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_sprintsdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_systemdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_threaddict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_threadsdict}
\input{@abs_srcroot@/doc/latex/onyx/lang_dict_userdict}

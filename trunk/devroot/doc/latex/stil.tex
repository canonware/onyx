%-*-mode:latex-*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: <Version>
%
% stil portion of Canonware Software Manual.
%              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearemptydoublepage
\chapter{stil}
\label{stillang}

Stil stands for ``stack-based threaded interpreted language''.  Its closest
relative is Adobe PostScript, followed by Forth.  Experienced PostScript
programmers should find most aspects of stil familiar, but there are several
important differences.  This manual does not assume specific knowledge of other
programming languages, so stands as a definitive reference manual for stil.

Stil is different from most languages in that it is not compiled, but rather
consumed.  For example, there are mechanisms for creating the equivalent of
named procedures that can be called at a later time, but behind the scenes, the
code is actually being interpreted as it is scanned in such a way that an
executable object is created.  As such, stil is not suited for compilation,
native or byte code.  However, the language syntax is very simple and the
scanner/parser is extremely fast.

Stil is implemented as a C library that can be embedded in other programs.
Mechanisms are provided for extending the set of operators available.  This
manual only documents the base language; see application documentation for any
language extensions.

Following is a laundry list of language features that are discussed in more
detail later in this manual:

\begin{itemize}
\item{Stack-based.  There are no named variables as in procedural languages.
Operations are done using various stacks, so stil operations are coded in
postfix notation.}
\item{Threaded.  Stil's threading uses the native POSIX threads implementation
of the operating system.}
\item{Interpreted.  Stil code is never compiled, but is rather interpreted as it
is encountered.}
\item{Garbage-collected.  There is no need to manually track memory allocation,
since the interpreter has an integrated automatic mark and sweep garbage
collector.}
\item{Statically typed.  A pre-defined set of types are available in stil, and
no mechanism for extending the type system is provided.}
\end{itemize}

\section{Objects}

A stil object has three aspects: type, attribute, and value.

Objects fall into two categories according to type: simple and composite.  A
simple object takes up no memory of its own; it uses space within a stack,
array, or dictionary.  A composite object requires space of its own in addition
to the space taken up in stacks, arrays, or dictionaries to refer to the
composite object.  See Table~\ref{simple-composite} for object type
classifications.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Simple	& Composite	\\
\hline \hline
boolean	& array		\\
integer	& condition	\\
mark	& dict		\\
name	& file		\\
null	& hook		\\
operator & mutex	\\
	& string	\\
\hline
\end{tabular}
\label{simple-composite}
\end{center}
\caption{Simple and composite types}
\end{table}

There can be multiple references that refer to the same memory backing composite
objects.  In most cases, composite objects that refer to the same memory are
indistinguishable, but for arrays and strings, composite objects may only be
able to access a subset of the total memory backing them.  This behavior is
described in detail later.

All objects have a literal or executable attribute associated with them.
Composite objects each have their own attribute, even for composite objects that
share the same backing memory.  An object is either literal or executable.  When
an executable array, file, hook, name, operator, or string is encountered by the
interpreter, it is pushed onto the execution stack and executed; otherwise the
object is pushed onto the operand stack.  All other object types, regardless of
literal/executable attribute, are pushed onto the operand stack.

In practice, attributes are only useful for types that can be executed.
Attributes are not considered in equality test operations.

\begin{description}

\item[array: ] An array is an ordered sequence of objects of any type.  The
sequence of objects contained in an array is indexed starting at 0.  References
to existing arrays may be constructed such that a contiguous subsequence is
visible.  The following code creates such an array:

\begin{verbatim}
[0 1 2 3 4]
1 3 getinterval
\end{verbatim}

After the code executes, the array left on the stack looks like:

\begin{verbatim}
[1 2 3]
\end{verbatim}

\item[boolean: ] A boolean can have two values: true or false.

\item[condition: ] A condition is used for thread synchronization.  The standard
operations on a condition are to wait and to signal.

\item[dict: ] A dict (short for dictionary) is a collection of key/value pairs.
Other names for dictionaries include ``associative array'' and ``hash''.  A key
can be of any type, though in most cases, keys are of type name.  A value can
also be of any type.

\item[file: ] A file is a handle to an ordered sequence of bytes with a current
position.  Read and write permissions are set when a file object is created.

\item[hook: ] The hook type is not used by the core stil language.  It can be
used by applications that extend the interpreter as a container object.

\item[integer: ] An integer is a signed integer in the range $-2^{63}$ to
$2^{63} - 1$.

\item[mark: ] A mark is used as a stack marker for various stack operations.

\item[mutex: ] A mutex is a mutual exclusion lock.

\item[name: ] A name is a key that uniquely identifies a sequence of characters.
Two name objects that correspond to the same sequence of characters can be
compared for equality with the same approximate cost as comparing two integers
for equality.  Names are typically used as keys in dictionaries.

\item[null: ] A null has no significance other than its existence.

\item[operator: ] An operator is an operation that is built in to the
interpreter.

\item[string: ] A string is an ordered sequence of 8 bit characters.  References
to substrings within an existing string can be created in the same way that
subarrays can be created.

\end{description}

\section{Syntax}

Stil's syntax is very simple in comparison to most languages.  The scanner and
parser are implemented as a human-understandable finite state machine (nested C
switch statements with a couple of auxiliary variables), which should give then
reader an idea of the simplicity of the language syntax.

CRLF (newline, linefeed) pairs are in all important cases converted to newline
during scanning.

The characters \%, /, [, ], \{, \}, (, ), {\lt}, and {\gt} are special.  Any
of the special characters and whitespace (space, tab, newline, form feed, null)
terminate any preceding token.  All other characters including non-printing
characters are considered regular characters.

A comment starts with a \% character outside of a string context and extends to
the next newline, linefeed or formfeed.

Procedures are actually executable arrays, but stil provides special syntax for
declaring procedures.  Procedures are delimited by \{ and \}, and can be
nested.  Normally, the interpreter executes code as it is scanned, but inside of
procedure declarations, execution is deferred.  Instead of executing a procedure
body as it is encountered, the tokens of the procedure body are pushed onto the
operand stack until the closing \} is encountered, at which time an executable
array is constructed from the tokens in the procedure body and pushed onto the
operand stack.

A partial grammar specification, using BNF notation (where convenient) is as
follows:

\begin{description}
%\item[{\lt}{\gt} ::= ]

\item[{\lt}program{\gt} ::= ] {\lt}statement{\gt}

\item[{\lt}statement{\gt} ::= ] {\lt}procedure{\gt} {\lt}statement{\gt} {\pipe}
{\lt}object{\gt} {\lt}statement{\gt} {\pipe} $\epsilon$

\item[{\lt}procedure{\gt} ::= ] \{{\lt}statement{\gt}\}

\item[{\lt}object{\gt} ::= ] {\lt}integer{\gt} {\pipe} {\lt}name{\gt} {\pipe}
{\lt}string{\gt}

\item[{\lt}integer{\gt} ::= ] {\lt}dec\_integer{\gt} {\pipe}
{\lt}radix\_integer{\gt}

\item[{\lt}name{\gt} : ] Any token that cannot be interpreted as a number or a
string is interpreted as an executable name.  There are three syntaxes for
names: executable, literal and immediately evaluated.  Executable names are
looked up in the dictionary stack and executed (unless execution is deferred).
Literal names are simply pushed onto the operand stack.  Immediately evaluated
names are replaced by their values as defined in the dictionary stack, even if
execution is deferred.  Examples include:
\begin{verbatim}
foo     % executable
4noth3r % executable
/bar    % literal
//biz   % immediately evaluated
\end{verbatim}

\item[{\lt}string{\gt} ::= ] {\lt}paren\_string{\gt} {\pipe}
{\lt}tick\_string{\gt} {\pipe} {\lt}hex\_string{\gt} {\pipe}
{\lt}base64\_string{\gt}

\item[{\lt}dec\_integer{\gt} : ] Signed integer in the range $-2^{63}$ to
$2^{63} - 1$.  The sign is optional.  Examples include:
\begin{verbatim}
0
42
-365
+17
\end{verbatim}

\item[{\lt}radix\_integer{\gt} : ] Integer with explicit base between 2 and 36,
inclusive, in the range $0$ to $2^{63} - 1$.  Integer digits are composed of
decimal numbers and lower case letters.  Examples include:
\begin{verbatim}
2#101
16#ff
10#42
9#18
35#7r3x
\end{verbatim}

\item[{\lt}paren\_string{\gt} : ] ()-delimited string.  Parens may
be embedded in the string without escaping them, as long as the parens are
matched.  The following sequences have special meaning when escaped by a
``$\backslash$'' character:
	\begin{description}
	\item[( ] ``('' character.
	\item[) ] ``)'' character.
	\item[$\backslash$ ] ``$\backslash$'' character.
	\item[n ] New line.
	\item[r ] Carriage return.
	\item[t ] Tab.
	\item[b ] Backspace.
	\item[f ] Form feed.
	\item[xDD ] DD is hex encoding for a byte.
	\item[$\backslash$n (newline) ] Ignore.
	\item[$\backslash$r$\backslash$n (carriage return, newline) ] Ignore.
	\end{description}
Examples include:
\begin{verbatim}
()
(A string.)
(Balanced ( and ) are allowed.)
(An embedded \n newline.)
(Another embedded 
newline.)
(An ignored \
newline.)
(Manually escaped \( paren.)
\end{verbatim}

\item[{\lt}tick\_string{\gt} ::= ] `'-delimited string.  All characters
are interpreted literally, except that two consecutive ' characters are
interpreted as a single '.  Examples include:
\begin{verbatim}
`'
`A string.'
`A string with an embedded '' tick.'
`An extended regular expression without double escapes: \([A-Z0-9]{1,3}|foo\)'
\end{verbatim}

\item[{\lt}hex\_string{\gt} : ] {\lt}{\gt}-delimited hex encoding for a string.
Bytes are encoded by hexadecimal digit pairs (0 to 9 and lower case a through
f).  Whitespace is ignored.  Examples include:
\begin{verbatim}
<>
<0a>
<00 01ac
 4f >
\end{verbatim}

\item[{\lt}base64\_string{\gt} : ] {\lt}{\twid}{\twid}{\gt}-delimited base 64
encoding for a string.  See RFC 8045 (XXX Add bibliography entry) for base 64
encoding details.  Examples include:
\begin{verbatim}
<~~>          % `'
<~YQ==~>      % `a'
<~YWI=~>      % `ab'
<~YWJj~>      % `abc'
<~YWJj
ZA==~>        % `abcd'
\end{verbatim}
\end{description}

Arrays do not have explicit syntactic support, but the [ and ] operators support
their construction.  Examples of array construction include:
\begin{verbatim}
[]
[0 (A string) `Another string.' true]
[5
42
false]
\end{verbatim}

Dictionaries do not have explicit syntactic support, but the {\lt}{\lt} and
{\gt}{\gt} operators support their construction.  Examples of dictionary
construction include:
\begin{verbatim}
<<>>
<</answer 42 /question (Who knows) /translate {babelfish} >>
\end{verbatim}

\section{Stacks}

Stacks in stil are the core data structure that programs act on.  Stacks store
objects in a last in, first out (LIFO) fashion.  Stil includes a number of
operators that manipulate stacks.

Each stil thread has three program-visible stacks associated with it:
\begin{description}
\item[Operand stack: ] Most direct object manipulations are done using the
	operand stack.  Operators use the operand stack for inputs and outputs,
	and code generally uses the operand stack for a place to store objects
	as they are being manipulated.
\item[Dictionary stack: ] The dictionary stack is used for looking up names.
	Each thread starts with with four dictionaries on its dictionary stack,
	which are, from top to bottom:
	\begin{itemize}
	\item{userdict}
	\item{globaldict}
	\item{systemdict}
	\item{threaddict}
	\end{itemize}
	These dictionaries are discussed in detail later.
\item[Execution stack: ] The interpreter uses the execution stack to store
	objects that are being executed.  The application generally does not
	need to explicitly manipulate the execution stack, but its contents are
	accessible, mainly for debugging purposes.
\end{description}

\section{Execution}

\section{Error handling}

\section{Threads}
\subsection{Implicit synchronization}
\subsection{Explicit synchronization}

\section{Memory management}
\subsection{Allocation}
\subsection{Garbage collection}

\section{Dictionary reference}
\subsection{Operator summary}
Naming conventions.
\subsection{currenterror}
\subsection{envdict}
\subsection{errordict}
\subsection{gcdict}
\subsection{globaldict}
\subsection{systemdict}
\subsection{threaddict}
\subsection{userdict}

\section{Tutorial}

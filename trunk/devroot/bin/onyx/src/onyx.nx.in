%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Onyx <Version = onyx>
%
% This file is processed by onyx_gen.nx to produce a more compact embedded
% version in onyx_nxcode.c (normal build) and onyx_bootstrap.c (development
% bootstrap).  In order to make changes to this file take effect in the
% bootstrap interpreter, either type:
%
%   cook bootstrap
%
% or
%
%   cat onyx.nx | onyx onyx_gen.nx > onyx_boostrap.c
%
% The end result of executing this file is a procedure (executable array).  In
% order to support output that differs according to configuration options, a
% string is constructed, then evaluated.
%
% The output of running sprints on the procedure must be evaluatable, which
% means that certain language features such as immediate evaluation must be
% avoided.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Initial string with an opening brace to defer execution, to which other
% strings are catenated.
`{'

@enable_posix@ 1 eq {
    `
% ostack currently contains: %ONYX_RPATH %ONYX_MPATH

% Define ONYX_RPATH and ONYX_MPATH in envdict.  They may already be defined, in
% which case we want to prepend `:.:' and append `:%ONYX_[RM]PATH'.
%
% This code avoids prepending/appending the extra path elements if it discovers
% that the prefix/suffix are already there, as will be the case if onyx is
% recursively executed.
[
	/ONYX_MPATH /ONYX_RPATH
]{
	% %ONYX_[MR]PATH /ONYX_[MR]PATH
	envdict 1 index known {
		% Already defined.
		envdict 1 index get
		% %ONYX_[MR]PATH /ONYX_[MR]PATH %PATH
		dup `:.:' search {
			% String found.  Check if it at the beginning.
			% %ONYX_[MR]PATH /ONYX_[MR]PATH %PATH %post `:.:' %pre
			3 1 roll pop pop
			% %ONYX_[MR]PATH /ONYX_[MR]PATH %PATH %pre
			`' ne {
				% String not at beginning.  Prepend.
				% %ONYX_[MR]PATH /ONYX_[MR]PATH %PATH
				`:.:' exch catenate
			} if
		}{
			% String not found.  Prepend.
			% %ONYX_[MR]PATH /ONYX_[MR]PATH %PATH %PATH
			pop
			`:.:' exch catenate
		} ifelse
		% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'

		% Append %ONYX_[MR]PATH only if it is not already the path
		% suffix.
		dup 3 index `:' exch catenate search {
			% String found.  Check if the match is at the end.
			% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'
			% %post %ONYX_[MR]PATH %pre
			pop pop
			`' ne {
				% Match not at end.  Searching finds the first
				% match, so there iss the possibility that the
				% end of the path is in fact already set.  We
				% know that %PATH is at least as long as
				% `:%ONYX_[MR]PATH', so create a substring of
				% the end of %PATH and compare it with
				% %ONYX_[MR]PATH.

				% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'
				dup dup length
				% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'
				% `:.:%PATH' %len
				4 index length dup 3 1 roll sub exch
				% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'
				% `:.:%PATH' %index %len
				getinterval 3 index ne {
					% String not at end.  Append.
					% %ONYX_[MR]PATH /ONYX_[MR]PATH
					% `:.:%PATH'
					`:' catenate 3 2 roll catenate
				}{
					% String already at end.
					% %ONYX_[MR]PATH /ONYX_[MR]PATH
					% `:.:%PATH'
					3 2 roll pop
				} ifelse
			}{
				% Match at end.  Do not append.
				% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH'
				3 2 roll pop
			} ifelse
		}{
			% String not found.  Append.
			% %ONYX_[MR]PATH /ONYX_[MR]PATH `:.:%PATH' `:.:%PATH'
			pop
			`:' catenate 3 2 roll catenate
		} ifelse
		% /ONYX_[MR]PATH `:.:%PATH:%ONYX_[MR]PATH'
		setenv
	}{
		exch `:.:' exch catenate
		% /ONYX_[MR]PATH `:.:%ONYX_[MR]PATH'
		setenv
	} ifelse
} foreach

systemdict begin

% `filename' require -
/require {
	% Make sure the argument is a string.
	dup type /stringtype ne {
		/typecheck throw
	} if

	% /ONYX_RPATH in envdict is a colon-separated path that we need to
	% search.  Use the search operator to split the path.
	envdict /ONYX_RPATH get
	{
		% `filename' %path
		`:' search {
			% `filename' %post `:' %dir
			exch pop
			% `filename' %post %dir
			`/' catenate 2 index catenate
			% `filename' %post %filepath
			dup `f' test {
				% Found.  Clean up the stack.
				3 1 roll pop pop

				% Open the file and evaluate it.
				`r' open cvx eval
				false
				exit
			}{
				% Not found.
				pop
			} ifelse
		}{
			% Last path component.
			% `filename' %dir
			`/' catenate exch catenate
			% %filepath
			dup `f' test {
				% Found.  Open the file and evaluate it.
				`r' open cvx eval
				false
			}{
				% Not found.
				pop
				true
			} ifelse
			exit
		} ifelse
	} loop

	% Throw an error if we did not find the file.
	{
		/undefinedfilename throw
	} if
} def

% `filename' `symbol' mrequire -
/mrequire {
	% Make sure the arguments are strings.
	1 index type /stringtype ne {
		/typecheck throw
	} if
	dup type /stringtype ne {
		/typecheck throw
	} if

	% /ONYX_MPATH in envdict is a colon-separated path that we need to
	% search.  Use the search operator to split the path.
	envdict /ONYX_MPATH get
	{
		% `filename' `symbol' %path
		`:' search {
			% `filename' `symbol' %post `:' %dir
			exch pop
			% `filename' `symbol' %post %dir
			`/' catenate 3 index catenate
			% `filename' `symbol' %post %filepath
			dup `f' test {
				% Found.  Clean up the stack.
				exch pop
				exch
				3 2 roll pop

				% Load the module.
				modload
				false
				exit
			}{
				% Not found.
				pop
			} ifelse
		}{
			% Last path component.
			% `filename' `symbol' %dir
			`/' catenate 3 2 roll catenate
			% `symbol' %filepath
			dup `f' test {
				% Found.  Load the module.
				exch modload
				false
			}{
				% Not found.
				pop pop
				true
			} ifelse
			exit
		} ifelse
	} loop

	% Throw an error if we did not find the file.
	{
		/undefinedfilename throw
	} if
} def

end % systemdict.
    ' catenate
} if

% Final closing brace.
`}' catenate cvx eval

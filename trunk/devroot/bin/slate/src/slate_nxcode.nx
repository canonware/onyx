%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% <Copyright = jasone>
% <License>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Version: Slate <Version = slate>
%
% This file is processed to produce a more compact version embedded in C code.
% Due to bootstrapping issues, this cannot safely be done automatically as part
% of the build process.  In order to make changes to this file take effect,
% either type:
%
%   cook bootstrap
%
% or
%
%   cat slate_nxcode.nx | onyx slate_nxcode_gen.nx > slate_nxcode.c
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Enclose this entire file in an outer array to defer execution.
{

% ostack currently contains: %SLATE_RPATH %SLATE_MPATH

% Define SLATE_RPATH and SLATE_MPATH in envdict.  They may already be defined,
% in which case we want to prepend `:.:' and append `:%SLATE_[RM]PATH'.
%
% This code avoids prepending/appending the extra path elements if it discovers
% that the prefix/suffix are already there, as will be the case if slate is
% recursively executed.
[
	/SLATE_MPATH /SLATE_RPATH
]{
	% %SLATE_[MR]PATH /SLATE_[MR]PATH
	envdict 1 index known {
		% Already defined.
		envdict 1 index get
		% %SLATE_[MR]PATH /SLATE_[MR]PATH %PATH
		dup `:.:' search {
			% String found.  Check if it at the beginning.
			% %SLATE_[MR]PATH /SLATE_[MR]PATH %PATH %post `:.:' %pre
			3 1 roll pop pop
			% %SLATE_[MR]PATH /SLATE_[MR]PATH %PATH %pre
			`' ne {
				% String not at beginning.  Prepend.
				% %SLATE_[MR]PATH /SLATE_[MR]PATH %PATH
				`:.:' exch catenate
			} if
		}{
			% String not found.  Prepend.
			% %SLATE_[MR]PATH /SLATE_[MR]PATH %PATH %PATH
			pop
			`:.:' exch catenate
		} ifelse
		% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'

		% Append %SLATE_[MR]PATH only if it isn't already the path
		% suffix.
		dup 3 index `:' exch catenate search {
			% String found.  Check if the match is at the end.
			% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'
			% %post %SLATE_[MR]PATH %pre
			pop pop
			`' ne {
				% Match not at end.  Searching finds the first
				% match, so there's the possibility that the
				% end of the path is in fact already set.  We
				% know that %PATH is at least as long as
				% `:%SLATE_[MR]PATH', so create a substring of
				% the end of %PATH and compare it with
				% %SLATE_[MR]PATH.

				% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'
				dup dup length
				% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'
				% `:.:%PATH' %len
				4 index length dup 3 1 roll sub exch
				% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'
				% `:.:%PATH' %index %len
				getinterval 3 index ne {
					% String not at end.  Append.
					% %SLATE_[MR]PATH /SLATE_[MR]PATH
					% `:.:%PATH'
					`:' catenate 3 2 roll catenate
				}{
					% String already at end.
					% %SLATE_[MR]PATH /SLATE_[MR]PATH
					% `:.:%PATH'
					3 2 roll pop
				} ifelse
			}{
				% Match at end.  Don't append.
				% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH'
				3 2 roll pop
			} ifelse
		}{
			% String not found.  Append.
			% %SLATE_[MR]PATH /SLATE_[MR]PATH `:.:%PATH' `:.:%PATH'
			pop
			`:' catenate 3 2 roll catenate
		} ifelse
		% /SLATE_[MR]PATH `:.:%PATH:%SLATE_[MR]PATH'
		setenv
	}{
		exch `:.:' exch catenate
		% /SLATE_[MR]PATH `:.:%SLATE_[MR]PATH'
		setenv
	} ifelse
} foreach

systemdict begin

% `filename' require -
/require {
	% Make sure the argument is a string.
	dup type /stringtype ne {
		/typecheck throw
	} if

	% /SLATE_RPATH in envdict is a colon-separated path that we need to
	% search.  Use the search operator to split the path.
	envdict /SLATE_RPATH get
	{
		% `filename' %path
		`:' search {
			% `filename' %post `:' %dir
			exch pop
			% `filename' %post %dir
			`/' catenate 2 index catenate
			% `filename' %post %filepath
			dup `f' test {
				% Found.  Clean up the stack.
				3 1 roll pop pop

				% Open the file and evaluate it.
				`r' open cvx eval
				false
				exit
			}{
				% Not found.
				pop
			} ifelse
		}{
			% Last path component.
			% `filename' %dir
			`/' catenate exch catenate
			% %filepath
			dup `f' test {
				% Found.  Open the file and evaluate it.
				`r' open cvx eval
				false
			}{
				% Not found.
				pop
				true
			} ifelse
			exit
		} ifelse
	} loop

	% Throw an error if we didn't find the file.
	{
		/undefinedfilename throw
	} if
} def

% `filename' `symbol' mrequire -
/mrequire {
	% Make sure the arguments are strings.
	1 index type /stringtype ne {
		/typecheck throw
	} if
	dup type /stringtype ne {
		/typecheck throw
	} if

	% /SLATE_MPATH in envdict is a colon-separated path that we need to
	% search.  Use the search operator to split the path.
	envdict /SLATE_MPATH get
	{
		% `filename' `symbol' %path
		`:' search {
			% `filename' `symbol' %post `:' %dir
			exch pop
			% `filename' `symbol' %post %dir
			`/' catenate 3 index catenate
			% `filename' `symbol' %post %filepath
			dup `f' test {
				% Found.  Clean up the stack.
				exch pop
				exch
				3 2 roll pop

				% Load the module.
				modload
				false
				exit
			}{
				% Not found.
				pop
			} ifelse
		}{
			% Last path component.
			% `filename' `symbol' %dir
			`/' catenate 3 2 roll catenate
			% `symbol' %filepath
			dup `f' test {
				% Found.  Load the module.
				exch modload
				false
			}{
				% Not found.
				pop pop
				true
			} ifelse
			exit
		} ifelse
	} loop

	% Throw an error if we didn't find the file.
	{
		/undefinedfilename throw
	} if
} def

end % systemdict.

} % End deferral.

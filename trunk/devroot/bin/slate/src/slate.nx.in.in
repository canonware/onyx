# -*- mode: onyx -*-
################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Slate <Version = slate>
#
# Entry point for the slate text editor.
#
################################################################################

# Add slate paths.
onyxdict begin
$rpath_post rpath_post [@slate_rpath_post@] cat def
$mpath_post mpath_post [@slate_mpath_post@] cat def
end

`modslate/modslate.nx' require

# Move slatedict to the bottom of dstack.
slatedict begin
dstack saup

# - hs -
$hs {
    # ANSI home cursor sequence: `\e[H'
    `\e[H' print
} def

# - cs -
$cs {
    # ANSI clear screen sequence: `\e[2J'
    `\e[2J' print
    hs
} def

# #=buffer= buffer_name #name
$buffer_name {
    buffer_aux_get $name get
} def

# - status_line -
$status_line {
    # Reverse video.
    `\e[7m' print

    # History.
    scratch buffer_undoable {
	` [<' print
    }{
	` [[' print
    } ifelse
    scratch buffer_history_active {
	`+' print
    }{
	`-' print
    } ifelse
    scratch buffer_redoable {
	`>]' print
    }{
	`]]' print
    } ifelse

    # Line.
    ` L' print
    bpoint marker_line cvs print
    `/' print
    scratch buffer_lines cvs print

    # Column.
    ` C' print
    tpoint dup 0 bpoint marker_seek
    exch -1 marker_seekline
    sub cvs print
    `/' print
    tpoint dup 0 bpoint marker_seek pop
    dup 1 marker_seekline
    exch -1 marker_seekline
    sub cvs print

    # Position.
    ` p' print
    bpoint marker_position cvs print
    `/' print
    scratch buffer_length inc cvs print

    # Mark.
    ` m' print
    bmark marker_position cvs print

    # Buffer name.
    ` ' print
    scratch buffer_name print

    `\r\n' print
    # Reset attributes.
    `\e[m' print
} def

# #=buffer= b2s #string
$b2s {
    tmark dup 0 $SEEK_BOB marker_seek pop
    tpoint dup 0 $SEEK_EOB marker_seek pop
    marker_range_get
} def

# #string srender -
$srender {
    {
	dup 16@a eq {
	    `\r' print
	} if
	stdout exch write pop
    } foreach
} def

# - redisplay -
$redisplay {
    cs
    status_line

    scratch b2s
#    stderr over 1 sprints write stderr `\n' write pop
    srender

    hs
    `\r\n' print
    tpoint dup 0 $SEEK_BOB marker_seek pop bpoint marker_range_get
    srender flush
#    scratch `redisplay ' buffer_dump
} def

# - getc #string
$getc {
    stdin ` ' read
    true eq {
	quit
    } if
} def

# #string self_insert_char -
$insert_string {
    bpoint exch marker_before_insert
#    scratch `insert_string ' buffer_dump
} def

# Undefined characters are inserted literally.
$keytable <
    `\b' {
	bmark dup 0 bpoint marker_seek pop
	bpoint dup -1 marker_seek pop
	marker_range_cut pop
    }
    # Delete.
    `\x7f' {
	bmark dup 0 bpoint marker_seek pop
	bpoint dup -1 marker_seek pop
	marker_range_cut pop
    }
    `\cd' {
	bmark dup 0 bpoint marker_seek pop
	bpoint dup 1 marker_seek pop
	marker_range_cut pop
    }
    `\r' {
	`\n' insert_string
    }
    `\cq' {
	`\r\n' print gcdict $stats get eval 2 sprint flush
	quit
    }
    `\cu' {
	bpoint buffer_undo
    }
    `\cr' {
	bpoint buffer_redo
    }
    `\cb' {
	bpoint -1 marker_seek pop
    }
    `\cf' {
	bpoint 1 marker_seek pop
    }
    # C-space
    `\x00' {
	bmark 0 bpoint marker_seek pop
    }
    `\cw' {
	scratch bpoint buffer_history_startgroup
	bmark bpoint marker_range_cut pop
	scratch buffer_history_endgroup
    }
    `\ca' {
	bpoint -1 marker_seekline
    }
    `\ce' {
	bpoint 1 marker_seekline
    }
    `\ct' {
	stdin readline pop
	dup length dec 0 1 dn {
	    2 ndup get 16@d eq {
		# Replace \n with \r.
		2 ndup 16@a put
	    } if
	    pop
	} for
	insert_string
    }
    `\cv' {
	`ABCDEFGH' insert_string
    }
    `\cx' {
	scratch `dump ' buffer_dump
    }
    `\cy' {
	scratch dup buffer_history_active
	not buffer_history_setactive
    }
    `\cc' {
	quit
    }
> def

# #string interpc -
$interpc {
#    stderr 1 idup cvs write pop stderr `\n' write pop
#    scratch `interpc ' buffer_dump
    keytable 1 idup known {
	keytable exch get eval
    }{
	insert_string
    } ifelse
} def

$scratch buffer def
$bpoint scratch marker def
$tpoint scratch marker def
$bmark scratch marker def
$tmark scratch marker def

scratch <
    $name	`*scratch*'
> buffer_aux_set

2 gcdict $setperiod get eval

# scratch true buffer_history_setactive

stdin 0 setiobuf {
    redisplay
    getc
    interpc
} loop

# -*- mode: onyx -*-
################################################################################
#
# <Copyright = jasone>
# <License>
#
################################################################################
#
# Version: Slate <Version = slate>
#
# Entry point for the slate text editor.
#
################################################################################

# Add slate paths.
onyxdict begin
$rpath_post rpath_post [@slate_rpath_post@] cat def
$mpath_post mpath_post [@slate_mpath_post@] cat def
end

`modslate/modslate.nx' require

# Move slatedict to the bottom of dstack.
slatedict begin
dstack saup

`modpane/modpane.nx' require

# Move panedict to the bottom of dstack.
panedict begin
dstack saup

# - hs -
$hs {
    # ANSI home cursor sequence: `\e[H'
    `\e[H' print
} def

# - cs -
$cs {
    # ANSI clear screen sequence: `\e[2J'
    `\e[2J' print
    hs
} def

# - status_line -
$status_line {
    # Reverse video.
    `\e[7m' print

    # History.
    scratch:undoable {
	` [<' print
    }{
	` [[' print
    } ifelse
    scratch:history_active {
	`+' print
    }{
	`-' print
    } ifelse
    scratch:redoable {
	`>]' print
    }{
	`]]' print
    } ifelse

    # Line.
    ` L' print
    bpoint:line cvs print
    `/' print
    scratch:lines cvs print

    # Column.
    ` C' print
    0 bpoint tpoint:seek
    -1 tpoint:seekline
    sub cvs print
    `/' print
    0 bpoint tpoint:seek pop
    1 tpoint:seekline
    -1 tpoint:seekline
    sub cvs print

    # Position.
    ` p' print
    bpoint:position cvs print
    `/' print
    scratch:length inc cvs print

    # Mark.
    ` m' print
    bmark:position cvs print

    # Buffer name.
    ` ' print
    scratch:name print

    `\r\n' print
    # Reset attributes.
    `\e[m' print
} def

#buffer b2s #string
$b2s {
    pop
    0 $SEEK_BOB tmark:seek pop
    0 $SEEK_EOB tpoint:seek pop
    tmark tpoint:range_get
} def

#string srender -
$srender {
    {
	dup 16@a eq {
	    `\r' print
	} if
	stdout exch write pop
    } foreach
} def

# - redisplay -
$redisplay {
    cs
    status_line

    scratch b2s
    srender

    hs
    `\r\n' print

    0 $SEEK_BOB tpoint:seek pop
    tpoint bpoint:range_get
    srender flush
} def

# - getc #string
$getc {
    stdin ` ' read
    true eq {
	quit
    } if
} def

#string self_insert_char -
$insert_string {
    bpoint:before_insert
} def

# Undefined characters are inserted literally.
$keytable <
    `\b' {
	0 bpoint bmark:seek pop
	-1 bpoint:seek pop
	bmark bpoint:range_cut pop
    }
    # Delete.
    `\x7f' {
	0 bpoint bmark:seek pop
	-1 bpoint:seek pop
	bmark bpoint:range_cut pop
    }
    `\cd' {
	0 bpoint bmark:seek pop
	1 bpoint:seek pop
	bmark bpoint:range_cut pop
    }
    `\r' {
	`\n' insert_string
    }
    `\cn' {
	bpoint scratch:history_startgroup
	gcdict $stats get eval 2 sprints
	insert_string
	scratch:history_endgroup
    }
    `\cq' {
	`\r\nslate GC stats: '
	gcdict $stats get eval 2 sprints
	`\n'
	3 ncat
	stderr exch write pop
	exit
    }
    `\cu' {
	1 bpoint scratch:undo
    }
    `\cr' {
	1 bpoint scratch:redo
    }
    `\cb' {
	-1 bpoint:seek pop
    }
    `\cf' {
	1 bpoint:seek pop
    }
    # C-space
    `\x00' {
	0 bpoint bmark:seek pop
    }
    `\ck' {
	# Move bmark to eol.
	0 bpoint bmark:seek pop
	1 bmark:seekline

	# Cut if there are any data to remove.
	bpoint bmark:range_get length 0 gt {
	    # Start group.
	    bpoint scratch:history_startgroup

	    # Cut.
	    bpoint bmark:range_cut pop

	    # End group.
	    scratch:history_endgroup
	} if
    }
    `\cw' {
	bpoint scratch:history_startgroup
	bmark bpoint:range_cut pop
	scratch:history_endgroup
    }
    `\ca' {
	-1 bpoint:seekline
    }
    `\ce' {
	1 bpoint:seekline
    }
    `\cs' {
	bpoint scratch:history_startgroup
    }
    `\cg' {
	scratch:history_endgroup
    }
    `\ct' {
	stdin readline pop
	dup length dec 0 1 dn {
	    2 ndup get 16@d eq {
		# Replace \n with \r.
		2 ndup 16@a put
	    } if
	    pop
	} for
	insert_string
    }
    `\cv' {
	`<12345678901234567890123456789012345678901234567890123456789012>'
	insert_string
    }
    `\cx' {
	`dump ' scratch:dump
    }
    `\cy' {
	scratch:history_active
	not scratch:history_setactive
    }
    `\cc' {
	exit
    }
> def

#string interpc -
$interpc {
    keytable 1 idup known {
	keytable exch get eval
    }{
	insert_string
    } ifelse
} def

$scratch 16 buffer:new def
$bpoint scratch marker:new def
$tpoint scratch marker:new def
$bmark scratch marker:new def
$tmark scratch marker:new def

`*scratch*' scratch:setname

true scratch:history_setactive

$disp envdict $TERM get stdin stdout display:new def
disp:start

stdin 0 setiobuf {
    redisplay
    getc
    interpc
    scratch:validate
} loop

disp:stop
